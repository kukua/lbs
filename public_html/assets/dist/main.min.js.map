{"version":3,"sources":["jquery.js","bootstrap.js","moment-with-locales.js","daterangepicker.js","highcharts.src.js","highcharts-more.src.js","chart.js","graph.js","helpers.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1/RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3zEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxvTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtgDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3hmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1mFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.min.js","sourcesContent":["/*!\n * jQuery JavaScript Library v2.1.4\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2015-04-28T16:01Z\n */\n\n(function( global, factory ) {\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n}(typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Support: Firefox 18+\n// Can't be in strict mode, several libs including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n//\n\nvar arr = [];\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar support = {};\n\n\n\nvar\n\t// Use the correct document accordingly with window argument (sandbox)\n\tdocument = window.document,\n\n\tversion = \"2.1.4\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android<4.1\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num != null ?\n\n\t\t\t// Return just the one element from the set\n\t\t\t( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n\t\t\t// Return all the elements in a clean array\n\t\t\tslice.call( this );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor(null);\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend({\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type(obj) === \"function\";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t// adding 1 corrects loss of precision from parseFloat (#15100)\n\t\treturn !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\t// Not plain objects:\n\t\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n\t\t// - DOM nodes\n\t\t// - window\n\t\tif ( jQuery.type( obj ) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( obj.constructor &&\n\t\t\t\t!hasOwn.call( obj.constructor.prototype, \"isPrototypeOf\" ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If the function hasn't returned already, we're confident that\n\t\t// |obj| is a plain object, created by {} or constructed with new Object\n\t\treturn true;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\t\t// Support: Android<4.0, iOS<6 (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call(obj) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tvar script,\n\t\t\tindirect = eval;\n\n\t\tcode = jQuery.trim( code );\n\n\t\tif ( code ) {\n\t\t\t// If the code includes a valid, prologue position\n\t\t\t// strict mode pragma, execute code by injecting a\n\t\t\t// script tag into the document.\n\t\t\tif ( code.indexOf(\"use strict\") === 1 ) {\n\t\t\t\tscript = document.createElement(\"script\");\n\t\t\t\tscript.text = code;\n\t\t\t\tdocument.head.appendChild( script ).parentNode.removeChild( script );\n\t\t\t} else {\n\t\t\t// Otherwise, avoid the DOM node creation, insertion\n\t\t\t// and removal by using an indirect global eval\n\t\t\t\tindirect( code );\n\t\t\t}\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE9-11+\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( obj, callback, args ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = obj.length,\n\t\t\tisArray = isArraylike( obj );\n\n\t\tif ( args ) {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android<4.1\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tisArray = isArraylike( elems ),\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArray ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n});\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n\n\t// Support: iOS 8.2 (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = \"length\" in obj && obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\tif ( obj.nodeType === 1 && length ) {\n\t\treturn true;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.2.0-pre\n * http://sizzlejs.com/\n *\n * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-12-16\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// General-purpose constants\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// http://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t// http://www.w3.org/TR/css3-syntax/#characters\n\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t// Loosely modeled on CSS identifier characters\n\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + characterEncoding + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\trescape = /'|\\\\/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar match, elem, m, nodeType,\n\t\t// QSA vars\n\t\ti, groups, old, nid, newContext, newSelector;\n\n\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\n\tcontext = context || document;\n\tresults = results || [];\n\tnodeType = context.nodeType;\n\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\tif ( !seed && documentIsHTML ) {\n\n\t\t// Try to shortcut find operations when possible (e.g., not under DocumentFragment)\n\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\tif ( (m = match[1]) ) {\n\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document (jQuery #6963)\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Context is not a document\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t} else if ( match[2] ) {\n\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\treturn results;\n\n\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName ) {\n\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\n\t\t// QSA path\n\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\t\tnid = old = expando;\n\t\t\tnewContext = context;\n\t\t\tnewSelector = nodeType !== 1 && selector;\n\n\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t// IE 8 doesn't work on object elements\n\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\tgroups = tokenize( selector );\n\n\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\t\t\t\t} else {\n\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t}\n\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\ti = groups.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t}\n\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;\n\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t}\n\n\t\t\tif ( newSelector ) {\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch(qsaError) {\n\t\t\t\t} finally {\n\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement(\"div\");\n\n\ttry {\n\t\treturn !!fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( div.parentNode ) {\n\t\t\tdiv.parentNode.removeChild( div );\n\t\t}\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = attrs.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, parent,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// If no document and documentElement is available, return\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Set our document\n\tdocument = doc;\n\tdocElem = doc.documentElement;\n\tparent = doc.defaultView;\n\n\t// Support: IE>8\n\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n\t// IE6-8 do not support the defaultView property so parent will be undefined\n\tif ( parent && parent !== parent.top ) {\n\t\t// IE11 does not have attachEvent, so all must suffer\n\t\tif ( parent.addEventListener ) {\n\t\t\tparent.addEventListener( \"unload\", unloadHandler, false );\n\t\t} else if ( parent.attachEvent ) {\n\t\t\tparent.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Support tests\n\t---------------------------------------------------------------------- */\n\tdocumentIsHTML = !isXML( doc );\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.className = \"i\";\n\t\treturn !div.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( div ) {\n\t\tdiv.appendChild( doc.createComment(\"\") );\n\t\treturn !div.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( doc.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( div ) {\n\t\tdocElem.appendChild( div ).id = expando;\n\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n\t});\n\n\t// ID find and filter\n\tif ( support.getById ) {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\treturn m && m.parentNode ? [ m ] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Support: IE6/7\n\t\t// getElementById is not reliable as a find shortcut\n\t\tdelete Expr.find[\"ID\"];\n\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See http://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( div ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\f]' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( div.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+\n\t\t\tif ( !div.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibing-combinator selector` fails\n\t\t\tif ( !div.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = doc.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tdiv.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( div.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully does not implement inclusive descendent\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === doc ? -1 :\n\t\t\t\tb === doc ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn doc;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t\"disabled\": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\tif ( (oldCache = outerCache[ dir ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\touterCache[ dir ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context !== document && context;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\tmatchedCount += i;\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is no seed and only one group\n\tif ( match.length === 1 ) {\n\n\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\trsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n\t// Should return 1, but returns 4 (following)\n\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( div ) {\n\tdiv.innerHTML = \"<input/>\";\n\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n\treturn div.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = (/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/);\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t/* jshint -W018 */\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t});\n\n\t}\n\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t});\n\n\t}\n\n\tif ( typeof qualifier === \"string\" ) {\n\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t}\n\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) >= 0 ) !== not;\n\t});\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t}));\n};\n\njQuery.fn.extend({\n\tfind: function( selector ) {\n\t\tvar i,\n\t\t\tlen = this.length,\n\t\t\tret = [],\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}) );\n\t\t}\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\treturn ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], false) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], true) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n});\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\tinit = jQuery.fn.init = function( selector, context ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[0] === \"<\" && selector[ selector.length - 1 ] === \">\" && selector.length >= 3 ) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t// Support: Blackberry 4.6\n\t\t\t\t\t// gEBID returns nodes no longer in the document (#6963)\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn typeof rootjQuery.ready !== \"undefined\" ?\n\t\t\t\trootjQuery.ready( selector ) :\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.extend({\n\tdir: function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\ttruncate = until !== undefined;\n\n\t\twhile ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatched.push( elem );\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t},\n\n\tsibling: function( n, elem ) {\n\t\tvar matched = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tmatched.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn matched;\n\t}\n});\n\njQuery.fn.extend({\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter(function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n\t\t\t\t// Always skip document fragments\n\t\t\t\tif ( cur.nodeType < 11 && (pos ?\n\t\t\t\t\tpos.index(cur) > -1 :\n\n\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\n\n\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.unique(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t);\n\t}\n});\n\nfunction sibling( cur, dir ) {\n\twhile ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each({\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn jQuery.sibling( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.unique( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n});\nvar rnotwhite = (/\\S+/g);\n\n\n\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// Flag to know if list is currently firing\n\t\tfiring,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\tfiringLength = 0;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// Add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\n\n\n// The deferred used on DOM ready\nvar readyList;\n\njQuery.fn.ready = function( fn ) {\n\t// Add the callback\n\tjQuery.ready.promise().done( fn );\n\n\treturn this;\n};\n\njQuery.extend({\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.triggerHandler ) {\n\t\t\tjQuery( document ).triggerHandler( \"ready\" );\n\t\t\tjQuery( document ).off( \"ready\" );\n\t\t}\n\t}\n});\n\n/**\n * The ready event handler and self cleanup method\n */\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\twindow.removeEventListener( \"load\", completed, false );\n\tjQuery.ready();\n}\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t// We once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\tsetTimeout( jQuery.ready );\n\n\t\t} else {\n\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", completed, false );\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n// Kick off the DOM ready check even if the user does not\njQuery.ready.promise();\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chainable ?\n\t\telems :\n\n\t\t// Gets\n\t\tbulk ?\n\t\t\tfn.call( elems ) :\n\t\t\tlen ? fn( elems[0], key ) : emptyGet;\n};\n\n\n/**\n * Determines whether an object can have data\n */\njQuery.acceptData = function( owner ) {\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\t/* jshint -W018 */\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\nfunction Data() {\n\t// Support: Android<4,\n\t// Old WebKit does not have Object.preventExtensions/freeze method,\n\t// return new empty object instead with no [[set]] accessor\n\tObject.defineProperty( this.cache = {}, 0, {\n\t\tget: function() {\n\t\t\treturn {};\n\t\t}\n\t});\n\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\nData.accepts = jQuery.acceptData;\n\nData.prototype = {\n\tkey: function( owner ) {\n\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t// but we should not, see #8335.\n\t\t// Always return the key for a frozen object.\n\t\tif ( !Data.accepts( owner ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar descriptor = {},\n\t\t\t// Check if the owner object already has a cache key\n\t\t\tunlock = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !unlock ) {\n\t\t\tunlock = Data.uid++;\n\n\t\t\t// Secure it in a non-enumerable, non-writable property\n\t\t\ttry {\n\t\t\t\tdescriptor[ this.expando ] = { value: unlock };\n\t\t\t\tObject.defineProperties( owner, descriptor );\n\n\t\t\t// Support: Android<4\n\t\t\t// Fallback to a less secure definition\n\t\t\t} catch ( e ) {\n\t\t\t\tdescriptor[ this.expando ] = unlock;\n\t\t\t\tjQuery.extend( owner, descriptor );\n\t\t\t}\n\t\t}\n\n\t\t// Ensure the cache object\n\t\tif ( !this.cache[ unlock ] ) {\n\t\t\tthis.cache[ unlock ] = {};\n\t\t}\n\n\t\treturn unlock;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\t// There may be an unlock assigned to this node,\n\t\t\t// if there is no entry for this \"owner\", create one inline\n\t\t\t// and set the unlock as though an owner entry had always existed\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\t// Handle: [ owner, key, value ] args\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ data ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\t\t\t// Fresh assignments by object are shallow copied\n\t\t\tif ( jQuery.isEmptyObject( cache ) ) {\n\t\t\t\tjQuery.extend( this.cache[ unlock ], data );\n\t\t\t// Otherwise, copy the properties one-by-one to the cache object\n\t\t\t} else {\n\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\t// Either a valid cache is found, or will be created.\n\t\t// New caches will be created and the unlock returned,\n\t\t// allowing direct access to the newly created\n\t\t// empty data object. A valid owner object must be provided.\n\t\tvar cache = this.cache[ this.key( owner ) ];\n\n\t\treturn key === undefined ?\n\t\t\tcache : cache[ key ];\n\t},\n\taccess: function( owner, key, value ) {\n\t\tvar stored;\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t((key && typeof key === \"string\") && value === undefined) ) {\n\n\t\t\tstored = this.get( owner, key );\n\n\t\t\treturn stored !== undefined ?\n\t\t\t\tstored : this.get( owner, jQuery.camelCase(key) );\n\t\t}\n\n\t\t// [*]When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i, name, camel,\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\tif ( key === undefined ) {\n\t\t\tthis.cache[ unlock ] = {};\n\n\t\t} else {\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t} else {\n\t\t\t\tcamel = jQuery.camelCase( key );\n\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\tif ( key in cache ) {\n\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t} else {\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tname = camel;\n\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t[ name ] : ( name.match( rnotwhite ) || [] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = name.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\treturn !jQuery.isEmptyObject(\n\t\t\tthis.cache[ owner[ this.expando ] ] || {}\n\t\t);\n\t},\n\tdiscard: function( owner ) {\n\t\tif ( owner[ this.expando ] ) {\n\t\t\tdelete this.cache[ owner[ this.expando ] ];\n\t\t}\n\t}\n};\nvar data_priv = new Data();\n\nvar data_user = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /([A-Z])/g;\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdata_user.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend({\n\thasData: function( elem ) {\n\t\treturn data_user.hasData( elem ) || data_priv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn data_user.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdata_user.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to data_priv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn data_priv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdata_priv.remove( elem, name );\n\t}\n});\n\njQuery.fn.extend({\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = data_user.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !data_priv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE11+\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata_priv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tdata_user.set( this, key );\n\t\t\t});\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data,\n\t\t\t\tcamelKey = jQuery.camelCase( key );\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key as-is\n\t\t\t\tdata = data_user.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key camelized\n\t\t\t\tdata = data_user.get( elem, camelKey );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, camelKey, undefined );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each(function() {\n\t\t\t\t// First, attempt to store a copy or reference of any\n\t\t\t\t// data that might've been store with a camelCased key.\n\t\t\t\tvar data = data_user.get( this, camelKey );\n\n\t\t\t\t// For HTML5 data-* attribute interop, we have to\n\t\t\t\t// store property names with dashes in a camelCase form.\n\t\t\t\t// This might not apply to all properties...*\n\t\t\t\tdata_user.set( this, camelKey, value );\n\n\t\t\t\t// *... In the case of properties that might _actually_\n\t\t\t\t// have dashes, we need to also store a copy of that\n\t\t\t\t// unchanged property.\n\t\t\t\tif ( key.indexOf(\"-\") !== -1 && data !== undefined ) {\n\t\t\t\t\tdata_user.set( this, key, value );\n\t\t\t\t}\n\t\t\t});\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each(function() {\n\t\t\tdata_user.remove( this, key );\n\t\t});\n\t}\n});\n\n\njQuery.extend({\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = data_priv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = data_priv.access( elem, type, jQuery.makeArray(data) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn data_priv.get( elem, key ) || data_priv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\tdata_priv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t})\n\t\t});\n\t}\n});\n\njQuery.fn.extend({\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n});\nvar pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHidden = function( elem, el ) {\n\t\t// isHidden might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\t\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n\t};\n\nvar rcheckableType = (/^(?:checkbox|radio)$/i);\n\n\n\n(function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Safari<=5.1\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Safari<=5.1, Android<4.2\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE<=11+\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n})();\nvar strundefined = typeof undefined;\n\n\n\nsupport.focusinBubbles = \"onfocusin\" in window;\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !(events = elemData.events) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend({\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.hasData( elem ) && data_priv.get( elem );\n\n\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdelete elemData.handle;\n\t\t\tdata_priv.remove( elem, \"events\" );\n\t\t}\n\t},\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf(\".\") >= 0 ) {\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join(\".\");\n\t\tevent.namespace_re = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( data_priv.get( cur, \"events\" ) || {} )[ event.type ] && data_priv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && jQuery.acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n\t\t\t\tjQuery.acceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, j, ret, matched, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\targs = slice.call( arguments ),\n\t\t\thandlers = ( data_priv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[0] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, matches, sel, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.disabled !== true || event.type !== \"click\" ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\t\t\tvar eventDoc, doc, body,\n\t\t\t\tbutton = original.button;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don't use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: Cordova 2.5 (WebKit) (#13255)\n\t\t// All events should have a target; Cordova deviceready doesn't\n\t\tif ( !event.target ) {\n\t\t\tevent.target = document;\n\t\t}\n\n\t\t// Support: Safari 6.0+, Chrome<28\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\tspecial: {\n\t\tload: {\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsimulate: function( type, elem, event, bubble ) {\n\t\t// Piggyback on a donor event to simulate a different one.\n\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t// simulated event prevents default then we do the same on the donor.\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t}\n\t\t);\n\t\tif ( bubble ) {\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t} else {\n\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t}\n\t\tif ( e.isDefaultPrevented() ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle, false );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\t// Allow instantiation without the 'new' keyword\n\tif ( !(this instanceof jQuery.Event) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\t\t\t\t// Support: Android<4.0\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && e.preventDefault ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopImmediatePropagation ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// Support: Chrome 15+\njQuery.each({\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\n// Support: Firefox, Chrome, Safari\n// Create \"bubbling\" focus and blur events\nif ( !support.focusinBubbles ) {\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = data_priv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdata_priv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = data_priv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdata_priv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdata_priv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\njQuery.fn.extend({\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\tvar origFn, type;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( data == null && fn == null ) {\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t});\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn this.on( types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t});\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[0];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n});\n\n\nvar\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\trtagName = /<([\\w:]+)/,\n\trhtml = /<|&#?\\w+;/,\n\trnoInnerhtml = /<(?:script|style|link)/i,\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\t// We have to close these tags to support XHTML (#13200)\n\twrapMap = {\n\n\t\t// Support: IE9\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t\t_default: [ 0, \"\", \"\" ]\n\t};\n\n// Support: IE9\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n// Support: 1.x compatibility\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n\treturn jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ?\n\n\t\telem.getElementsByTagName(\"tbody\")[0] ||\n\t\t\telem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n\t\telem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute(\"type\");\n\t}\n\n\treturn elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdata_priv.set(\n\t\t\telems[ i ], \"globalEval\", !refElements || data_priv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( data_priv.hasData( src ) ) {\n\t\tpdataOld = data_priv.access( src );\n\t\tpdataCur = data_priv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( data_user.hasData( src ) ) {\n\t\tudataOld = data_user.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdata_user.set( dest, udataCur );\n\t}\n}\n\nfunction getAll( context, tag ) {\n\tvar ret = context.getElementsByTagName ? context.getElementsByTagName( tag || \"*\" ) :\n\t\t\tcontext.querySelectorAll ? context.querySelectorAll( tag || \"*\" ) :\n\t\t\t[];\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], ret ) :\n\t\tret;\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\njQuery.extend({\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\tvar elem, tmp, tag, wrap, contains, j,\n\t\t\tfragment = context.createDocumentFragment(),\n\t\t\tnodes = [],\n\t\t\ti = 0,\n\t\t\tl = elems.length;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\n\t\t\tif ( elem || elem === 0 ) {\n\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\t\t// Support: QtWebKit, PhantomJS\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement(\"div\") );\n\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[ 2 ];\n\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[ 0 ];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: QtWebKit, PhantomJS\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove wrapper from fragment\n\t\tfragment.textContent = \"\";\n\n\t\ti = 0;\n\t\twhile ( (elem = nodes[ i++ ]) ) {\n\n\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t// that element, do not do anything\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fragment;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type, key,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[ i ]) !== undefined; i++ ) {\n\t\t\tif ( jQuery.acceptData( elem ) ) {\n\t\t\t\tkey = elem[ data_priv.expando ];\n\n\t\t\t\tif ( key && (data = data_priv.cache[ key ]) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( data_priv.cache[ key ] ) {\n\t\t\t\t\t\t// Discard any remaining `private` data\n\t\t\t\t\t\tdelete data_priv.cache[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Discard any remaining `user` data\n\t\t\tdelete data_user.cache[ elem[ data_user.expando ] ];\n\t\t}\n\t}\n});\n\njQuery.fn.extend({\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each(function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t});\n\t},\n\n\tafter: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t});\n\t},\n\n\tremove: function( selector, keepData /* Internal Use Only */ ) {\n\t\tvar elem,\n\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t}\n\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\t\t\t\t}\n\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map(function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar arg = arguments[ 0 ];\n\n\t\t// Make the changes, replacing each context element with the new content\n\t\tthis.domManip( arguments, function( elem ) {\n\t\t\targ = this.parentNode;\n\n\t\t\tjQuery.cleanData( getAll( this ) );\n\n\t\t\tif ( arg ) {\n\t\t\t\targ.replaceChild( elem, this );\n\t\t\t}\n\t\t});\n\n\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\treturn arg && (arg.length || arg.nodeType) ? this : this.remove();\n\t},\n\n\tdetach: function( selector ) {\n\t\treturn this.remove( selector, true );\n\t},\n\n\tdomManip: function( args, callback ) {\n\n\t\t// Flatten any nested arrays\n\t\targs = concat.apply( [], args );\n\n\t\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tset = this,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[ 0 ],\n\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction ||\n\t\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\t\treturn this.each(function( index ) {\n\t\t\t\tvar self = set.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t\t}\n\t\t\t\tself.domManip( args, callback );\n\t\t\t});\n\t\t}\n\n\t\tif ( l ) {\n\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\tif ( first ) {\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t\t\t// jQuery.merge because push.apply(_, arraylike) throws\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback.call( this[ i ], node, i );\n\t\t\t\t}\n\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!data_priv.access( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.globalEval( node.textContent.replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\njQuery.each({\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: QtWebKit\n\t\t\t// .get() because push.apply(_, arraylike) throws\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\n\n\nvar iframe,\n\telemdisplay = {};\n\n/**\n * Retrieve the actual display of a element\n * @param {String} name nodeName of the element\n * @param {Object} doc Document object\n */\n// Called only from within defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar style,\n\t\telem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n\t\t// getDefaultComputedStyle might be reliably used only on attached element\n\t\tdisplay = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?\n\n\t\t\t// Use of this method is a temporary fix (more like optimization) until something better comes along,\n\t\t\t// since it was removed from specification and supported only in FF\n\t\t\tstyle.display : jQuery.css( elem[ 0 ], \"display\" );\n\n\t// We don't have any data stored on the element,\n\t// so use \"detach\" method as fast way to get rid of the element\n\telem.detach();\n\n\treturn display;\n}\n\n/**\n * Try to determine the default display value of an element\n * @param {String} nodeName\n */\nfunction defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === \"none\" || !display ) {\n\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = (iframe || jQuery( \"<iframe frameborder='0' width='0' height='0'/>\" )).appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\tdoc = iframe[ 0 ].contentDocument;\n\n\t\t\t// Support: IE\n\t\t\tdoc.write();\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\nvar rmargin = (/^margin/);\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\t\t// Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tif ( elem.ownerDocument.defaultView.opener ) {\n\t\t\treturn elem.ownerDocument.defaultView.getComputedStyle( elem, null );\n\t\t}\n\n\t\treturn window.getComputedStyle( elem, null );\n\t};\n\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// Support: IE9\n\t// getPropertyValue is only needed for .css('filter') (#12537)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\t}\n\n\tif ( computed ) {\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// Support: iOS < 6\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\t\t// Support: IE\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn (this.get = hookFn).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\n(function() {\n\tvar pixelPositionVal, boxSizingReliableVal,\n\t\tdocElem = document.documentElement,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE9-11+\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tcontainer.style.cssText = \"border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;\" +\n\t\t\"position:absolute\";\n\tcontainer.appendChild( div );\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computePixelPositionAndBoxSizingReliable() {\n\t\tdiv.style.cssText =\n\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t// Vendor-prefix box-sizing\n\t\t\t\"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" +\n\t\t\t\"box-sizing:border-box;display:block;margin-top:1%;top:1%;\" +\n\t\t\t\"border:1px;padding:1px;width:4px;position:absolute\";\n\t\tdiv.innerHTML = \"\";\n\t\tdocElem.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div, null );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\n\t\tdocElem.removeChild( container );\n\t}\n\n\t// Support: node.js jsdom\n\t// Don't assume that getComputedStyle is a property of the global object\n\tif ( window.getComputedStyle ) {\n\t\tjQuery.extend( support, {\n\t\t\tpixelPosition: function() {\n\n\t\t\t\t// This test is executed only once but we still do memoizing\n\t\t\t\t// since we can use the boxSizingReliable pre-computing.\n\t\t\t\t// No need to check if the test was already performed, though.\n\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\treturn pixelPositionVal;\n\t\t\t},\n\t\t\tboxSizingReliable: function() {\n\t\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\t}\n\t\t\t\treturn boxSizingReliableVal;\n\t\t\t},\n\t\t\treliableMarginRight: function() {\n\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t// This support function is only executed once so no memoizing is needed.\n\t\t\t\tvar ret,\n\t\t\t\t\tmarginDiv = div.appendChild( document.createElement( \"div\" ) );\n\n\t\t\t\t// Reset CSS: box-sizing; display; margin; border; padding\n\t\t\t\tmarginDiv.style.cssText = div.style.cssText =\n\t\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\t\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n\t\t\t\t\t\"box-sizing:content-box;display:block;margin:0;border:0;padding:0\";\n\t\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\t\tdiv.style.width = \"1px\";\n\t\t\t\tdocElem.appendChild( container );\n\n\t\t\t\tret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );\n\n\t\t\t\tdocElem.removeChild( container );\n\t\t\t\tdiv.removeChild( marginDiv );\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t});\n\t}\n})();\n\n\n// A method for quickly swapping in/out CSS properties to get correct calculations.\njQuery.swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar\n\t// Swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trnumsplit = new RegExp( \"^(\" + pnum + \")(.*)$\", \"i\" ),\n\trrelNum = new RegExp( \"^([+-])=(\" + pnum + \")\", \"i\" ),\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in style ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[0].toUpperCase() + name.slice(1),\n\t\torigName = name,\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\treturn origName;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\tvar matches = rnumsplit.exec( value );\n\treturn matches ?\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\t\t// Both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\t\t\t// At this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test(val) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// Check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// Use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = data_priv.get( elem, \"olddisplay\" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\telem.style.display = \"\";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = data_priv.access( elem, \"olddisplay\", defaultDisplay(elem.nodeName) );\n\t\t\t}\n\t\t} else {\n\t\t\thidden = isHidden( elem );\n\n\t\t\tif ( display !== \"none\" || !hidden ) {\n\t\t\t\tdata_priv.set( elem, \"olddisplay\", hidden ? display : jQuery.css( elem, \"display\" ) );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.extend({\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number, add 'px' to the (except for certain CSS properties)\n\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\tvalue += \"px\";\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n});\n\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) && elem.offsetWidth === 0 ?\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t}) :\n\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar styles = extra && getStyles( elem );\n\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t) : 0\n\t\t\t);\n\t\t}\n\t};\n});\n\n// Support: Android 2.3\njQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each({\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n});\n\njQuery.fn.extend({\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t});\n\t}\n});\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || \"swing\";\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE9\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t}\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" ),\n\trrun = /queueHooks$/,\n\tanimationPrefilters = [ defaultPrefilter ],\n\ttweeners = {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value ),\n\t\t\t\ttarget = tween.cur(),\n\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\tunit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\t\tstart = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n\t\t\t\t\trfxnum.exec( jQuery.css( tween.elem, prop ) ),\n\t\t\t\tscale = 1,\n\t\t\t\tmaxIterations = 20;\n\n\t\t\tif ( start && start[ 3 ] !== unit ) {\n\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\tunit = unit || start[ 3 ];\n\n\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\tparts = parts || [];\n\n\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\tstart = +target || 1;\n\n\t\t\t\tdo {\n\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t// Adjust and apply\n\t\t\t\t\tstart = start / scale;\n\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur(),\n\t\t\t\t// break the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t}\n\n\t\t\t// Update tween properties\n\t\t\tif ( parts ) {\n\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\ttween.unit = unit;\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\ttween.end = parts[ 1 ] ?\n\t\t\t\t\tstart + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n\t\t\t\t\t+parts[ 2 ];\n\t\t\t}\n\n\t\t\treturn tween;\n\t\t} ]\n\t};\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\tsetTimeout(function() {\n\t\tfxNow = undefined;\n\t});\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/* jshint validthis: true */\n\tvar prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHidden( elem ),\n\t\tdataShow = data_priv.get( elem, \"fxshow\" );\n\n\t// Handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always(function() {\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always(function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// Height/width overflow pass\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE9-10 do not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\n\t\t// Test default display if display is currently \"none\"\n\t\tcheckDisplay = display === \"none\" ?\n\t\t\tdata_priv.get( elem, \"olddisplay\" ) || defaultDisplay( elem.nodeName ) : display;\n\n\t\tif ( checkDisplay === \"inline\" && jQuery.css( elem, \"float\" ) === \"none\" ) {\n\t\t\tstyle.display = \"inline-block\";\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always(function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t});\n\t}\n\n\t// show/hide pass\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\n\t\t// Any non-fx value stops us from restoring the original display value\n\t\t} else {\n\t\t\tdisplay = undefined;\n\t\t}\n\t}\n\n\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\tif ( dataShow ) {\n\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\thidden = dataShow.hidden;\n\t\t\t}\n\t\t} else {\n\t\t\tdataShow = data_priv.access( elem, \"fxshow\", {} );\n\t\t}\n\n\t\t// Store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done(function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t});\n\t\t}\n\t\tanim.done(function() {\n\t\t\tvar prop;\n\n\t\t\tdata_priv.remove( elem, \"fxshow\" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t});\n\t\tfor ( prop in orig ) {\n\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t// If this is a noop like .hide().hide(), restore an overwritten display value\n\t} else if ( (display === \"none\" ? defaultDisplay( elem.nodeName ) : display) === \"inline\" ) {\n\t\tstyle.display = display;\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = animationPrefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t})\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.split(\" \");\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\ttweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tanimationPrefilters.unshift( callback );\n\t\t} else {\n\t\t\tanimationPrefilters.push( callback );\n\t\t}\n\t}\n});\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend({\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || data_priv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = data_priv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tvar index,\n\t\t\t\tdata = data_priv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t});\n\t}\n});\n\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n});\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx(\"show\"),\n\tslideUp: genFx(\"hide\"),\n\tslideToggle: genFx(\"toggle\"),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n});\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tclearInterval( timerId );\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\tclearTimeout( timeout );\n\t\t};\n\t});\n};\n\n\n(function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: iOS<=5.1, Android<=4.2+\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE<=11+\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: Android<=2.3\n\t// Options inside disabled selects are incorrectly marked as disabled\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Support: IE<=11+\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n})();\n\n\nvar nodeHook, boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend({\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tattr: function( elem, name, value ) {\n\t\tvar hooks, ret,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === strundefined ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\n\t\t\t} else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t} else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\treturn ret;\n\n\t\t} else {\n\t\t\tret = jQuery.find.attr( elem, name );\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ?\n\t\t\t\tundefined :\n\t\t\t\tret;\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle;\n\t\tif ( !isXML ) {\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ name ];\n\t\t\tattrHandle[ name ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tname.toLowerCase() :\n\t\t\t\tnull;\n\t\t\tattrHandle[ name ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n});\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i;\n\njQuery.fn.extend({\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t},\n\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks, notxml,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\tif ( notxml ) {\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n\t\t\t\tret :\n\t\t\t\t( elem[ name ] = value );\n\n\t\t} else {\n\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n\t\t\t\tret :\n\t\t\t\telem[ name ];\n\t\t}\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\t\t\t\treturn elem.hasAttribute( \"tabindex\" ) || rfocusable.test( elem.nodeName ) || elem.href ?\n\t\t\t\t\telem.tabIndex :\n\t\t\t\t\t-1;\n\t\t\t}\n\t\t}\n\t}\n});\n\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\njQuery.each([\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n});\n\n\n\n\nvar rclass = /[\\t\\r\\n\\f]/g;\n\njQuery.fn.extend({\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\tproceed = typeof value === \"string\" && value,\n\t\t\ti = 0,\n\t\t\tlen = this.length;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\n\t\tif ( proceed ) {\n\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\" \"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value,\n\t\t\ti = 0,\n\t\t\tlen = this.length;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\t\tif ( proceed ) {\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\"\"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = value ? jQuery.trim( cur ) : \"\";\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( type === \"string\" ) {\n\t\t\t\t// Toggle individual class names\n\t\t\t\tvar className,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\tclassNames = value.match( rnotwhite ) || [];\n\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( type === strundefined || type === \"boolean\" ) {\n\t\t\t\tif ( this.className ) {\n\t\t\t\t\t// store className if set\n\t\t\t\t\tdata_priv.set( this, \"__className__\", this.className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tthis.className = this.className || value === false ? \"\" : data_priv.get( this, \"__className__\" ) || \"\";\n\t\t\t}\n\t\t});\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className = \" \" + selector + \" \",\n\t\t\ti = 0,\n\t\t\tl = this.length;\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n});\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend({\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[0];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t// Handle most common string cases\n\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each(function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\t\t\t\t\t// Support: IE10-11+\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\tjQuery.trim( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// IE6-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( support.optDisabled ? !option.disabled : option.getAttribute( \"disabled\" ) === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\tif ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Radios and checkboxes getter/setter\njQuery.each([ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t};\n\t}\n});\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n});\n\njQuery.fn.extend({\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t},\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t}\n});\n\n\nvar nonce = jQuery.now();\n\nvar rquery = (/\\?/);\n\n\n\n// Support: Android 2.3\n// Workaround failure to string-cast null input\njQuery.parseJSON = function( data ) {\n\treturn JSON.parse( data + \"\" );\n};\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml, tmp;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE9\n\ttry {\n\t\ttmp = new DOMParser();\n\t\txml = tmp.parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Document location\n\tajaxLocation = window.location.href,\n\n\t// Segment location into parts\n\tajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[0] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t});\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend({\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\t\t\t// Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" )\n\t\t\t.replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( rnotwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t});\n\t};\n});\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax({\n\t\turl: url,\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t});\n};\n\n\njQuery.fn.extend({\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[ 0 ] ) {\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map(function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each(function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t});\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each(function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t}\n});\n\n\njQuery.expr.filters.hidden = function( elem ) {\n\t// Support: Opera <= 12.12\n\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\n};\njQuery.expr.filters.visible = function( elem ) {\n\treturn !jQuery.expr.filters.hidden( elem );\n};\n\n\n\n\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t}\n\t\t});\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t});\n\n\t} else {\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\n};\n\njQuery.fn.extend({\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function() {\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t})\n\t\t.filter(function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t})\n\t\t.map(function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t}) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t}).get();\n\t}\n});\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new XMLHttpRequest();\n\t} catch( e ) {}\n};\n\nvar xhrId = 0,\n\txhrCallbacks = {},\n\txhrSuccessStatus = {\n\t\t// file protocol always yields status code 0, assume 200\n\t\t0: 200,\n\t\t// Support: IE9\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\n// Support: IE9\n// Open requests must be manually aborted on unload (#5280)\n// See https://support.microsoft.com/kb/2856746 for more info\nif ( window.attachEvent ) {\n\twindow.attachEvent( \"onunload\", function() {\n\t\tfor ( var key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]();\n\t\t}\n\t});\n}\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport(function( options ) {\n\tvar callback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr(),\n\t\t\t\t\tid = ++xhrId;\n\n\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\n\t\t\t\t\t\t\tcallback = xhr.onload = xhr.onerror = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t// file: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\t\t\t\t\t\t\t\t\t// Support: IE9\n\t\t\t\t\t\t\t\t\t// Accessing binary-data responseText throws an exception\n\t\t\t\t\t\t\t\t\t// (#11426)\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText === \"string\" ? {\n\t\t\t\t\t\t\t\t\t\ttext: xhr.responseText\n\t\t\t\t\t\t\t\t\t} : undefined,\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\txhr.onerror = callback(\"error\");\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = xhrCallbacks[ id ] = callback(\"abort\");\n\n\t\t\t\ttry {\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\n// Install script dataType\njQuery.ajaxSetup({\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /(?:java|ecma)script/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n});\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery(\"<script>\").prop({\n\t\t\t\t\tasync: true,\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t}).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[\"script json\"] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always(function() {\n\t\t\t// Restore preexisting value\n\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t});\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n});\n\n\n\n\n// data: string of html\n// context (optional): If specified, the fragment will be created in this context, defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\tcontext = context || document;\n\n\tvar parsed = rsingleTag.exec( data ),\n\t\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[1] ) ];\n\t}\n\n\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n// Keep a copy of the old load method\nvar _load = jQuery.fn.load;\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== \"string\" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf(\" \");\n\n\tif ( off >= 0 ) {\n\t\tselector = jQuery.trim( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\n\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t}).done(function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t});\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n});\n\n\n\n\njQuery.expr.filters.animated = function( elem ) {\n\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t}).length;\n};\n\n\n\n\nvar docElem = window.document.documentElement;\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf(\"auto\") > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\toptions = options.call( elem, i, curOffset );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend({\n\toffset: function( options ) {\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each(function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t});\n\t\t}\n\n\t\tvar docElem, win,\n\t\t\telem = this[ 0 ],\n\t\t\tbox = { top: 0, left: 0 },\n\t\t\tdoc = elem && elem.ownerDocument;\n\n\t\tif ( !doc ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdocElem = doc.documentElement;\n\n\t\t// Make sure it's not a disconnected DOM node\n\t\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\t\treturn box;\n\t\t}\n\n\t\t// Support: BlackBerry 5, iOS 3 (original iPhone)\n\t\t// If we don't have gBCR, just use 0,0 rather than error\n\t\tif ( typeof elem.getBoundingClientRect !== strundefined ) {\n\t\t\tbox = elem.getBoundingClientRect();\n\t\t}\n\t\twin = getWindow( doc );\n\t\treturn {\n\t\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\n\t\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\n\t\t};\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map(function() {\n\t\t\tvar offsetParent = this.offsetParent || docElem;\n\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\" ) === \"static\" ) ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || docElem;\n\t\t});\n\t}\n});\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : window.pageXOffset,\n\t\t\t\t\ttop ? val : window.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length, null );\n\t};\n});\n\n// Support: Safari<7+, Chrome<37+\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n});\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t});\n});\n\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n\treturn this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( \"jquery\", [], function() {\n\t\treturn jQuery;\n\t});\n}\n\n\n\n\nvar\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === strundefined ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n\n}));\n","/*!\n * Bootstrap v3.3.6 (http://getbootstrap.com)\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under the MIT license\n */\n\nif (typeof jQuery === 'undefined') {\n  throw new Error('Bootstrap\\'s JavaScript requires jQuery')\n}\n\n+function ($) {\n  'use strict';\n  var version = $.fn.jquery.split(' ')[0].split('.')\n  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 2)) {\n    throw new Error('Bootstrap\\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3')\n  }\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: transition.js v3.3.6\n * http://getbootstrap.com/javascript/#transitions\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)\n  // ============================================================\n\n  function transitionEnd() {\n    var el = document.createElement('bootstrap')\n\n    var transEndEventNames = {\n      WebkitTransition : 'webkitTransitionEnd',\n      MozTransition    : 'transitionend',\n      OTransition      : 'oTransitionEnd otransitionend',\n      transition       : 'transitionend'\n    }\n\n    for (var name in transEndEventNames) {\n      if (el.style[name] !== undefined) {\n        return { end: transEndEventNames[name] }\n      }\n    }\n\n    return false // explicit for ie8 (  ._.)\n  }\n\n  // http://blog.alexmaccaw.com/css-transitions\n  $.fn.emulateTransitionEnd = function (duration) {\n    var called = false\n    var $el = this\n    $(this).one('bsTransitionEnd', function () { called = true })\n    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }\n    setTimeout(callback, duration)\n    return this\n  }\n\n  $(function () {\n    $.support.transition = transitionEnd()\n\n    if (!$.support.transition) return\n\n    $.event.special.bsTransitionEnd = {\n      bindType: $.support.transition.end,\n      delegateType: $.support.transition.end,\n      handle: function (e) {\n        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)\n      }\n    }\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: alert.js v3.3.6\n * http://getbootstrap.com/javascript/#alerts\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // ALERT CLASS DEFINITION\n  // ======================\n\n  var dismiss = '[data-dismiss=\"alert\"]'\n  var Alert   = function (el) {\n    $(el).on('click', dismiss, this.close)\n  }\n\n  Alert.VERSION = '3.3.6'\n\n  Alert.TRANSITION_DURATION = 150\n\n  Alert.prototype.close = function (e) {\n    var $this    = $(this)\n    var selector = $this.attr('data-target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    var $parent = $(selector)\n\n    if (e) e.preventDefault()\n\n    if (!$parent.length) {\n      $parent = $this.closest('.alert')\n    }\n\n    $parent.trigger(e = $.Event('close.bs.alert'))\n\n    if (e.isDefaultPrevented()) return\n\n    $parent.removeClass('in')\n\n    function removeElement() {\n      // detach from parent, fire event then clean up data\n      $parent.detach().trigger('closed.bs.alert').remove()\n    }\n\n    $.support.transition && $parent.hasClass('fade') ?\n      $parent\n        .one('bsTransitionEnd', removeElement)\n        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :\n      removeElement()\n  }\n\n\n  // ALERT PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.alert')\n\n      if (!data) $this.data('bs.alert', (data = new Alert(this)))\n      if (typeof option == 'string') data[option].call($this)\n    })\n  }\n\n  var old = $.fn.alert\n\n  $.fn.alert             = Plugin\n  $.fn.alert.Constructor = Alert\n\n\n  // ALERT NO CONFLICT\n  // =================\n\n  $.fn.alert.noConflict = function () {\n    $.fn.alert = old\n    return this\n  }\n\n\n  // ALERT DATA-API\n  // ==============\n\n  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: button.js v3.3.6\n * http://getbootstrap.com/javascript/#buttons\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // BUTTON PUBLIC CLASS DEFINITION\n  // ==============================\n\n  var Button = function (element, options) {\n    this.$element  = $(element)\n    this.options   = $.extend({}, Button.DEFAULTS, options)\n    this.isLoading = false\n  }\n\n  Button.VERSION  = '3.3.6'\n\n  Button.DEFAULTS = {\n    loadingText: 'loading...'\n  }\n\n  Button.prototype.setState = function (state) {\n    var d    = 'disabled'\n    var $el  = this.$element\n    var val  = $el.is('input') ? 'val' : 'html'\n    var data = $el.data()\n\n    state += 'Text'\n\n    if (data.resetText == null) $el.data('resetText', $el[val]())\n\n    // push to event loop to allow forms to submit\n    setTimeout($.proxy(function () {\n      $el[val](data[state] == null ? this.options[state] : data[state])\n\n      if (state == 'loadingText') {\n        this.isLoading = true\n        $el.addClass(d).attr(d, d)\n      } else if (this.isLoading) {\n        this.isLoading = false\n        $el.removeClass(d).removeAttr(d)\n      }\n    }, this), 0)\n  }\n\n  Button.prototype.toggle = function () {\n    var changed = true\n    var $parent = this.$element.closest('[data-toggle=\"buttons\"]')\n\n    if ($parent.length) {\n      var $input = this.$element.find('input')\n      if ($input.prop('type') == 'radio') {\n        if ($input.prop('checked')) changed = false\n        $parent.find('.active').removeClass('active')\n        this.$element.addClass('active')\n      } else if ($input.prop('type') == 'checkbox') {\n        if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false\n        this.$element.toggleClass('active')\n      }\n      $input.prop('checked', this.$element.hasClass('active'))\n      if (changed) $input.trigger('change')\n    } else {\n      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))\n      this.$element.toggleClass('active')\n    }\n  }\n\n\n  // BUTTON PLUGIN DEFINITION\n  // ========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.button')\n      var options = typeof option == 'object' && option\n\n      if (!data) $this.data('bs.button', (data = new Button(this, options)))\n\n      if (option == 'toggle') data.toggle()\n      else if (option) data.setState(option)\n    })\n  }\n\n  var old = $.fn.button\n\n  $.fn.button             = Plugin\n  $.fn.button.Constructor = Button\n\n\n  // BUTTON NO CONFLICT\n  // ==================\n\n  $.fn.button.noConflict = function () {\n    $.fn.button = old\n    return this\n  }\n\n\n  // BUTTON DATA-API\n  // ===============\n\n  $(document)\n    .on('click.bs.button.data-api', '[data-toggle^=\"button\"]', function (e) {\n      var $btn = $(e.target)\n      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')\n      Plugin.call($btn, 'toggle')\n      if (!($(e.target).is('input[type=\"radio\"]') || $(e.target).is('input[type=\"checkbox\"]'))) e.preventDefault()\n    })\n    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^=\"button\"]', function (e) {\n      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))\n    })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: carousel.js v3.3.6\n * http://getbootstrap.com/javascript/#carousel\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // CAROUSEL CLASS DEFINITION\n  // =========================\n\n  var Carousel = function (element, options) {\n    this.$element    = $(element)\n    this.$indicators = this.$element.find('.carousel-indicators')\n    this.options     = options\n    this.paused      = null\n    this.sliding     = null\n    this.interval    = null\n    this.$active     = null\n    this.$items      = null\n\n    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))\n\n    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element\n      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))\n      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))\n  }\n\n  Carousel.VERSION  = '3.3.6'\n\n  Carousel.TRANSITION_DURATION = 600\n\n  Carousel.DEFAULTS = {\n    interval: 5000,\n    pause: 'hover',\n    wrap: true,\n    keyboard: true\n  }\n\n  Carousel.prototype.keydown = function (e) {\n    if (/input|textarea/i.test(e.target.tagName)) return\n    switch (e.which) {\n      case 37: this.prev(); break\n      case 39: this.next(); break\n      default: return\n    }\n\n    e.preventDefault()\n  }\n\n  Carousel.prototype.cycle = function (e) {\n    e || (this.paused = false)\n\n    this.interval && clearInterval(this.interval)\n\n    this.options.interval\n      && !this.paused\n      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))\n\n    return this\n  }\n\n  Carousel.prototype.getItemIndex = function (item) {\n    this.$items = item.parent().children('.item')\n    return this.$items.index(item || this.$active)\n  }\n\n  Carousel.prototype.getItemForDirection = function (direction, active) {\n    var activeIndex = this.getItemIndex(active)\n    var willWrap = (direction == 'prev' && activeIndex === 0)\n                || (direction == 'next' && activeIndex == (this.$items.length - 1))\n    if (willWrap && !this.options.wrap) return active\n    var delta = direction == 'prev' ? -1 : 1\n    var itemIndex = (activeIndex + delta) % this.$items.length\n    return this.$items.eq(itemIndex)\n  }\n\n  Carousel.prototype.to = function (pos) {\n    var that        = this\n    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))\n\n    if (pos > (this.$items.length - 1) || pos < 0) return\n\n    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, \"slid\"\n    if (activeIndex == pos) return this.pause().cycle()\n\n    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))\n  }\n\n  Carousel.prototype.pause = function (e) {\n    e || (this.paused = true)\n\n    if (this.$element.find('.next, .prev').length && $.support.transition) {\n      this.$element.trigger($.support.transition.end)\n      this.cycle(true)\n    }\n\n    this.interval = clearInterval(this.interval)\n\n    return this\n  }\n\n  Carousel.prototype.next = function () {\n    if (this.sliding) return\n    return this.slide('next')\n  }\n\n  Carousel.prototype.prev = function () {\n    if (this.sliding) return\n    return this.slide('prev')\n  }\n\n  Carousel.prototype.slide = function (type, next) {\n    var $active   = this.$element.find('.item.active')\n    var $next     = next || this.getItemForDirection(type, $active)\n    var isCycling = this.interval\n    var direction = type == 'next' ? 'left' : 'right'\n    var that      = this\n\n    if ($next.hasClass('active')) return (this.sliding = false)\n\n    var relatedTarget = $next[0]\n    var slideEvent = $.Event('slide.bs.carousel', {\n      relatedTarget: relatedTarget,\n      direction: direction\n    })\n    this.$element.trigger(slideEvent)\n    if (slideEvent.isDefaultPrevented()) return\n\n    this.sliding = true\n\n    isCycling && this.pause()\n\n    if (this.$indicators.length) {\n      this.$indicators.find('.active').removeClass('active')\n      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])\n      $nextIndicator && $nextIndicator.addClass('active')\n    }\n\n    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, \"slid\"\n    if ($.support.transition && this.$element.hasClass('slide')) {\n      $next.addClass(type)\n      $next[0].offsetWidth // force reflow\n      $active.addClass(direction)\n      $next.addClass(direction)\n      $active\n        .one('bsTransitionEnd', function () {\n          $next.removeClass([type, direction].join(' ')).addClass('active')\n          $active.removeClass(['active', direction].join(' '))\n          that.sliding = false\n          setTimeout(function () {\n            that.$element.trigger(slidEvent)\n          }, 0)\n        })\n        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)\n    } else {\n      $active.removeClass('active')\n      $next.addClass('active')\n      this.sliding = false\n      this.$element.trigger(slidEvent)\n    }\n\n    isCycling && this.cycle()\n\n    return this\n  }\n\n\n  // CAROUSEL PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.carousel')\n      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)\n      var action  = typeof option == 'string' ? option : options.slide\n\n      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))\n      if (typeof option == 'number') data.to(option)\n      else if (action) data[action]()\n      else if (options.interval) data.pause().cycle()\n    })\n  }\n\n  var old = $.fn.carousel\n\n  $.fn.carousel             = Plugin\n  $.fn.carousel.Constructor = Carousel\n\n\n  // CAROUSEL NO CONFLICT\n  // ====================\n\n  $.fn.carousel.noConflict = function () {\n    $.fn.carousel = old\n    return this\n  }\n\n\n  // CAROUSEL DATA-API\n  // =================\n\n  var clickHandler = function (e) {\n    var href\n    var $this   = $(this)\n    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, '')) // strip for ie7\n    if (!$target.hasClass('carousel')) return\n    var options = $.extend({}, $target.data(), $this.data())\n    var slideIndex = $this.attr('data-slide-to')\n    if (slideIndex) options.interval = false\n\n    Plugin.call($target, options)\n\n    if (slideIndex) {\n      $target.data('bs.carousel').to(slideIndex)\n    }\n\n    e.preventDefault()\n  }\n\n  $(document)\n    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)\n    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)\n\n  $(window).on('load', function () {\n    $('[data-ride=\"carousel\"]').each(function () {\n      var $carousel = $(this)\n      Plugin.call($carousel, $carousel.data())\n    })\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: collapse.js v3.3.6\n * http://getbootstrap.com/javascript/#collapse\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // COLLAPSE PUBLIC CLASS DEFINITION\n  // ================================\n\n  var Collapse = function (element, options) {\n    this.$element      = $(element)\n    this.options       = $.extend({}, Collapse.DEFAULTS, options)\n    this.$trigger      = $('[data-toggle=\"collapse\"][href=\"#' + element.id + '\"],' +\n                           '[data-toggle=\"collapse\"][data-target=\"#' + element.id + '\"]')\n    this.transitioning = null\n\n    if (this.options.parent) {\n      this.$parent = this.getParent()\n    } else {\n      this.addAriaAndCollapsedClass(this.$element, this.$trigger)\n    }\n\n    if (this.options.toggle) this.toggle()\n  }\n\n  Collapse.VERSION  = '3.3.6'\n\n  Collapse.TRANSITION_DURATION = 350\n\n  Collapse.DEFAULTS = {\n    toggle: true\n  }\n\n  Collapse.prototype.dimension = function () {\n    var hasWidth = this.$element.hasClass('width')\n    return hasWidth ? 'width' : 'height'\n  }\n\n  Collapse.prototype.show = function () {\n    if (this.transitioning || this.$element.hasClass('in')) return\n\n    var activesData\n    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')\n\n    if (actives && actives.length) {\n      activesData = actives.data('bs.collapse')\n      if (activesData && activesData.transitioning) return\n    }\n\n    var startEvent = $.Event('show.bs.collapse')\n    this.$element.trigger(startEvent)\n    if (startEvent.isDefaultPrevented()) return\n\n    if (actives && actives.length) {\n      Plugin.call(actives, 'hide')\n      activesData || actives.data('bs.collapse', null)\n    }\n\n    var dimension = this.dimension()\n\n    this.$element\n      .removeClass('collapse')\n      .addClass('collapsing')[dimension](0)\n      .attr('aria-expanded', true)\n\n    this.$trigger\n      .removeClass('collapsed')\n      .attr('aria-expanded', true)\n\n    this.transitioning = 1\n\n    var complete = function () {\n      this.$element\n        .removeClass('collapsing')\n        .addClass('collapse in')[dimension]('')\n      this.transitioning = 0\n      this.$element\n        .trigger('shown.bs.collapse')\n    }\n\n    if (!$.support.transition) return complete.call(this)\n\n    var scrollSize = $.camelCase(['scroll', dimension].join('-'))\n\n    this.$element\n      .one('bsTransitionEnd', $.proxy(complete, this))\n      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])\n  }\n\n  Collapse.prototype.hide = function () {\n    if (this.transitioning || !this.$element.hasClass('in')) return\n\n    var startEvent = $.Event('hide.bs.collapse')\n    this.$element.trigger(startEvent)\n    if (startEvent.isDefaultPrevented()) return\n\n    var dimension = this.dimension()\n\n    this.$element[dimension](this.$element[dimension]())[0].offsetHeight\n\n    this.$element\n      .addClass('collapsing')\n      .removeClass('collapse in')\n      .attr('aria-expanded', false)\n\n    this.$trigger\n      .addClass('collapsed')\n      .attr('aria-expanded', false)\n\n    this.transitioning = 1\n\n    var complete = function () {\n      this.transitioning = 0\n      this.$element\n        .removeClass('collapsing')\n        .addClass('collapse')\n        .trigger('hidden.bs.collapse')\n    }\n\n    if (!$.support.transition) return complete.call(this)\n\n    this.$element\n      [dimension](0)\n      .one('bsTransitionEnd', $.proxy(complete, this))\n      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)\n  }\n\n  Collapse.prototype.toggle = function () {\n    this[this.$element.hasClass('in') ? 'hide' : 'show']()\n  }\n\n  Collapse.prototype.getParent = function () {\n    return $(this.options.parent)\n      .find('[data-toggle=\"collapse\"][data-parent=\"' + this.options.parent + '\"]')\n      .each($.proxy(function (i, element) {\n        var $element = $(element)\n        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)\n      }, this))\n      .end()\n  }\n\n  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {\n    var isOpen = $element.hasClass('in')\n\n    $element.attr('aria-expanded', isOpen)\n    $trigger\n      .toggleClass('collapsed', !isOpen)\n      .attr('aria-expanded', isOpen)\n  }\n\n  function getTargetFromTrigger($trigger) {\n    var href\n    var target = $trigger.attr('data-target')\n      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, '') // strip for ie7\n\n    return $(target)\n  }\n\n\n  // COLLAPSE PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.collapse')\n      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)\n\n      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false\n      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.collapse\n\n  $.fn.collapse             = Plugin\n  $.fn.collapse.Constructor = Collapse\n\n\n  // COLLAPSE NO CONFLICT\n  // ====================\n\n  $.fn.collapse.noConflict = function () {\n    $.fn.collapse = old\n    return this\n  }\n\n\n  // COLLAPSE DATA-API\n  // =================\n\n  $(document).on('click.bs.collapse.data-api', '[data-toggle=\"collapse\"]', function (e) {\n    var $this   = $(this)\n\n    if (!$this.attr('data-target')) e.preventDefault()\n\n    var $target = getTargetFromTrigger($this)\n    var data    = $target.data('bs.collapse')\n    var option  = data ? 'toggle' : $this.data()\n\n    Plugin.call($target, option)\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: dropdown.js v3.3.6\n * http://getbootstrap.com/javascript/#dropdowns\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // DROPDOWN CLASS DEFINITION\n  // =========================\n\n  var backdrop = '.dropdown-backdrop'\n  var toggle   = '[data-toggle=\"dropdown\"]'\n  var Dropdown = function (element) {\n    $(element).on('click.bs.dropdown', this.toggle)\n  }\n\n  Dropdown.VERSION = '3.3.6'\n\n  function getParent($this) {\n    var selector = $this.attr('data-target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    var $parent = selector && $(selector)\n\n    return $parent && $parent.length ? $parent : $this.parent()\n  }\n\n  function clearMenus(e) {\n    if (e && e.which === 3) return\n    $(backdrop).remove()\n    $(toggle).each(function () {\n      var $this         = $(this)\n      var $parent       = getParent($this)\n      var relatedTarget = { relatedTarget: this }\n\n      if (!$parent.hasClass('open')) return\n\n      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return\n\n      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this.attr('aria-expanded', 'false')\n      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))\n    })\n  }\n\n  Dropdown.prototype.toggle = function (e) {\n    var $this = $(this)\n\n    if ($this.is('.disabled, :disabled')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass('open')\n\n    clearMenus()\n\n    if (!isActive) {\n      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {\n        // if mobile we use a backdrop because click events don't delegate\n        $(document.createElement('div'))\n          .addClass('dropdown-backdrop')\n          .insertAfter($(this))\n          .on('click', clearMenus)\n      }\n\n      var relatedTarget = { relatedTarget: this }\n      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this\n        .trigger('focus')\n        .attr('aria-expanded', 'true')\n\n      $parent\n        .toggleClass('open')\n        .trigger($.Event('shown.bs.dropdown', relatedTarget))\n    }\n\n    return false\n  }\n\n  Dropdown.prototype.keydown = function (e) {\n    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return\n\n    var $this = $(this)\n\n    e.preventDefault()\n    e.stopPropagation()\n\n    if ($this.is('.disabled, :disabled')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass('open')\n\n    if (!isActive && e.which != 27 || isActive && e.which == 27) {\n      if (e.which == 27) $parent.find(toggle).trigger('focus')\n      return $this.trigger('click')\n    }\n\n    var desc = ' li:not(.disabled):visible a'\n    var $items = $parent.find('.dropdown-menu' + desc)\n\n    if (!$items.length) return\n\n    var index = $items.index(e.target)\n\n    if (e.which == 38 && index > 0)                 index--         // up\n    if (e.which == 40 && index < $items.length - 1) index++         // down\n    if (!~index)                                    index = 0\n\n    $items.eq(index).trigger('focus')\n  }\n\n\n  // DROPDOWN PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.dropdown')\n\n      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))\n      if (typeof option == 'string') data[option].call($this)\n    })\n  }\n\n  var old = $.fn.dropdown\n\n  $.fn.dropdown             = Plugin\n  $.fn.dropdown.Constructor = Dropdown\n\n\n  // DROPDOWN NO CONFLICT\n  // ====================\n\n  $.fn.dropdown.noConflict = function () {\n    $.fn.dropdown = old\n    return this\n  }\n\n\n  // APPLY TO STANDARD DROPDOWN ELEMENTS\n  // ===================================\n\n  $(document)\n    .on('click.bs.dropdown.data-api', clearMenus)\n    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })\n    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)\n    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)\n    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: modal.js v3.3.6\n * http://getbootstrap.com/javascript/#modals\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // MODAL CLASS DEFINITION\n  // ======================\n\n  var Modal = function (element, options) {\n    this.options             = options\n    this.$body               = $(document.body)\n    this.$element            = $(element)\n    this.$dialog             = this.$element.find('.modal-dialog')\n    this.$backdrop           = null\n    this.isShown             = null\n    this.originalBodyPad     = null\n    this.scrollbarWidth      = 0\n    this.ignoreBackdropClick = false\n\n    if (this.options.remote) {\n      this.$element\n        .find('.modal-content')\n        .load(this.options.remote, $.proxy(function () {\n          this.$element.trigger('loaded.bs.modal')\n        }, this))\n    }\n  }\n\n  Modal.VERSION  = '3.3.6'\n\n  Modal.TRANSITION_DURATION = 300\n  Modal.BACKDROP_TRANSITION_DURATION = 150\n\n  Modal.DEFAULTS = {\n    backdrop: true,\n    keyboard: true,\n    show: true\n  }\n\n  Modal.prototype.toggle = function (_relatedTarget) {\n    return this.isShown ? this.hide() : this.show(_relatedTarget)\n  }\n\n  Modal.prototype.show = function (_relatedTarget) {\n    var that = this\n    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })\n\n    this.$element.trigger(e)\n\n    if (this.isShown || e.isDefaultPrevented()) return\n\n    this.isShown = true\n\n    this.checkScrollbar()\n    this.setScrollbar()\n    this.$body.addClass('modal-open')\n\n    this.escape()\n    this.resize()\n\n    this.$element.on('click.dismiss.bs.modal', '[data-dismiss=\"modal\"]', $.proxy(this.hide, this))\n\n    this.$dialog.on('mousedown.dismiss.bs.modal', function () {\n      that.$element.one('mouseup.dismiss.bs.modal', function (e) {\n        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true\n      })\n    })\n\n    this.backdrop(function () {\n      var transition = $.support.transition && that.$element.hasClass('fade')\n\n      if (!that.$element.parent().length) {\n        that.$element.appendTo(that.$body) // don't move modals dom position\n      }\n\n      that.$element\n        .show()\n        .scrollTop(0)\n\n      that.adjustDialog()\n\n      if (transition) {\n        that.$element[0].offsetWidth // force reflow\n      }\n\n      that.$element.addClass('in')\n\n      that.enforceFocus()\n\n      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })\n\n      transition ?\n        that.$dialog // wait for modal to slide in\n          .one('bsTransitionEnd', function () {\n            that.$element.trigger('focus').trigger(e)\n          })\n          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\n        that.$element.trigger('focus').trigger(e)\n    })\n  }\n\n  Modal.prototype.hide = function (e) {\n    if (e) e.preventDefault()\n\n    e = $.Event('hide.bs.modal')\n\n    this.$element.trigger(e)\n\n    if (!this.isShown || e.isDefaultPrevented()) return\n\n    this.isShown = false\n\n    this.escape()\n    this.resize()\n\n    $(document).off('focusin.bs.modal')\n\n    this.$element\n      .removeClass('in')\n      .off('click.dismiss.bs.modal')\n      .off('mouseup.dismiss.bs.modal')\n\n    this.$dialog.off('mousedown.dismiss.bs.modal')\n\n    $.support.transition && this.$element.hasClass('fade') ?\n      this.$element\n        .one('bsTransitionEnd', $.proxy(this.hideModal, this))\n        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\n      this.hideModal()\n  }\n\n  Modal.prototype.enforceFocus = function () {\n    $(document)\n      .off('focusin.bs.modal') // guard against infinite focus loop\n      .on('focusin.bs.modal', $.proxy(function (e) {\n        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {\n          this.$element.trigger('focus')\n        }\n      }, this))\n  }\n\n  Modal.prototype.escape = function () {\n    if (this.isShown && this.options.keyboard) {\n      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {\n        e.which == 27 && this.hide()\n      }, this))\n    } else if (!this.isShown) {\n      this.$element.off('keydown.dismiss.bs.modal')\n    }\n  }\n\n  Modal.prototype.resize = function () {\n    if (this.isShown) {\n      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))\n    } else {\n      $(window).off('resize.bs.modal')\n    }\n  }\n\n  Modal.prototype.hideModal = function () {\n    var that = this\n    this.$element.hide()\n    this.backdrop(function () {\n      that.$body.removeClass('modal-open')\n      that.resetAdjustments()\n      that.resetScrollbar()\n      that.$element.trigger('hidden.bs.modal')\n    })\n  }\n\n  Modal.prototype.removeBackdrop = function () {\n    this.$backdrop && this.$backdrop.remove()\n    this.$backdrop = null\n  }\n\n  Modal.prototype.backdrop = function (callback) {\n    var that = this\n    var animate = this.$element.hasClass('fade') ? 'fade' : ''\n\n    if (this.isShown && this.options.backdrop) {\n      var doAnimate = $.support.transition && animate\n\n      this.$backdrop = $(document.createElement('div'))\n        .addClass('modal-backdrop ' + animate)\n        .appendTo(this.$body)\n\n      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {\n        if (this.ignoreBackdropClick) {\n          this.ignoreBackdropClick = false\n          return\n        }\n        if (e.target !== e.currentTarget) return\n        this.options.backdrop == 'static'\n          ? this.$element[0].focus()\n          : this.hide()\n      }, this))\n\n      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow\n\n      this.$backdrop.addClass('in')\n\n      if (!callback) return\n\n      doAnimate ?\n        this.$backdrop\n          .one('bsTransitionEnd', callback)\n          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\n        callback()\n\n    } else if (!this.isShown && this.$backdrop) {\n      this.$backdrop.removeClass('in')\n\n      var callbackRemove = function () {\n        that.removeBackdrop()\n        callback && callback()\n      }\n      $.support.transition && this.$element.hasClass('fade') ?\n        this.$backdrop\n          .one('bsTransitionEnd', callbackRemove)\n          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\n        callbackRemove()\n\n    } else if (callback) {\n      callback()\n    }\n  }\n\n  // these following methods are used to handle overflowing modals\n\n  Modal.prototype.handleUpdate = function () {\n    this.adjustDialog()\n  }\n\n  Modal.prototype.adjustDialog = function () {\n    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight\n\n    this.$element.css({\n      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',\n      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''\n    })\n  }\n\n  Modal.prototype.resetAdjustments = function () {\n    this.$element.css({\n      paddingLeft: '',\n      paddingRight: ''\n    })\n  }\n\n  Modal.prototype.checkScrollbar = function () {\n    var fullWindowWidth = window.innerWidth\n    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8\n      var documentElementRect = document.documentElement.getBoundingClientRect()\n      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)\n    }\n    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth\n    this.scrollbarWidth = this.measureScrollbar()\n  }\n\n  Modal.prototype.setScrollbar = function () {\n    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)\n    this.originalBodyPad = document.body.style.paddingRight || ''\n    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)\n  }\n\n  Modal.prototype.resetScrollbar = function () {\n    this.$body.css('padding-right', this.originalBodyPad)\n  }\n\n  Modal.prototype.measureScrollbar = function () { // thx walsh\n    var scrollDiv = document.createElement('div')\n    scrollDiv.className = 'modal-scrollbar-measure'\n    this.$body.append(scrollDiv)\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth\n    this.$body[0].removeChild(scrollDiv)\n    return scrollbarWidth\n  }\n\n\n  // MODAL PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option, _relatedTarget) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.modal')\n      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)\n\n      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))\n      if (typeof option == 'string') data[option](_relatedTarget)\n      else if (options.show) data.show(_relatedTarget)\n    })\n  }\n\n  var old = $.fn.modal\n\n  $.fn.modal             = Plugin\n  $.fn.modal.Constructor = Modal\n\n\n  // MODAL NO CONFLICT\n  // =================\n\n  $.fn.modal.noConflict = function () {\n    $.fn.modal = old\n    return this\n  }\n\n\n  // MODAL DATA-API\n  // ==============\n\n  $(document).on('click.bs.modal.data-api', '[data-toggle=\"modal\"]', function (e) {\n    var $this   = $(this)\n    var href    = $this.attr('href')\n    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\\s]+$)/, ''))) // strip for ie7\n    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())\n\n    if ($this.is('a')) e.preventDefault()\n\n    $target.one('show.bs.modal', function (showEvent) {\n      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown\n      $target.one('hidden.bs.modal', function () {\n        $this.is(':visible') && $this.trigger('focus')\n      })\n    })\n    Plugin.call($target, option, this)\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: tooltip.js v3.3.6\n * http://getbootstrap.com/javascript/#tooltip\n * Inspired by the original jQuery.tipsy by Jason Frame\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // TOOLTIP PUBLIC CLASS DEFINITION\n  // ===============================\n\n  var Tooltip = function (element, options) {\n    this.type       = null\n    this.options    = null\n    this.enabled    = null\n    this.timeout    = null\n    this.hoverState = null\n    this.$element   = null\n    this.inState    = null\n\n    this.init('tooltip', element, options)\n  }\n\n  Tooltip.VERSION  = '3.3.6'\n\n  Tooltip.TRANSITION_DURATION = 150\n\n  Tooltip.DEFAULTS = {\n    animation: true,\n    placement: 'top',\n    selector: false,\n    template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n    trigger: 'hover focus',\n    title: '',\n    delay: 0,\n    html: false,\n    container: false,\n    viewport: {\n      selector: 'body',\n      padding: 0\n    }\n  }\n\n  Tooltip.prototype.init = function (type, element, options) {\n    this.enabled   = true\n    this.type      = type\n    this.$element  = $(element)\n    this.options   = this.getOptions(options)\n    this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))\n    this.inState   = { click: false, hover: false, focus: false }\n\n    if (this.$element[0] instanceof document.constructor && !this.options.selector) {\n      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')\n    }\n\n    var triggers = this.options.trigger.split(' ')\n\n    for (var i = triggers.length; i--;) {\n      var trigger = triggers[i]\n\n      if (trigger == 'click') {\n        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))\n      } else if (trigger != 'manual') {\n        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'\n        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'\n\n        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))\n        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))\n      }\n    }\n\n    this.options.selector ?\n      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :\n      this.fixTitle()\n  }\n\n  Tooltip.prototype.getDefaults = function () {\n    return Tooltip.DEFAULTS\n  }\n\n  Tooltip.prototype.getOptions = function (options) {\n    options = $.extend({}, this.getDefaults(), this.$element.data(), options)\n\n    if (options.delay && typeof options.delay == 'number') {\n      options.delay = {\n        show: options.delay,\n        hide: options.delay\n      }\n    }\n\n    return options\n  }\n\n  Tooltip.prototype.getDelegateOptions = function () {\n    var options  = {}\n    var defaults = this.getDefaults()\n\n    this._options && $.each(this._options, function (key, value) {\n      if (defaults[key] != value) options[key] = value\n    })\n\n    return options\n  }\n\n  Tooltip.prototype.enter = function (obj) {\n    var self = obj instanceof this.constructor ?\n      obj : $(obj.currentTarget).data('bs.' + this.type)\n\n    if (!self) {\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\n      $(obj.currentTarget).data('bs.' + this.type, self)\n    }\n\n    if (obj instanceof $.Event) {\n      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true\n    }\n\n    if (self.tip().hasClass('in') || self.hoverState == 'in') {\n      self.hoverState = 'in'\n      return\n    }\n\n    clearTimeout(self.timeout)\n\n    self.hoverState = 'in'\n\n    if (!self.options.delay || !self.options.delay.show) return self.show()\n\n    self.timeout = setTimeout(function () {\n      if (self.hoverState == 'in') self.show()\n    }, self.options.delay.show)\n  }\n\n  Tooltip.prototype.isInStateTrue = function () {\n    for (var key in this.inState) {\n      if (this.inState[key]) return true\n    }\n\n    return false\n  }\n\n  Tooltip.prototype.leave = function (obj) {\n    var self = obj instanceof this.constructor ?\n      obj : $(obj.currentTarget).data('bs.' + this.type)\n\n    if (!self) {\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\n      $(obj.currentTarget).data('bs.' + this.type, self)\n    }\n\n    if (obj instanceof $.Event) {\n      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false\n    }\n\n    if (self.isInStateTrue()) return\n\n    clearTimeout(self.timeout)\n\n    self.hoverState = 'out'\n\n    if (!self.options.delay || !self.options.delay.hide) return self.hide()\n\n    self.timeout = setTimeout(function () {\n      if (self.hoverState == 'out') self.hide()\n    }, self.options.delay.hide)\n  }\n\n  Tooltip.prototype.show = function () {\n    var e = $.Event('show.bs.' + this.type)\n\n    if (this.hasContent() && this.enabled) {\n      this.$element.trigger(e)\n\n      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])\n      if (e.isDefaultPrevented() || !inDom) return\n      var that = this\n\n      var $tip = this.tip()\n\n      var tipId = this.getUID(this.type)\n\n      this.setContent()\n      $tip.attr('id', tipId)\n      this.$element.attr('aria-describedby', tipId)\n\n      if (this.options.animation) $tip.addClass('fade')\n\n      var placement = typeof this.options.placement == 'function' ?\n        this.options.placement.call(this, $tip[0], this.$element[0]) :\n        this.options.placement\n\n      var autoToken = /\\s?auto?\\s?/i\n      var autoPlace = autoToken.test(placement)\n      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'\n\n      $tip\n        .detach()\n        .css({ top: 0, left: 0, display: 'block' })\n        .addClass(placement)\n        .data('bs.' + this.type, this)\n\n      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)\n      this.$element.trigger('inserted.bs.' + this.type)\n\n      var pos          = this.getPosition()\n      var actualWidth  = $tip[0].offsetWidth\n      var actualHeight = $tip[0].offsetHeight\n\n      if (autoPlace) {\n        var orgPlacement = placement\n        var viewportDim = this.getPosition(this.$viewport)\n\n        placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :\n                    placement == 'top'    && pos.top    - actualHeight < viewportDim.top    ? 'bottom' :\n                    placement == 'right'  && pos.right  + actualWidth  > viewportDim.width  ? 'left'   :\n                    placement == 'left'   && pos.left   - actualWidth  < viewportDim.left   ? 'right'  :\n                    placement\n\n        $tip\n          .removeClass(orgPlacement)\n          .addClass(placement)\n      }\n\n      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)\n\n      this.applyPlacement(calculatedOffset, placement)\n\n      var complete = function () {\n        var prevHoverState = that.hoverState\n        that.$element.trigger('shown.bs.' + that.type)\n        that.hoverState = null\n\n        if (prevHoverState == 'out') that.leave(that)\n      }\n\n      $.support.transition && this.$tip.hasClass('fade') ?\n        $tip\n          .one('bsTransitionEnd', complete)\n          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\n        complete()\n    }\n  }\n\n  Tooltip.prototype.applyPlacement = function (offset, placement) {\n    var $tip   = this.tip()\n    var width  = $tip[0].offsetWidth\n    var height = $tip[0].offsetHeight\n\n    // manually read margins because getBoundingClientRect includes difference\n    var marginTop = parseInt($tip.css('margin-top'), 10)\n    var marginLeft = parseInt($tip.css('margin-left'), 10)\n\n    // we must check for NaN for ie 8/9\n    if (isNaN(marginTop))  marginTop  = 0\n    if (isNaN(marginLeft)) marginLeft = 0\n\n    offset.top  += marginTop\n    offset.left += marginLeft\n\n    // $.fn.offset doesn't round pixel values\n    // so we use setOffset directly with our own function B-0\n    $.offset.setOffset($tip[0], $.extend({\n      using: function (props) {\n        $tip.css({\n          top: Math.round(props.top),\n          left: Math.round(props.left)\n        })\n      }\n    }, offset), 0)\n\n    $tip.addClass('in')\n\n    // check to see if placing tip in new offset caused the tip to resize itself\n    var actualWidth  = $tip[0].offsetWidth\n    var actualHeight = $tip[0].offsetHeight\n\n    if (placement == 'top' && actualHeight != height) {\n      offset.top = offset.top + height - actualHeight\n    }\n\n    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)\n\n    if (delta.left) offset.left += delta.left\n    else offset.top += delta.top\n\n    var isVertical          = /top|bottom/.test(placement)\n    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight\n    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'\n\n    $tip.offset(offset)\n    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)\n  }\n\n  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {\n    this.arrow()\n      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n      .css(isVertical ? 'top' : 'left', '')\n  }\n\n  Tooltip.prototype.setContent = function () {\n    var $tip  = this.tip()\n    var title = this.getTitle()\n\n    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)\n    $tip.removeClass('fade in top bottom left right')\n  }\n\n  Tooltip.prototype.hide = function (callback) {\n    var that = this\n    var $tip = $(this.$tip)\n    var e    = $.Event('hide.bs.' + this.type)\n\n    function complete() {\n      if (that.hoverState != 'in') $tip.detach()\n      that.$element\n        .removeAttr('aria-describedby')\n        .trigger('hidden.bs.' + that.type)\n      callback && callback()\n    }\n\n    this.$element.trigger(e)\n\n    if (e.isDefaultPrevented()) return\n\n    $tip.removeClass('in')\n\n    $.support.transition && $tip.hasClass('fade') ?\n      $tip\n        .one('bsTransitionEnd', complete)\n        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\n      complete()\n\n    this.hoverState = null\n\n    return this\n  }\n\n  Tooltip.prototype.fixTitle = function () {\n    var $e = this.$element\n    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {\n      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')\n    }\n  }\n\n  Tooltip.prototype.hasContent = function () {\n    return this.getTitle()\n  }\n\n  Tooltip.prototype.getPosition = function ($element) {\n    $element   = $element || this.$element\n\n    var el     = $element[0]\n    var isBody = el.tagName == 'BODY'\n\n    var elRect    = el.getBoundingClientRect()\n    if (elRect.width == null) {\n      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })\n    }\n    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()\n    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }\n    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null\n\n    return $.extend({}, elRect, scroll, outerDims, elOffset)\n  }\n\n  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {\n    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :\n           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :\n           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :\n        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }\n\n  }\n\n  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {\n    var delta = { top: 0, left: 0 }\n    if (!this.$viewport) return delta\n\n    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0\n    var viewportDimensions = this.getPosition(this.$viewport)\n\n    if (/right|left/.test(placement)) {\n      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll\n      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight\n      if (topEdgeOffset < viewportDimensions.top) { // top overflow\n        delta.top = viewportDimensions.top - topEdgeOffset\n      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset\n      }\n    } else {\n      var leftEdgeOffset  = pos.left - viewportPadding\n      var rightEdgeOffset = pos.left + viewportPadding + actualWidth\n      if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n        delta.left = viewportDimensions.left - leftEdgeOffset\n      } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset\n      }\n    }\n\n    return delta\n  }\n\n  Tooltip.prototype.getTitle = function () {\n    var title\n    var $e = this.$element\n    var o  = this.options\n\n    title = $e.attr('data-original-title')\n      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)\n\n    return title\n  }\n\n  Tooltip.prototype.getUID = function (prefix) {\n    do prefix += ~~(Math.random() * 1000000)\n    while (document.getElementById(prefix))\n    return prefix\n  }\n\n  Tooltip.prototype.tip = function () {\n    if (!this.$tip) {\n      this.$tip = $(this.options.template)\n      if (this.$tip.length != 1) {\n        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')\n      }\n    }\n    return this.$tip\n  }\n\n  Tooltip.prototype.arrow = function () {\n    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))\n  }\n\n  Tooltip.prototype.enable = function () {\n    this.enabled = true\n  }\n\n  Tooltip.prototype.disable = function () {\n    this.enabled = false\n  }\n\n  Tooltip.prototype.toggleEnabled = function () {\n    this.enabled = !this.enabled\n  }\n\n  Tooltip.prototype.toggle = function (e) {\n    var self = this\n    if (e) {\n      self = $(e.currentTarget).data('bs.' + this.type)\n      if (!self) {\n        self = new this.constructor(e.currentTarget, this.getDelegateOptions())\n        $(e.currentTarget).data('bs.' + this.type, self)\n      }\n    }\n\n    if (e) {\n      self.inState.click = !self.inState.click\n      if (self.isInStateTrue()) self.enter(self)\n      else self.leave(self)\n    } else {\n      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)\n    }\n  }\n\n  Tooltip.prototype.destroy = function () {\n    var that = this\n    clearTimeout(this.timeout)\n    this.hide(function () {\n      that.$element.off('.' + that.type).removeData('bs.' + that.type)\n      if (that.$tip) {\n        that.$tip.detach()\n      }\n      that.$tip = null\n      that.$arrow = null\n      that.$viewport = null\n    })\n  }\n\n\n  // TOOLTIP PLUGIN DEFINITION\n  // =========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.tooltip')\n      var options = typeof option == 'object' && option\n\n      if (!data && /destroy|hide/.test(option)) return\n      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.tooltip\n\n  $.fn.tooltip             = Plugin\n  $.fn.tooltip.Constructor = Tooltip\n\n\n  // TOOLTIP NO CONFLICT\n  // ===================\n\n  $.fn.tooltip.noConflict = function () {\n    $.fn.tooltip = old\n    return this\n  }\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: popover.js v3.3.6\n * http://getbootstrap.com/javascript/#popovers\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // POPOVER PUBLIC CLASS DEFINITION\n  // ===============================\n\n  var Popover = function (element, options) {\n    this.init('popover', element, options)\n  }\n\n  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')\n\n  Popover.VERSION  = '3.3.6'\n\n  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {\n    placement: 'right',\n    trigger: 'click',\n    content: '',\n    template: '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\"></div></div>'\n  })\n\n\n  // NOTE: POPOVER EXTENDS tooltip.js\n  // ================================\n\n  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)\n\n  Popover.prototype.constructor = Popover\n\n  Popover.prototype.getDefaults = function () {\n    return Popover.DEFAULTS\n  }\n\n  Popover.prototype.setContent = function () {\n    var $tip    = this.tip()\n    var title   = this.getTitle()\n    var content = this.getContent()\n\n    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)\n    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events\n      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'\n    ](content)\n\n    $tip.removeClass('fade top bottom left right in')\n\n    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do\n    // this manually by checking the contents.\n    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()\n  }\n\n  Popover.prototype.hasContent = function () {\n    return this.getTitle() || this.getContent()\n  }\n\n  Popover.prototype.getContent = function () {\n    var $e = this.$element\n    var o  = this.options\n\n    return $e.attr('data-content')\n      || (typeof o.content == 'function' ?\n            o.content.call($e[0]) :\n            o.content)\n  }\n\n  Popover.prototype.arrow = function () {\n    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))\n  }\n\n\n  // POPOVER PLUGIN DEFINITION\n  // =========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.popover')\n      var options = typeof option == 'object' && option\n\n      if (!data && /destroy|hide/.test(option)) return\n      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.popover\n\n  $.fn.popover             = Plugin\n  $.fn.popover.Constructor = Popover\n\n\n  // POPOVER NO CONFLICT\n  // ===================\n\n  $.fn.popover.noConflict = function () {\n    $.fn.popover = old\n    return this\n  }\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: scrollspy.js v3.3.6\n * http://getbootstrap.com/javascript/#scrollspy\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // SCROLLSPY CLASS DEFINITION\n  // ==========================\n\n  function ScrollSpy(element, options) {\n    this.$body          = $(document.body)\n    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)\n    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)\n    this.selector       = (this.options.target || '') + ' .nav li > a'\n    this.offsets        = []\n    this.targets        = []\n    this.activeTarget   = null\n    this.scrollHeight   = 0\n\n    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))\n    this.refresh()\n    this.process()\n  }\n\n  ScrollSpy.VERSION  = '3.3.6'\n\n  ScrollSpy.DEFAULTS = {\n    offset: 10\n  }\n\n  ScrollSpy.prototype.getScrollHeight = function () {\n    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)\n  }\n\n  ScrollSpy.prototype.refresh = function () {\n    var that          = this\n    var offsetMethod  = 'offset'\n    var offsetBase    = 0\n\n    this.offsets      = []\n    this.targets      = []\n    this.scrollHeight = this.getScrollHeight()\n\n    if (!$.isWindow(this.$scrollElement[0])) {\n      offsetMethod = 'position'\n      offsetBase   = this.$scrollElement.scrollTop()\n    }\n\n    this.$body\n      .find(this.selector)\n      .map(function () {\n        var $el   = $(this)\n        var href  = $el.data('target') || $el.attr('href')\n        var $href = /^#./.test(href) && $(href)\n\n        return ($href\n          && $href.length\n          && $href.is(':visible')\n          && [[$href[offsetMethod]().top + offsetBase, href]]) || null\n      })\n      .sort(function (a, b) { return a[0] - b[0] })\n      .each(function () {\n        that.offsets.push(this[0])\n        that.targets.push(this[1])\n      })\n  }\n\n  ScrollSpy.prototype.process = function () {\n    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset\n    var scrollHeight = this.getScrollHeight()\n    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()\n    var offsets      = this.offsets\n    var targets      = this.targets\n    var activeTarget = this.activeTarget\n    var i\n\n    if (this.scrollHeight != scrollHeight) {\n      this.refresh()\n    }\n\n    if (scrollTop >= maxScroll) {\n      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)\n    }\n\n    if (activeTarget && scrollTop < offsets[0]) {\n      this.activeTarget = null\n      return this.clear()\n    }\n\n    for (i = offsets.length; i--;) {\n      activeTarget != targets[i]\n        && scrollTop >= offsets[i]\n        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])\n        && this.activate(targets[i])\n    }\n  }\n\n  ScrollSpy.prototype.activate = function (target) {\n    this.activeTarget = target\n\n    this.clear()\n\n    var selector = this.selector +\n      '[data-target=\"' + target + '\"],' +\n      this.selector + '[href=\"' + target + '\"]'\n\n    var active = $(selector)\n      .parents('li')\n      .addClass('active')\n\n    if (active.parent('.dropdown-menu').length) {\n      active = active\n        .closest('li.dropdown')\n        .addClass('active')\n    }\n\n    active.trigger('activate.bs.scrollspy')\n  }\n\n  ScrollSpy.prototype.clear = function () {\n    $(this.selector)\n      .parentsUntil(this.options.target, '.active')\n      .removeClass('active')\n  }\n\n\n  // SCROLLSPY PLUGIN DEFINITION\n  // ===========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.scrollspy')\n      var options = typeof option == 'object' && option\n\n      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.scrollspy\n\n  $.fn.scrollspy             = Plugin\n  $.fn.scrollspy.Constructor = ScrollSpy\n\n\n  // SCROLLSPY NO CONFLICT\n  // =====================\n\n  $.fn.scrollspy.noConflict = function () {\n    $.fn.scrollspy = old\n    return this\n  }\n\n\n  // SCROLLSPY DATA-API\n  // ==================\n\n  $(window).on('load.bs.scrollspy.data-api', function () {\n    $('[data-spy=\"scroll\"]').each(function () {\n      var $spy = $(this)\n      Plugin.call($spy, $spy.data())\n    })\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: tab.js v3.3.6\n * http://getbootstrap.com/javascript/#tabs\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // TAB CLASS DEFINITION\n  // ====================\n\n  var Tab = function (element) {\n    // jscs:disable requireDollarBeforejQueryAssignment\n    this.element = $(element)\n    // jscs:enable requireDollarBeforejQueryAssignment\n  }\n\n  Tab.VERSION = '3.3.6'\n\n  Tab.TRANSITION_DURATION = 150\n\n  Tab.prototype.show = function () {\n    var $this    = this.element\n    var $ul      = $this.closest('ul:not(.dropdown-menu)')\n    var selector = $this.data('target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    if ($this.parent('li').hasClass('active')) return\n\n    var $previous = $ul.find('.active:last a')\n    var hideEvent = $.Event('hide.bs.tab', {\n      relatedTarget: $this[0]\n    })\n    var showEvent = $.Event('show.bs.tab', {\n      relatedTarget: $previous[0]\n    })\n\n    $previous.trigger(hideEvent)\n    $this.trigger(showEvent)\n\n    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return\n\n    var $target = $(selector)\n\n    this.activate($this.closest('li'), $ul)\n    this.activate($target, $target.parent(), function () {\n      $previous.trigger({\n        type: 'hidden.bs.tab',\n        relatedTarget: $this[0]\n      })\n      $this.trigger({\n        type: 'shown.bs.tab',\n        relatedTarget: $previous[0]\n      })\n    })\n  }\n\n  Tab.prototype.activate = function (element, container, callback) {\n    var $active    = container.find('> .active')\n    var transition = callback\n      && $.support.transition\n      && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)\n\n    function next() {\n      $active\n        .removeClass('active')\n        .find('> .dropdown-menu > .active')\n          .removeClass('active')\n        .end()\n        .find('[data-toggle=\"tab\"]')\n          .attr('aria-expanded', false)\n\n      element\n        .addClass('active')\n        .find('[data-toggle=\"tab\"]')\n          .attr('aria-expanded', true)\n\n      if (transition) {\n        element[0].offsetWidth // reflow for transition\n        element.addClass('in')\n      } else {\n        element.removeClass('fade')\n      }\n\n      if (element.parent('.dropdown-menu').length) {\n        element\n          .closest('li.dropdown')\n            .addClass('active')\n          .end()\n          .find('[data-toggle=\"tab\"]')\n            .attr('aria-expanded', true)\n      }\n\n      callback && callback()\n    }\n\n    $active.length && transition ?\n      $active\n        .one('bsTransitionEnd', next)\n        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :\n      next()\n\n    $active.removeClass('in')\n  }\n\n\n  // TAB PLUGIN DEFINITION\n  // =====================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.tab')\n\n      if (!data) $this.data('bs.tab', (data = new Tab(this)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.tab\n\n  $.fn.tab             = Plugin\n  $.fn.tab.Constructor = Tab\n\n\n  // TAB NO CONFLICT\n  // ===============\n\n  $.fn.tab.noConflict = function () {\n    $.fn.tab = old\n    return this\n  }\n\n\n  // TAB DATA-API\n  // ============\n\n  var clickHandler = function (e) {\n    e.preventDefault()\n    Plugin.call($(this), 'show')\n  }\n\n  $(document)\n    .on('click.bs.tab.data-api', '[data-toggle=\"tab\"]', clickHandler)\n    .on('click.bs.tab.data-api', '[data-toggle=\"pill\"]', clickHandler)\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: affix.js v3.3.6\n * http://getbootstrap.com/javascript/#affix\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // AFFIX CLASS DEFINITION\n  // ======================\n\n  var Affix = function (element, options) {\n    this.options = $.extend({}, Affix.DEFAULTS, options)\n\n    this.$target = $(this.options.target)\n      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))\n      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))\n\n    this.$element     = $(element)\n    this.affixed      = null\n    this.unpin        = null\n    this.pinnedOffset = null\n\n    this.checkPosition()\n  }\n\n  Affix.VERSION  = '3.3.6'\n\n  Affix.RESET    = 'affix affix-top affix-bottom'\n\n  Affix.DEFAULTS = {\n    offset: 0,\n    target: window\n  }\n\n  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {\n    var scrollTop    = this.$target.scrollTop()\n    var position     = this.$element.offset()\n    var targetHeight = this.$target.height()\n\n    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false\n\n    if (this.affixed == 'bottom') {\n      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'\n      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'\n    }\n\n    var initializing   = this.affixed == null\n    var colliderTop    = initializing ? scrollTop : position.top\n    var colliderHeight = initializing ? targetHeight : height\n\n    if (offsetTop != null && scrollTop <= offsetTop) return 'top'\n    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'\n\n    return false\n  }\n\n  Affix.prototype.getPinnedOffset = function () {\n    if (this.pinnedOffset) return this.pinnedOffset\n    this.$element.removeClass(Affix.RESET).addClass('affix')\n    var scrollTop = this.$target.scrollTop()\n    var position  = this.$element.offset()\n    return (this.pinnedOffset = position.top - scrollTop)\n  }\n\n  Affix.prototype.checkPositionWithEventLoop = function () {\n    setTimeout($.proxy(this.checkPosition, this), 1)\n  }\n\n  Affix.prototype.checkPosition = function () {\n    if (!this.$element.is(':visible')) return\n\n    var height       = this.$element.height()\n    var offset       = this.options.offset\n    var offsetTop    = offset.top\n    var offsetBottom = offset.bottom\n    var scrollHeight = Math.max($(document).height(), $(document.body).height())\n\n    if (typeof offset != 'object')         offsetBottom = offsetTop = offset\n    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)\n    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)\n\n    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)\n\n    if (this.affixed != affix) {\n      if (this.unpin != null) this.$element.css('top', '')\n\n      var affixType = 'affix' + (affix ? '-' + affix : '')\n      var e         = $.Event(affixType + '.bs.affix')\n\n      this.$element.trigger(e)\n\n      if (e.isDefaultPrevented()) return\n\n      this.affixed = affix\n      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null\n\n      this.$element\n        .removeClass(Affix.RESET)\n        .addClass(affixType)\n        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')\n    }\n\n    if (affix == 'bottom') {\n      this.$element.offset({\n        top: scrollHeight - height - offsetBottom\n      })\n    }\n  }\n\n\n  // AFFIX PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.affix')\n      var options = typeof option == 'object' && option\n\n      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.affix\n\n  $.fn.affix             = Plugin\n  $.fn.affix.Constructor = Affix\n\n\n  // AFFIX NO CONFLICT\n  // =================\n\n  $.fn.affix.noConflict = function () {\n    $.fn.affix = old\n    return this\n  }\n\n\n  // AFFIX DATA-API\n  // ==============\n\n  $(window).on('load', function () {\n    $('[data-spy=\"affix\"]').each(function () {\n      var $spy = $(this)\n      var data = $spy.data()\n\n      data.offset = data.offset || {}\n\n      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom\n      if (data.offsetTop    != null) data.offset.top    = data.offsetTop\n\n      Plugin.call($spy, data)\n    })\n  })\n\n}(jQuery);\n","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    global.moment = factory()\n}(this, function () { 'use strict';\n\n    var hookCallback;\n\n    function utils_hooks__hooks () {\n        return hookCallback.apply(null, arguments);\n    }\n\n    // This is done to register the method called with moment()\n    // without creating circular dependencies.\n    function setHookCallback (callback) {\n        hookCallback = callback;\n    }\n\n    function isArray(input) {\n        return Object.prototype.toString.call(input) === '[object Array]';\n    }\n\n    function isDate(input) {\n        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n    }\n\n    function map(arr, fn) {\n        var res = [], i;\n        for (i = 0; i < arr.length; ++i) {\n            res.push(fn(arr[i], i));\n        }\n        return res;\n    }\n\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a, b);\n    }\n\n    function extend(a, b) {\n        for (var i in b) {\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n\n        if (hasOwnProp(b, 'toString')) {\n            a.toString = b.toString;\n        }\n\n        if (hasOwnProp(b, 'valueOf')) {\n            a.valueOf = b.valueOf;\n        }\n\n        return a;\n    }\n\n    function create_utc__createUTC (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\n    }\n\n    function defaultParsingFlags() {\n        // We need to deep clone this object.\n        return {\n            empty           : false,\n            unusedTokens    : [],\n            unusedInput     : [],\n            overflow        : -2,\n            charsLeftOver   : 0,\n            nullInput       : false,\n            invalidMonth    : null,\n            invalidFormat   : false,\n            userInvalidated : false,\n            iso             : false\n        };\n    }\n\n    function getParsingFlags(m) {\n        if (m._pf == null) {\n            m._pf = defaultParsingFlags();\n        }\n        return m._pf;\n    }\n\n    function valid__isValid(m) {\n        if (m._isValid == null) {\n            var flags = getParsingFlags(m);\n            m._isValid = !isNaN(m._d.getTime()) &&\n                flags.overflow < 0 &&\n                !flags.empty &&\n                !flags.invalidMonth &&\n                !flags.invalidWeekday &&\n                !flags.nullInput &&\n                !flags.invalidFormat &&\n                !flags.userInvalidated;\n\n            if (m._strict) {\n                m._isValid = m._isValid &&\n                    flags.charsLeftOver === 0 &&\n                    flags.unusedTokens.length === 0 &&\n                    flags.bigHour === undefined;\n            }\n        }\n        return m._isValid;\n    }\n\n    function valid__createInvalid (flags) {\n        var m = create_utc__createUTC(NaN);\n        if (flags != null) {\n            extend(getParsingFlags(m), flags);\n        }\n        else {\n            getParsingFlags(m).userInvalidated = true;\n        }\n\n        return m;\n    }\n\n    var momentProperties = utils_hooks__hooks.momentProperties = [];\n\n    function copyConfig(to, from) {\n        var i, prop, val;\n\n        if (typeof from._isAMomentObject !== 'undefined') {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if (typeof from._i !== 'undefined') {\n            to._i = from._i;\n        }\n        if (typeof from._f !== 'undefined') {\n            to._f = from._f;\n        }\n        if (typeof from._l !== 'undefined') {\n            to._l = from._l;\n        }\n        if (typeof from._strict !== 'undefined') {\n            to._strict = from._strict;\n        }\n        if (typeof from._tzm !== 'undefined') {\n            to._tzm = from._tzm;\n        }\n        if (typeof from._isUTC !== 'undefined') {\n            to._isUTC = from._isUTC;\n        }\n        if (typeof from._offset !== 'undefined') {\n            to._offset = from._offset;\n        }\n        if (typeof from._pf !== 'undefined') {\n            to._pf = getParsingFlags(from);\n        }\n        if (typeof from._locale !== 'undefined') {\n            to._locale = from._locale;\n        }\n\n        if (momentProperties.length > 0) {\n            for (i in momentProperties) {\n                prop = momentProperties[i];\n                val = from[prop];\n                if (typeof val !== 'undefined') {\n                    to[prop] = val;\n                }\n            }\n        }\n\n        return to;\n    }\n\n    var updateInProgress = false;\n\n    // Moment prototype object\n    function Moment(config) {\n        copyConfig(this, config);\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n        // Prevent infinite loop in case updateOffset creates new moment\n        // objects.\n        if (updateInProgress === false) {\n            updateInProgress = true;\n            utils_hooks__hooks.updateOffset(this);\n            updateInProgress = false;\n        }\n    }\n\n    function isMoment (obj) {\n        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\n    }\n\n    function absFloor (number) {\n        if (number < 0) {\n            return Math.ceil(number);\n        } else {\n            return Math.floor(number);\n        }\n    }\n\n    function toInt(argumentForCoercion) {\n        var coercedNumber = +argumentForCoercion,\n            value = 0;\n\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            value = absFloor(coercedNumber);\n        }\n\n        return value;\n    }\n\n    function compareArrays(array1, array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length),\n            lengthDiff = Math.abs(array1.length - array2.length),\n            diffs = 0,\n            i;\n        for (i = 0; i < len; i++) {\n            if ((dontConvert && array1[i] !== array2[i]) ||\n                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n                diffs++;\n            }\n        }\n        return diffs + lengthDiff;\n    }\n\n    function Locale() {\n    }\n\n    var locales = {};\n    var globalLocale;\n\n    function normalizeLocale(key) {\n        return key ? key.toLowerCase().replace('_', '-') : key;\n    }\n\n    // pick the locale from the array\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n    function chooseLocale(names) {\n        var i = 0, j, next, locale, split;\n\n        while (i < names.length) {\n            split = normalizeLocale(names[i]).split('-');\n            j = split.length;\n            next = normalizeLocale(names[i + 1]);\n            next = next ? next.split('-') : null;\n            while (j > 0) {\n                locale = loadLocale(split.slice(0, j).join('-'));\n                if (locale) {\n                    return locale;\n                }\n                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n                    //the next array item is better than a shallower substring of this one\n                    break;\n                }\n                j--;\n            }\n            i++;\n        }\n        return null;\n    }\n\n    function loadLocale(name) {\n        var oldLocale = null;\n        // TODO: Find a better way to register and load all the locales in Node\n        if (!locales[name] && typeof module !== 'undefined' &&\n                module && module.exports) {\n            try {\n                oldLocale = globalLocale._abbr;\n                require('./locale/' + name);\n                // because defineLocale currently also sets the global locale, we\n                // want to undo that for lazy loaded locales\n                locale_locales__getSetGlobalLocale(oldLocale);\n            } catch (e) { }\n        }\n        return locales[name];\n    }\n\n    // This function will load locale and then set the global locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    function locale_locales__getSetGlobalLocale (key, values) {\n        var data;\n        if (key) {\n            if (typeof values === 'undefined') {\n                data = locale_locales__getLocale(key);\n            }\n            else {\n                data = defineLocale(key, values);\n            }\n\n            if (data) {\n                // moment.duration._locale = moment._locale = data;\n                globalLocale = data;\n            }\n        }\n\n        return globalLocale._abbr;\n    }\n\n    function defineLocale (name, values) {\n        if (values !== null) {\n            values.abbr = name;\n            locales[name] = locales[name] || new Locale();\n            locales[name].set(values);\n\n            // backwards compat for now: also set the locale\n            locale_locales__getSetGlobalLocale(name);\n\n            return locales[name];\n        } else {\n            // useful for testing\n            delete locales[name];\n            return null;\n        }\n    }\n\n    // returns locale data\n    function locale_locales__getLocale (key) {\n        var locale;\n\n        if (key && key._locale && key._locale._abbr) {\n            key = key._locale._abbr;\n        }\n\n        if (!key) {\n            return globalLocale;\n        }\n\n        if (!isArray(key)) {\n            //short-circuit everything else\n            locale = loadLocale(key);\n            if (locale) {\n                return locale;\n            }\n            key = [key];\n        }\n\n        return chooseLocale(key);\n    }\n\n    var aliases = {};\n\n    function addUnitAlias (unit, shorthand) {\n        var lowerCase = unit.toLowerCase();\n        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n    }\n\n    function normalizeUnits(units) {\n        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n    }\n\n    function normalizeObjectUnits(inputObject) {\n        var normalizedInput = {},\n            normalizedProp,\n            prop;\n\n        for (prop in inputObject) {\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp] = inputObject[prop];\n                }\n            }\n        }\n\n        return normalizedInput;\n    }\n\n    function makeGetSet (unit, keepTime) {\n        return function (value) {\n            if (value != null) {\n                get_set__set(this, unit, value);\n                utils_hooks__hooks.updateOffset(this, keepTime);\n                return this;\n            } else {\n                return get_set__get(this, unit);\n            }\n        };\n    }\n\n    function get_set__get (mom, unit) {\n        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();\n    }\n\n    function get_set__set (mom, unit, value) {\n        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n    }\n\n    // MOMENTS\n\n    function getSet (units, value) {\n        var unit;\n        if (typeof units === 'object') {\n            for (unit in units) {\n                this.set(unit, units[unit]);\n            }\n        } else {\n            units = normalizeUnits(units);\n            if (typeof this[units] === 'function') {\n                return this[units](value);\n            }\n        }\n        return this;\n    }\n\n    function zeroFill(number, targetLength, forceSign) {\n        var absNumber = '' + Math.abs(number),\n            zerosToFill = targetLength - absNumber.length,\n            sign = number >= 0;\n        return (sign ? (forceSign ? '+' : '') : '-') +\n            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n    }\n\n    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\n    var localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\n    var formatFunctions = {};\n\n    var formatTokenFunctions = {};\n\n    // token:    'M'\n    // padded:   ['MM', 2]\n    // ordinal:  'Mo'\n    // callback: function () { this.month() + 1 }\n    function addFormatToken (token, padded, ordinal, callback) {\n        var func = callback;\n        if (typeof callback === 'string') {\n            func = function () {\n                return this[callback]();\n            };\n        }\n        if (token) {\n            formatTokenFunctions[token] = func;\n        }\n        if (padded) {\n            formatTokenFunctions[padded[0]] = function () {\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n            };\n        }\n        if (ordinal) {\n            formatTokenFunctions[ordinal] = function () {\n                return this.localeData().ordinal(func.apply(this, arguments), token);\n            };\n        }\n    }\n\n    function removeFormattingTokens(input) {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g, '');\n        }\n        return input.replace(/\\\\/g, '');\n    }\n\n    function makeFormatFunction(format) {\n        var array = format.match(formattingTokens), i, length;\n\n        for (i = 0, length = array.length; i < length; i++) {\n            if (formatTokenFunctions[array[i]]) {\n                array[i] = formatTokenFunctions[array[i]];\n            } else {\n                array[i] = removeFormattingTokens(array[i]);\n            }\n        }\n\n        return function (mom) {\n            var output = '';\n            for (i = 0; i < length; i++) {\n                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];\n            }\n            return output;\n        };\n    }\n\n    // format date using native date object\n    function formatMoment(m, format) {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n        }\n\n        format = expandFormat(format, m.localeData());\n        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n\n        return formatFunctions[format](m);\n    }\n\n    function expandFormat(format, locale) {\n        var i = 5;\n\n        function replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input) || input;\n        }\n\n        localFormattingTokens.lastIndex = 0;\n        while (i >= 0 && localFormattingTokens.test(format)) {\n            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n            localFormattingTokens.lastIndex = 0;\n            i -= 1;\n        }\n\n        return format;\n    }\n\n    var match1         = /\\d/;            //       0 - 9\n    var match2         = /\\d\\d/;          //      00 - 99\n    var match3         = /\\d{3}/;         //     000 - 999\n    var match4         = /\\d{4}/;         //    0000 - 9999\n    var match6         = /[+-]?\\d{6}/;    // -999999 - 999999\n    var match1to2      = /\\d\\d?/;         //       0 - 99\n    var match1to3      = /\\d{1,3}/;       //       0 - 999\n    var match1to4      = /\\d{1,4}/;       //       0 - 9999\n    var match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\n\n    var matchUnsigned  = /\\d+/;           //       0 - inf\n    var matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\n    var matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\n\n    var matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\n\n    // any word (or two) characters or numbers including two/three word month in arabic.\n    var matchWord = /[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i;\n\n    var regexes = {};\n\n    function isFunction (sth) {\n        // https://github.com/moment/moment/issues/2325\n        return typeof sth === 'function' &&\n            Object.prototype.toString.call(sth) === '[object Function]';\n    }\n\n\n    function addRegexToken (token, regex, strictRegex) {\n        regexes[token] = isFunction(regex) ? regex : function (isStrict) {\n            return (isStrict && strictRegex) ? strictRegex : regex;\n        };\n    }\n\n    function getParseRegexForToken (token, config) {\n        if (!hasOwnProp(regexes, token)) {\n            return new RegExp(unescapeFormat(token));\n        }\n\n        return regexes[token](config._strict, config._locale);\n    }\n\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n    function unescapeFormat(s) {\n        return s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n            return p1 || p2 || p3 || p4;\n        }).replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    }\n\n    var tokens = {};\n\n    function addParseToken (token, callback) {\n        var i, func = callback;\n        if (typeof token === 'string') {\n            token = [token];\n        }\n        if (typeof callback === 'number') {\n            func = function (input, array) {\n                array[callback] = toInt(input);\n            };\n        }\n        for (i = 0; i < token.length; i++) {\n            tokens[token[i]] = func;\n        }\n    }\n\n    function addWeekParseToken (token, callback) {\n        addParseToken(token, function (input, array, config, token) {\n            config._w = config._w || {};\n            callback(input, config._w, config, token);\n        });\n    }\n\n    function addTimeToArrayFromToken(token, input, config) {\n        if (input != null && hasOwnProp(tokens, token)) {\n            tokens[token](input, config._a, config, token);\n        }\n    }\n\n    var YEAR = 0;\n    var MONTH = 1;\n    var DATE = 2;\n    var HOUR = 3;\n    var MINUTE = 4;\n    var SECOND = 5;\n    var MILLISECOND = 6;\n\n    function daysInMonth(year, month) {\n        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();\n    }\n\n    // FORMATTING\n\n    addFormatToken('M', ['MM', 2], 'Mo', function () {\n        return this.month() + 1;\n    });\n\n    addFormatToken('MMM', 0, 0, function (format) {\n        return this.localeData().monthsShort(this, format);\n    });\n\n    addFormatToken('MMMM', 0, 0, function (format) {\n        return this.localeData().months(this, format);\n    });\n\n    // ALIASES\n\n    addUnitAlias('month', 'M');\n\n    // PARSING\n\n    addRegexToken('M',    match1to2);\n    addRegexToken('MM',   match1to2, match2);\n    addRegexToken('MMM',  matchWord);\n    addRegexToken('MMMM', matchWord);\n\n    addParseToken(['M', 'MM'], function (input, array) {\n        array[MONTH] = toInt(input) - 1;\n    });\n\n    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n        var month = config._locale.monthsParse(input, token, config._strict);\n        // if we didn't find a month name, mark the date as invalid.\n        if (month != null) {\n            array[MONTH] = month;\n        } else {\n            getParsingFlags(config).invalidMonth = input;\n        }\n    });\n\n    // LOCALES\n\n    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\n    function localeMonths (m) {\n        return this._months[m.month()];\n    }\n\n    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\n    function localeMonthsShort (m) {\n        return this._monthsShort[m.month()];\n    }\n\n    function localeMonthsParse (monthName, format, strict) {\n        var i, mom, regex;\n\n        if (!this._monthsParse) {\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n        }\n\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = create_utc__createUTC([2000, i]);\n            if (strict && !this._longMonthsParse[i]) {\n                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n            }\n            if (!strict && !this._monthsParse[i]) {\n                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function setMonth (mom, value) {\n        var dayOfMonth;\n\n        // TODO: Move this out of here!\n        if (typeof value === 'string') {\n            value = mom.localeData().monthsParse(value);\n            // TODO: Another silent failure?\n            if (typeof value !== 'number') {\n                return mom;\n            }\n        }\n\n        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n        return mom;\n    }\n\n    function getSetMonth (value) {\n        if (value != null) {\n            setMonth(this, value);\n            utils_hooks__hooks.updateOffset(this, true);\n            return this;\n        } else {\n            return get_set__get(this, 'Month');\n        }\n    }\n\n    function getDaysInMonth () {\n        return daysInMonth(this.year(), this.month());\n    }\n\n    function checkOverflow (m) {\n        var overflow;\n        var a = m._a;\n\n        if (a && getParsingFlags(m).overflow === -2) {\n            overflow =\n                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\n                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\n                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\n                -1;\n\n            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n                overflow = DATE;\n            }\n\n            getParsingFlags(m).overflow = overflow;\n        }\n\n        return m;\n    }\n\n    function warn(msg) {\n        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {\n            console.warn('Deprecation warning: ' + msg);\n        }\n    }\n\n    function deprecate(msg, fn) {\n        var firstTime = true;\n\n        return extend(function () {\n            if (firstTime) {\n                warn(msg + '\\n' + (new Error()).stack);\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n\n    var deprecations = {};\n\n    function deprecateSimple(name, msg) {\n        if (!deprecations[name]) {\n            warn(msg);\n            deprecations[name] = true;\n        }\n    }\n\n    utils_hooks__hooks.suppressDeprecationWarnings = false;\n\n    var from_string__isoRegex = /^\\s*(?:[+-]\\d{6}|\\d{4})-(?:(\\d\\d-\\d\\d)|(W\\d\\d$)|(W\\d\\d-\\d)|(\\d\\d\\d))((T| )(\\d\\d(:\\d\\d(:\\d\\d(\\.\\d+)?)?)?)?([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\n    var isoDates = [\n        ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d{2}-\\d{2}/],\n        ['YYYY-MM-DD', /\\d{4}-\\d{2}-\\d{2}/],\n        ['GGGG-[W]WW-E', /\\d{4}-W\\d{2}-\\d/],\n        ['GGGG-[W]WW', /\\d{4}-W\\d{2}/],\n        ['YYYY-DDD', /\\d{4}-\\d{3}/]\n    ];\n\n    // iso time formats and regexes\n    var isoTimes = [\n        ['HH:mm:ss.SSSS', /(T| )\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n        ['HH:mm:ss', /(T| )\\d\\d:\\d\\d:\\d\\d/],\n        ['HH:mm', /(T| )\\d\\d:\\d\\d/],\n        ['HH', /(T| )\\d\\d/]\n    ];\n\n    var aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\n    // date from iso format\n    function configFromISO(config) {\n        var i, l,\n            string = config._i,\n            match = from_string__isoRegex.exec(string);\n\n        if (match) {\n            getParsingFlags(config).iso = true;\n            for (i = 0, l = isoDates.length; i < l; i++) {\n                if (isoDates[i][1].exec(string)) {\n                    config._f = isoDates[i][0];\n                    break;\n                }\n            }\n            for (i = 0, l = isoTimes.length; i < l; i++) {\n                if (isoTimes[i][1].exec(string)) {\n                    // match[6] should be 'T' or space\n                    config._f += (match[6] || ' ') + isoTimes[i][0];\n                    break;\n                }\n            }\n            if (string.match(matchOffset)) {\n                config._f += 'Z';\n            }\n            configFromStringAndFormat(config);\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // date from iso format or fallback\n    function configFromString(config) {\n        var matched = aspNetJsonRegex.exec(config._i);\n\n        if (matched !== null) {\n            config._d = new Date(+matched[1]);\n            return;\n        }\n\n        configFromISO(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n            utils_hooks__hooks.createFromInputFallback(config);\n        }\n    }\n\n    utils_hooks__hooks.createFromInputFallback = deprecate(\n        'moment construction falls back to js Date. This is ' +\n        'discouraged and will be removed in upcoming major ' +\n        'release. Please refer to ' +\n        'https://github.com/moment/moment/issues/1407 for more info.',\n        function (config) {\n            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n        }\n    );\n\n    function createDate (y, m, d, h, M, s, ms) {\n        //can't just apply() to create a date:\n        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply\n        var date = new Date(y, m, d, h, M, s, ms);\n\n        //the date constructor doesn't accept years < 1970\n        if (y < 1970) {\n            date.setFullYear(y);\n        }\n        return date;\n    }\n\n    function createUTCDate (y) {\n        var date = new Date(Date.UTC.apply(null, arguments));\n        if (y < 1970) {\n            date.setUTCFullYear(y);\n        }\n        return date;\n    }\n\n    addFormatToken(0, ['YY', 2], 0, function () {\n        return this.year() % 100;\n    });\n\n    addFormatToken(0, ['YYYY',   4],       0, 'year');\n    addFormatToken(0, ['YYYYY',  5],       0, 'year');\n    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n    // ALIASES\n\n    addUnitAlias('year', 'y');\n\n    // PARSING\n\n    addRegexToken('Y',      matchSigned);\n    addRegexToken('YY',     match1to2, match2);\n    addRegexToken('YYYY',   match1to4, match4);\n    addRegexToken('YYYYY',  match1to6, match6);\n    addRegexToken('YYYYYY', match1to6, match6);\n\n    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n    addParseToken('YYYY', function (input, array) {\n        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);\n    });\n    addParseToken('YY', function (input, array) {\n        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);\n    });\n\n    // HELPERS\n\n    function daysInYear(year) {\n        return isLeapYear(year) ? 366 : 365;\n    }\n\n    function isLeapYear(year) {\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n    }\n\n    // HOOKS\n\n    utils_hooks__hooks.parseTwoDigitYear = function (input) {\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n\n    // MOMENTS\n\n    var getSetYear = makeGetSet('FullYear', false);\n\n    function getIsLeapYear () {\n        return isLeapYear(this.year());\n    }\n\n    addFormatToken('w', ['ww', 2], 'wo', 'week');\n    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n    // ALIASES\n\n    addUnitAlias('week', 'w');\n    addUnitAlias('isoWeek', 'W');\n\n    // PARSING\n\n    addRegexToken('w',  match1to2);\n    addRegexToken('ww', match1to2, match2);\n    addRegexToken('W',  match1to2);\n    addRegexToken('WW', match1to2, match2);\n\n    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n        week[token.substr(0, 1)] = toInt(input);\n    });\n\n    // HELPERS\n\n    // firstDayOfWeek       0 = sun, 6 = sat\n    //                      the day of the week that starts the week\n    //                      (usually sunday or monday)\n    // firstDayOfWeekOfYear 0 = sun, 6 = sat\n    //                      the first week is the week that contains the first\n    //                      of this day of the week\n    //                      (eg. ISO weeks use thursday (4))\n    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {\n        var end = firstDayOfWeekOfYear - firstDayOfWeek,\n            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),\n            adjustedMoment;\n\n\n        if (daysToDayOfWeek > end) {\n            daysToDayOfWeek -= 7;\n        }\n\n        if (daysToDayOfWeek < end - 7) {\n            daysToDayOfWeek += 7;\n        }\n\n        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');\n        return {\n            week: Math.ceil(adjustedMoment.dayOfYear() / 7),\n            year: adjustedMoment.year()\n        };\n    }\n\n    // LOCALES\n\n    function localeWeek (mom) {\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n    }\n\n    var defaultLocaleWeek = {\n        dow : 0, // Sunday is the first day of the week.\n        doy : 6  // The week that contains Jan 1st is the first week of the year.\n    };\n\n    function localeFirstDayOfWeek () {\n        return this._week.dow;\n    }\n\n    function localeFirstDayOfYear () {\n        return this._week.doy;\n    }\n\n    // MOMENTS\n\n    function getSetWeek (input) {\n        var week = this.localeData().week(this);\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    function getSetISOWeek (input) {\n        var week = weekOfYear(this, 1, 4).week;\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n    // ALIASES\n\n    addUnitAlias('dayOfYear', 'DDD');\n\n    // PARSING\n\n    addRegexToken('DDD',  match1to3);\n    addRegexToken('DDDD', match3);\n    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n        config._dayOfYear = toInt(input);\n    });\n\n    // HELPERS\n\n    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {\n        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;\n        if (d < firstDayOfWeek) {\n            d += 7;\n        }\n\n        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;\n\n        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;\n\n        return {\n            year: dayOfYear > 0 ? year : year - 1,\n            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear\n        };\n    }\n\n    // MOMENTS\n\n    function getSetDayOfYear (input) {\n        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function currentDateArray(config) {\n        var now = new Date();\n        if (config._useUTC) {\n            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];\n        }\n        return [now.getFullYear(), now.getMonth(), now.getDate()];\n    }\n\n    // convert an array to a date.\n    // the array should mirror the parameters below\n    // note: all values past the year are optional and will default to the lowest possible value.\n    // [year, month, day , hour, minute, second, millisecond]\n    function configFromArray (config) {\n        var i, date, input = [], currentDate, yearToUse;\n\n        if (config._d) {\n            return;\n        }\n\n        currentDate = currentDateArray(config);\n\n        //compute day of the year from weeks and weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n\n        //if the day of the year is set, figure out what it is\n        if (config._dayOfYear) {\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n            if (config._dayOfYear > daysInYear(yearToUse)) {\n                getParsingFlags(config)._overflowDayOfYear = true;\n            }\n\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n            config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE] = date.getUTCDate();\n        }\n\n        // Default to current date.\n        // * if no year, month, day of month are given, default to today\n        // * if day of month is given, default month and year\n        // * if month is given, default only year\n        // * if year is given, don't default anything\n        for (i = 0; i < 3 && config._a[i] == null; ++i) {\n            config._a[i] = input[i] = currentDate[i];\n        }\n\n        // Zero out whatever was not defaulted, including time\n        for (; i < 7; i++) {\n            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n        }\n\n        // Check for 24:00:00.000\n        if (config._a[HOUR] === 24 &&\n                config._a[MINUTE] === 0 &&\n                config._a[SECOND] === 0 &&\n                config._a[MILLISECOND] === 0) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n        }\n\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n        // Apply timezone offset from input. The actual utcOffset can be changed\n        // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n        }\n\n        if (config._nextDay) {\n            config._a[HOUR] = 24;\n        }\n    }\n\n    function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday, dow, doy, temp;\n\n        w = config._w;\n        if (w.GG != null || w.W != null || w.E != null) {\n            dow = 1;\n            doy = 4;\n\n            // TODO: We need to take the current isoWeekYear, but that depends on\n            // how we interpret now (local, utc, fixed offset). So create\n            // a now version of current config (take local/utc/offset flags, and\n            // create now).\n            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);\n            week = defaults(w.W, 1);\n            weekday = defaults(w.E, 1);\n        } else {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n\n            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);\n            week = defaults(w.w, 1);\n\n            if (w.d != null) {\n                // weekday -- low day numbers are considered next week\n                weekday = w.d;\n                if (weekday < dow) {\n                    ++week;\n                }\n            } else if (w.e != null) {\n                // local weekday -- counting starts from begining of week\n                weekday = w.e + dow;\n            } else {\n                // default to begining of week\n                weekday = dow;\n            }\n        }\n        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);\n\n        config._a[YEAR] = temp.year;\n        config._dayOfYear = temp.dayOfYear;\n    }\n\n    utils_hooks__hooks.ISO_8601 = function () {};\n\n    // date from string and format string\n    function configFromStringAndFormat(config) {\n        // TODO: Move this to another part of the creation flow to prevent circular deps\n        if (config._f === utils_hooks__hooks.ISO_8601) {\n            configFromISO(config);\n            return;\n        }\n\n        config._a = [];\n        getParsingFlags(config).empty = true;\n\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n        var string = '' + config._i,\n            i, parsedInput, tokens, token, skipped,\n            stringLength = string.length,\n            totalParsedInputLength = 0;\n\n        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i];\n            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n            if (parsedInput) {\n                skipped = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length > 0) {\n                    getParsingFlags(config).unusedInput.push(skipped);\n                }\n                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n                totalParsedInputLength += parsedInput.length;\n            }\n            // don't parse if it's not a known token\n            if (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    getParsingFlags(config).empty = false;\n                }\n                else {\n                    getParsingFlags(config).unusedTokens.push(token);\n                }\n                addTimeToArrayFromToken(token, parsedInput, config);\n            }\n            else if (config._strict && !parsedInput) {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n        }\n\n        // add remaining unparsed input length to the string\n        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            getParsingFlags(config).unusedInput.push(string);\n        }\n\n        // clear _12h flag if hour is <= 12\n        if (getParsingFlags(config).bigHour === true &&\n                config._a[HOUR] <= 12 &&\n                config._a[HOUR] > 0) {\n            getParsingFlags(config).bigHour = undefined;\n        }\n        // handle meridiem\n        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\n        configFromArray(config);\n        checkOverflow(config);\n    }\n\n\n    function meridiemFixWrap (locale, hour, meridiem) {\n        var isPm;\n\n        if (meridiem == null) {\n            // nothing to do\n            return hour;\n        }\n        if (locale.meridiemHour != null) {\n            return locale.meridiemHour(hour, meridiem);\n        } else if (locale.isPM != null) {\n            // Fallback\n            isPm = locale.isPM(meridiem);\n            if (isPm && hour < 12) {\n                hour += 12;\n            }\n            if (!isPm && hour === 12) {\n                hour = 0;\n            }\n            return hour;\n        } else {\n            // this is not supposed to happen\n            return hour;\n        }\n    }\n\n    function configFromStringAndArray(config) {\n        var tempConfig,\n            bestMoment,\n\n            scoreToBeat,\n            i,\n            currentScore;\n\n        if (config._f.length === 0) {\n            getParsingFlags(config).invalidFormat = true;\n            config._d = new Date(NaN);\n            return;\n        }\n\n        for (i = 0; i < config._f.length; i++) {\n            currentScore = 0;\n            tempConfig = copyConfig({}, config);\n            if (config._useUTC != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n            tempConfig._f = config._f[i];\n            configFromStringAndFormat(tempConfig);\n\n            if (!valid__isValid(tempConfig)) {\n                continue;\n            }\n\n            // if there is any input that was not parsed add a penalty for that format\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n            //or tokens\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n            getParsingFlags(tempConfig).score = currentScore;\n\n            if (scoreToBeat == null || currentScore < scoreToBeat) {\n                scoreToBeat = currentScore;\n                bestMoment = tempConfig;\n            }\n        }\n\n        extend(config, bestMoment || tempConfig);\n    }\n\n    function configFromObject(config) {\n        if (config._d) {\n            return;\n        }\n\n        var i = normalizeObjectUnits(config._i);\n        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];\n\n        configFromArray(config);\n    }\n\n    function createFromConfig (config) {\n        var res = new Moment(checkOverflow(prepareConfig(config)));\n        if (res._nextDay) {\n            // Adding is smart enough around DST\n            res.add(1, 'd');\n            res._nextDay = undefined;\n        }\n\n        return res;\n    }\n\n    function prepareConfig (config) {\n        var input = config._i,\n            format = config._f;\n\n        config._locale = config._locale || locale_locales__getLocale(config._l);\n\n        if (input === null || (format === undefined && input === '')) {\n            return valid__createInvalid({nullInput: true});\n        }\n\n        if (typeof input === 'string') {\n            config._i = input = config._locale.preparse(input);\n        }\n\n        if (isMoment(input)) {\n            return new Moment(checkOverflow(input));\n        } else if (isArray(format)) {\n            configFromStringAndArray(config);\n        } else if (format) {\n            configFromStringAndFormat(config);\n        } else if (isDate(input)) {\n            config._d = input;\n        } else {\n            configFromInput(config);\n        }\n\n        return config;\n    }\n\n    function configFromInput(config) {\n        var input = config._i;\n        if (input === undefined) {\n            config._d = new Date();\n        } else if (isDate(input)) {\n            config._d = new Date(+input);\n        } else if (typeof input === 'string') {\n            configFromString(config);\n        } else if (isArray(input)) {\n            config._a = map(input.slice(0), function (obj) {\n                return parseInt(obj, 10);\n            });\n            configFromArray(config);\n        } else if (typeof(input) === 'object') {\n            configFromObject(config);\n        } else if (typeof(input) === 'number') {\n            // from milliseconds\n            config._d = new Date(input);\n        } else {\n            utils_hooks__hooks.createFromInputFallback(config);\n        }\n    }\n\n    function createLocalOrUTC (input, format, locale, strict, isUTC) {\n        var c = {};\n\n        if (typeof(locale) === 'boolean') {\n            strict = locale;\n            locale = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c._isAMomentObject = true;\n        c._useUTC = c._isUTC = isUTC;\n        c._l = locale;\n        c._i = input;\n        c._f = format;\n        c._strict = strict;\n\n        return createFromConfig(c);\n    }\n\n    function local__createLocal (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, false);\n    }\n\n    var prototypeMin = deprecate(\n         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',\n         function () {\n             var other = local__createLocal.apply(null, arguments);\n             return other < this ? this : other;\n         }\n     );\n\n    var prototypeMax = deprecate(\n        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',\n        function () {\n            var other = local__createLocal.apply(null, arguments);\n            return other > this ? this : other;\n        }\n    );\n\n    // Pick a moment m from moments so that m[fn](other) is true for all\n    // other. This relies on the function fn to be transitive.\n    //\n    // moments should either be an array of moment objects or an array, whose\n    // first element is an array of moment objects.\n    function pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if (!moments.length) {\n            return local__createLocal();\n        }\n        res = moments[0];\n        for (i = 1; i < moments.length; ++i) {\n            if (!moments[i].isValid() || moments[i][fn](res)) {\n                res = moments[i];\n            }\n        }\n        return res;\n    }\n\n    // TODO: Use [].sort instead?\n    function min () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isBefore', args);\n    }\n\n    function max () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isAfter', args);\n    }\n\n    function Duration (duration) {\n        var normalizedInput = normalizeObjectUnits(duration),\n            years = normalizedInput.year || 0,\n            quarters = normalizedInput.quarter || 0,\n            months = normalizedInput.month || 0,\n            weeks = normalizedInput.week || 0,\n            days = normalizedInput.day || 0,\n            hours = normalizedInput.hour || 0,\n            minutes = normalizedInput.minute || 0,\n            seconds = normalizedInput.second || 0,\n            milliseconds = normalizedInput.millisecond || 0;\n\n        // representation for dateAddRemove\n        this._milliseconds = +milliseconds +\n            seconds * 1e3 + // 1000\n            minutes * 6e4 + // 1000 * 60\n            hours * 36e5; // 1000 * 60 * 60\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = +days +\n            weeks * 7;\n        // It is impossible translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = +months +\n            quarters * 3 +\n            years * 12;\n\n        this._data = {};\n\n        this._locale = locale_locales__getLocale();\n\n        this._bubble();\n    }\n\n    function isDuration (obj) {\n        return obj instanceof Duration;\n    }\n\n    function offset (token, separator) {\n        addFormatToken(token, 0, 0, function () {\n            var offset = this.utcOffset();\n            var sign = '+';\n            if (offset < 0) {\n                offset = -offset;\n                sign = '-';\n            }\n            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\n        });\n    }\n\n    offset('Z', ':');\n    offset('ZZ', '');\n\n    // PARSING\n\n    addRegexToken('Z',  matchOffset);\n    addRegexToken('ZZ', matchOffset);\n    addParseToken(['Z', 'ZZ'], function (input, array, config) {\n        config._useUTC = true;\n        config._tzm = offsetFromString(input);\n    });\n\n    // HELPERS\n\n    // timezone chunker\n    // '+10:00' > ['10',  '00']\n    // '-1530'  > ['-15', '30']\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\n    function offsetFromString(string) {\n        var matches = ((string || '').match(matchOffset) || []);\n        var chunk   = matches[matches.length - 1] || [];\n        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n        var minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n        return parts[0] === '+' ? minutes : -minutes;\n    }\n\n    // Return a moment from input, that is local/utc/zone equivalent to model.\n    function cloneWithOffset(input, model) {\n        var res, diff;\n        if (model._isUTC) {\n            res = model.clone();\n            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);\n            // Use low-level api, because this fn is low-level api.\n            res._d.setTime(+res._d + diff);\n            utils_hooks__hooks.updateOffset(res, false);\n            return res;\n        } else {\n            return local__createLocal(input).local();\n        }\n    }\n\n    function getDateOffset (m) {\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n        // https://github.com/moment/moment/pull/1871\n        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n    }\n\n    // HOOKS\n\n    // This function will be called whenever a moment is mutated.\n    // It is intended to keep the offset in sync with the timezone.\n    utils_hooks__hooks.updateOffset = function () {};\n\n    // MOMENTS\n\n    // keepLocalTime = true means only change the timezone, without\n    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n    // +0200, so we adjust the time as needed, to be valid.\n    //\n    // Keeping the time actually adds/subtracts (one hour)\n    // from the actual represented time. That is why we call updateOffset\n    // a second time. In case it wants us to change the offset again\n    // _changeInProgress == true case, then we have to adjust, because\n    // there is no such time in the given timezone.\n    function getSetOffset (input, keepLocalTime) {\n        var offset = this._offset || 0,\n            localAdjust;\n        if (input != null) {\n            if (typeof input === 'string') {\n                input = offsetFromString(input);\n            }\n            if (Math.abs(input) < 16) {\n                input = input * 60;\n            }\n            if (!this._isUTC && keepLocalTime) {\n                localAdjust = getDateOffset(this);\n            }\n            this._offset = input;\n            this._isUTC = true;\n            if (localAdjust != null) {\n                this.add(localAdjust, 'm');\n            }\n            if (offset !== input) {\n                if (!keepLocalTime || this._changeInProgress) {\n                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);\n                } else if (!this._changeInProgress) {\n                    this._changeInProgress = true;\n                    utils_hooks__hooks.updateOffset(this, true);\n                    this._changeInProgress = null;\n                }\n            }\n            return this;\n        } else {\n            return this._isUTC ? offset : getDateOffset(this);\n        }\n    }\n\n    function getSetZone (input, keepLocalTime) {\n        if (input != null) {\n            if (typeof input !== 'string') {\n                input = -input;\n            }\n\n            this.utcOffset(input, keepLocalTime);\n\n            return this;\n        } else {\n            return -this.utcOffset();\n        }\n    }\n\n    function setOffsetToUTC (keepLocalTime) {\n        return this.utcOffset(0, keepLocalTime);\n    }\n\n    function setOffsetToLocal (keepLocalTime) {\n        if (this._isUTC) {\n            this.utcOffset(0, keepLocalTime);\n            this._isUTC = false;\n\n            if (keepLocalTime) {\n                this.subtract(getDateOffset(this), 'm');\n            }\n        }\n        return this;\n    }\n\n    function setOffsetToParsedOffset () {\n        if (this._tzm) {\n            this.utcOffset(this._tzm);\n        } else if (typeof this._i === 'string') {\n            this.utcOffset(offsetFromString(this._i));\n        }\n        return this;\n    }\n\n    function hasAlignedHourOffset (input) {\n        input = input ? local__createLocal(input).utcOffset() : 0;\n\n        return (this.utcOffset() - input) % 60 === 0;\n    }\n\n    function isDaylightSavingTime () {\n        return (\n            this.utcOffset() > this.clone().month(0).utcOffset() ||\n            this.utcOffset() > this.clone().month(5).utcOffset()\n        );\n    }\n\n    function isDaylightSavingTimeShifted () {\n        if (typeof this._isDSTShifted !== 'undefined') {\n            return this._isDSTShifted;\n        }\n\n        var c = {};\n\n        copyConfig(c, this);\n        c = prepareConfig(c);\n\n        if (c._a) {\n            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);\n            this._isDSTShifted = this.isValid() &&\n                compareArrays(c._a, other.toArray()) > 0;\n        } else {\n            this._isDSTShifted = false;\n        }\n\n        return this._isDSTShifted;\n    }\n\n    function isLocal () {\n        return !this._isUTC;\n    }\n\n    function isUtcOffset () {\n        return this._isUTC;\n    }\n\n    function isUtc () {\n        return this._isUTC && this._offset === 0;\n    }\n\n    var aspNetRegex = /(\\-)?(?:(\\d*)\\.)?(\\d+)\\:(\\d+)(?:\\:(\\d+)\\.?(\\d{3})?)?/;\n\n    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;\n\n    function create__createDuration (input, key) {\n        var duration = input,\n            // matching against regexp is expensive, do it on demand\n            match = null,\n            sign,\n            ret,\n            diffRes;\n\n        if (isDuration(input)) {\n            duration = {\n                ms : input._milliseconds,\n                d  : input._days,\n                M  : input._months\n            };\n        } else if (typeof input === 'number') {\n            duration = {};\n            if (key) {\n                duration[key] = input;\n            } else {\n                duration.milliseconds = input;\n            }\n        } else if (!!(match = aspNetRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : 1;\n            duration = {\n                y  : 0,\n                d  : toInt(match[DATE])        * sign,\n                h  : toInt(match[HOUR])        * sign,\n                m  : toInt(match[MINUTE])      * sign,\n                s  : toInt(match[SECOND])      * sign,\n                ms : toInt(match[MILLISECOND]) * sign\n            };\n        } else if (!!(match = create__isoRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : 1;\n            duration = {\n                y : parseIso(match[2], sign),\n                M : parseIso(match[3], sign),\n                d : parseIso(match[4], sign),\n                h : parseIso(match[5], sign),\n                m : parseIso(match[6], sign),\n                s : parseIso(match[7], sign),\n                w : parseIso(match[8], sign)\n            };\n        } else if (duration == null) {// checks for null or undefined\n            duration = {};\n        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));\n\n            duration = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M = diffRes.months;\n        }\n\n        ret = new Duration(duration);\n\n        if (isDuration(input) && hasOwnProp(input, '_locale')) {\n            ret._locale = input._locale;\n        }\n\n        return ret;\n    }\n\n    create__createDuration.fn = Duration.prototype;\n\n    function parseIso (inp, sign) {\n        // We'd normally use ~~inp for this, but unfortunately it also\n        // converts floats to ints.\n        // inp may be undefined, so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(',', '.'));\n        // apply sign while we're at it\n        return (isNaN(res) ? 0 : res) * sign;\n    }\n\n    function positiveMomentsDifference(base, other) {\n        var res = {milliseconds: 0, months: 0};\n\n        res.months = other.month() - base.month() +\n            (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months, 'M').isAfter(other)) {\n            --res.months;\n        }\n\n        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\n        return res;\n    }\n\n    function momentsDifference(base, other) {\n        var res;\n        other = cloneWithOffset(other, base);\n        if (base.isBefore(other)) {\n            res = positiveMomentsDifference(base, other);\n        } else {\n            res = positiveMomentsDifference(other, base);\n            res.milliseconds = -res.milliseconds;\n            res.months = -res.months;\n        }\n\n        return res;\n    }\n\n    function createAdder(direction, name) {\n        return function (val, period) {\n            var dur, tmp;\n            //invert the arguments, but complain about it\n            if (period !== null && !isNaN(+period)) {\n                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');\n                tmp = val; val = period; period = tmp;\n            }\n\n            val = typeof val === 'string' ? +val : val;\n            dur = create__createDuration(val, period);\n            add_subtract__addSubtract(this, dur, direction);\n            return this;\n        };\n    }\n\n    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {\n        var milliseconds = duration._milliseconds,\n            days = duration._days,\n            months = duration._months;\n        updateOffset = updateOffset == null ? true : updateOffset;\n\n        if (milliseconds) {\n            mom._d.setTime(+mom._d + milliseconds * isAdding);\n        }\n        if (days) {\n            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);\n        }\n        if (months) {\n            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);\n        }\n        if (updateOffset) {\n            utils_hooks__hooks.updateOffset(mom, days || months);\n        }\n    }\n\n    var add_subtract__add      = createAdder(1, 'add');\n    var add_subtract__subtract = createAdder(-1, 'subtract');\n\n    function moment_calendar__calendar (time, formats) {\n        // We want to compare the start of today, vs this.\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\n        var now = time || local__createLocal(),\n            sod = cloneWithOffset(now, this).startOf('day'),\n            diff = this.diff(sod, 'days', true),\n            format = diff < -6 ? 'sameElse' :\n                diff < -1 ? 'lastWeek' :\n                diff < 0 ? 'lastDay' :\n                diff < 1 ? 'sameDay' :\n                diff < 2 ? 'nextDay' :\n                diff < 7 ? 'nextWeek' : 'sameElse';\n        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));\n    }\n\n    function clone () {\n        return new Moment(this);\n    }\n\n    function isAfter (input, units) {\n        var inputMs;\n        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');\n        if (units === 'millisecond') {\n            input = isMoment(input) ? input : local__createLocal(input);\n            return +this > +input;\n        } else {\n            inputMs = isMoment(input) ? +input : +local__createLocal(input);\n            return inputMs < +this.clone().startOf(units);\n        }\n    }\n\n    function isBefore (input, units) {\n        var inputMs;\n        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');\n        if (units === 'millisecond') {\n            input = isMoment(input) ? input : local__createLocal(input);\n            return +this < +input;\n        } else {\n            inputMs = isMoment(input) ? +input : +local__createLocal(input);\n            return +this.clone().endOf(units) < inputMs;\n        }\n    }\n\n    function isBetween (from, to, units) {\n        return this.isAfter(from, units) && this.isBefore(to, units);\n    }\n\n    function isSame (input, units) {\n        var inputMs;\n        units = normalizeUnits(units || 'millisecond');\n        if (units === 'millisecond') {\n            input = isMoment(input) ? input : local__createLocal(input);\n            return +this === +input;\n        } else {\n            inputMs = +local__createLocal(input);\n            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));\n        }\n    }\n\n    function diff (input, units, asFloat) {\n        var that = cloneWithOffset(input, this),\n            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,\n            delta, output;\n\n        units = normalizeUnits(units);\n\n        if (units === 'year' || units === 'month' || units === 'quarter') {\n            output = monthDiff(this, that);\n            if (units === 'quarter') {\n                output = output / 3;\n            } else if (units === 'year') {\n                output = output / 12;\n            }\n        } else {\n            delta = this - that;\n            output = units === 'second' ? delta / 1e3 : // 1000\n                units === 'minute' ? delta / 6e4 : // 1000 * 60\n                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60\n                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst\n                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst\n                delta;\n        }\n        return asFloat ? output : absFloor(output);\n    }\n\n    function monthDiff (a, b) {\n        // difference in months\n        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n            // b is in (anchor - 1 month, anchor + 1 month)\n            anchor = a.clone().add(wholeMonthDiff, 'months'),\n            anchor2, adjust;\n\n        if (b - anchor < 0) {\n            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n        }\n\n        return -(wholeMonthDiff + adjust);\n    }\n\n    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n\n    function toString () {\n        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n    }\n\n    function moment_format__toISOString () {\n        var m = this.clone().utc();\n        if (0 < m.year() && m.year() <= 9999) {\n            if ('function' === typeof Date.prototype.toISOString) {\n                // native implementation is ~50x faster, use it when we can\n                return this.toDate().toISOString();\n            } else {\n                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n            }\n        } else {\n            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n        }\n    }\n\n    function moment_format__format (inputString) {\n        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);\n        return this.localeData().postformat(output);\n    }\n\n    function from (time, withoutSuffix) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n        return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n    }\n\n    function fromNow (withoutSuffix) {\n        return this.from(local__createLocal(), withoutSuffix);\n    }\n\n    function to (time, withoutSuffix) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n        return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n    }\n\n    function toNow (withoutSuffix) {\n        return this.to(local__createLocal(), withoutSuffix);\n    }\n\n    function locale (key) {\n        var newLocaleData;\n\n        if (key === undefined) {\n            return this._locale._abbr;\n        } else {\n            newLocaleData = locale_locales__getLocale(key);\n            if (newLocaleData != null) {\n                this._locale = newLocaleData;\n            }\n            return this;\n        }\n    }\n\n    var lang = deprecate(\n        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n        function (key) {\n            if (key === undefined) {\n                return this.localeData();\n            } else {\n                return this.locale(key);\n            }\n        }\n    );\n\n    function localeData () {\n        return this._locale;\n    }\n\n    function startOf (units) {\n        units = normalizeUnits(units);\n        // the following switch intentionally omits break keywords\n        // to utilize falling through the cases.\n        switch (units) {\n        case 'year':\n            this.month(0);\n            /* falls through */\n        case 'quarter':\n        case 'month':\n            this.date(1);\n            /* falls through */\n        case 'week':\n        case 'isoWeek':\n        case 'day':\n            this.hours(0);\n            /* falls through */\n        case 'hour':\n            this.minutes(0);\n            /* falls through */\n        case 'minute':\n            this.seconds(0);\n            /* falls through */\n        case 'second':\n            this.milliseconds(0);\n        }\n\n        // weeks are a special case\n        if (units === 'week') {\n            this.weekday(0);\n        }\n        if (units === 'isoWeek') {\n            this.isoWeekday(1);\n        }\n\n        // quarters are also special\n        if (units === 'quarter') {\n            this.month(Math.floor(this.month() / 3) * 3);\n        }\n\n        return this;\n    }\n\n    function endOf (units) {\n        units = normalizeUnits(units);\n        if (units === undefined || units === 'millisecond') {\n            return this;\n        }\n        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\n    }\n\n    function to_type__valueOf () {\n        return +this._d - ((this._offset || 0) * 60000);\n    }\n\n    function unix () {\n        return Math.floor(+this / 1000);\n    }\n\n    function toDate () {\n        return this._offset ? new Date(+this) : this._d;\n    }\n\n    function toArray () {\n        var m = this;\n        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n    }\n\n    function toObject () {\n        var m = this;\n        return {\n            years: m.year(),\n            months: m.month(),\n            date: m.date(),\n            hours: m.hours(),\n            minutes: m.minutes(),\n            seconds: m.seconds(),\n            milliseconds: m.milliseconds()\n        };\n    }\n\n    function moment_valid__isValid () {\n        return valid__isValid(this);\n    }\n\n    function parsingFlags () {\n        return extend({}, getParsingFlags(this));\n    }\n\n    function invalidAt () {\n        return getParsingFlags(this).overflow;\n    }\n\n    addFormatToken(0, ['gg', 2], 0, function () {\n        return this.weekYear() % 100;\n    });\n\n    addFormatToken(0, ['GG', 2], 0, function () {\n        return this.isoWeekYear() % 100;\n    });\n\n    function addWeekYearFormatToken (token, getter) {\n        addFormatToken(0, [token, token.length], 0, getter);\n    }\n\n    addWeekYearFormatToken('gggg',     'weekYear');\n    addWeekYearFormatToken('ggggg',    'weekYear');\n    addWeekYearFormatToken('GGGG',  'isoWeekYear');\n    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n    // ALIASES\n\n    addUnitAlias('weekYear', 'gg');\n    addUnitAlias('isoWeekYear', 'GG');\n\n    // PARSING\n\n    addRegexToken('G',      matchSigned);\n    addRegexToken('g',      matchSigned);\n    addRegexToken('GG',     match1to2, match2);\n    addRegexToken('gg',     match1to2, match2);\n    addRegexToken('GGGG',   match1to4, match4);\n    addRegexToken('gggg',   match1to4, match4);\n    addRegexToken('GGGGG',  match1to6, match6);\n    addRegexToken('ggggg',  match1to6, match6);\n\n    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n        week[token.substr(0, 2)] = toInt(input);\n    });\n\n    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);\n    });\n\n    // HELPERS\n\n    function weeksInYear(year, dow, doy) {\n        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;\n    }\n\n    // MOMENTS\n\n    function getSetWeekYear (input) {\n        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;\n        return input == null ? year : this.add((input - year), 'y');\n    }\n\n    function getSetISOWeekYear (input) {\n        var year = weekOfYear(this, 1, 4).year;\n        return input == null ? year : this.add((input - year), 'y');\n    }\n\n    function getISOWeeksInYear () {\n        return weeksInYear(this.year(), 1, 4);\n    }\n\n    function getWeeksInYear () {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n    }\n\n    addFormatToken('Q', 0, 0, 'quarter');\n\n    // ALIASES\n\n    addUnitAlias('quarter', 'Q');\n\n    // PARSING\n\n    addRegexToken('Q', match1);\n    addParseToken('Q', function (input, array) {\n        array[MONTH] = (toInt(input) - 1) * 3;\n    });\n\n    // MOMENTS\n\n    function getSetQuarter (input) {\n        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n    }\n\n    addFormatToken('D', ['DD', 2], 'Do', 'date');\n\n    // ALIASES\n\n    addUnitAlias('date', 'D');\n\n    // PARSING\n\n    addRegexToken('D',  match1to2);\n    addRegexToken('DD', match1to2, match2);\n    addRegexToken('Do', function (isStrict, locale) {\n        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;\n    });\n\n    addParseToken(['D', 'DD'], DATE);\n    addParseToken('Do', function (input, array) {\n        array[DATE] = toInt(input.match(match1to2)[0], 10);\n    });\n\n    // MOMENTS\n\n    var getSetDayOfMonth = makeGetSet('Date', true);\n\n    addFormatToken('d', 0, 'do', 'day');\n\n    addFormatToken('dd', 0, 0, function (format) {\n        return this.localeData().weekdaysMin(this, format);\n    });\n\n    addFormatToken('ddd', 0, 0, function (format) {\n        return this.localeData().weekdaysShort(this, format);\n    });\n\n    addFormatToken('dddd', 0, 0, function (format) {\n        return this.localeData().weekdays(this, format);\n    });\n\n    addFormatToken('e', 0, 0, 'weekday');\n    addFormatToken('E', 0, 0, 'isoWeekday');\n\n    // ALIASES\n\n    addUnitAlias('day', 'd');\n    addUnitAlias('weekday', 'e');\n    addUnitAlias('isoWeekday', 'E');\n\n    // PARSING\n\n    addRegexToken('d',    match1to2);\n    addRegexToken('e',    match1to2);\n    addRegexToken('E',    match1to2);\n    addRegexToken('dd',   matchWord);\n    addRegexToken('ddd',  matchWord);\n    addRegexToken('dddd', matchWord);\n\n    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {\n        var weekday = config._locale.weekdaysParse(input);\n        // if we didn't get a weekday name, mark the date as invalid\n        if (weekday != null) {\n            week.d = weekday;\n        } else {\n            getParsingFlags(config).invalidWeekday = input;\n        }\n    });\n\n    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n        week[token] = toInt(input);\n    });\n\n    // HELPERS\n\n    function parseWeekday(input, locale) {\n        if (typeof input !== 'string') {\n            return input;\n        }\n\n        if (!isNaN(input)) {\n            return parseInt(input, 10);\n        }\n\n        input = locale.weekdaysParse(input);\n        if (typeof input === 'number') {\n            return input;\n        }\n\n        return null;\n    }\n\n    // LOCALES\n\n    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\n    function localeWeekdays (m) {\n        return this._weekdays[m.day()];\n    }\n\n    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\n    function localeWeekdaysShort (m) {\n        return this._weekdaysShort[m.day()];\n    }\n\n    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\n    function localeWeekdaysMin (m) {\n        return this._weekdaysMin[m.day()];\n    }\n\n    function localeWeekdaysParse (weekdayName) {\n        var i, mom, regex;\n\n        this._weekdaysParse = this._weekdaysParse || [];\n\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n            if (!this._weekdaysParse[i]) {\n                mom = local__createLocal([2000, 1]).day(i);\n                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (this._weekdaysParse[i].test(weekdayName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function getSetDayOfWeek (input) {\n        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n        if (input != null) {\n            input = parseWeekday(input, this.localeData());\n            return this.add(input - day, 'd');\n        } else {\n            return day;\n        }\n    }\n\n    function getSetLocaleDayOfWeek (input) {\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n        return input == null ? weekday : this.add(input - weekday, 'd');\n    }\n\n    function getSetISODayOfWeek (input) {\n        // behaves the same as moment#day except\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n        // as a setter, sunday should belong to the previous week.\n        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);\n    }\n\n    addFormatToken('H', ['HH', 2], 0, 'hour');\n    addFormatToken('h', ['hh', 2], 0, function () {\n        return this.hours() % 12 || 12;\n    });\n\n    function meridiem (token, lowercase) {\n        addFormatToken(token, 0, 0, function () {\n            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n        });\n    }\n\n    meridiem('a', true);\n    meridiem('A', false);\n\n    // ALIASES\n\n    addUnitAlias('hour', 'h');\n\n    // PARSING\n\n    function matchMeridiem (isStrict, locale) {\n        return locale._meridiemParse;\n    }\n\n    addRegexToken('a',  matchMeridiem);\n    addRegexToken('A',  matchMeridiem);\n    addRegexToken('H',  match1to2);\n    addRegexToken('h',  match1to2);\n    addRegexToken('HH', match1to2, match2);\n    addRegexToken('hh', match1to2, match2);\n\n    addParseToken(['H', 'HH'], HOUR);\n    addParseToken(['a', 'A'], function (input, array, config) {\n        config._isPm = config._locale.isPM(input);\n        config._meridiem = input;\n    });\n    addParseToken(['h', 'hh'], function (input, array, config) {\n        array[HOUR] = toInt(input);\n        getParsingFlags(config).bigHour = true;\n    });\n\n    // LOCALES\n\n    function localeIsPM (input) {\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n        // Using charAt should be more compatible.\n        return ((input + '').toLowerCase().charAt(0) === 'p');\n    }\n\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\n    function localeMeridiem (hours, minutes, isLower) {\n        if (hours > 11) {\n            return isLower ? 'pm' : 'PM';\n        } else {\n            return isLower ? 'am' : 'AM';\n        }\n    }\n\n\n    // MOMENTS\n\n    // Setting the hour should keep the time, because the user explicitly\n    // specified which hour he wants. So trying to maintain the same hour (in\n    // a new timezone) makes sense. Adding/subtracting hours does not follow\n    // this rule.\n    var getSetHour = makeGetSet('Hours', true);\n\n    addFormatToken('m', ['mm', 2], 0, 'minute');\n\n    // ALIASES\n\n    addUnitAlias('minute', 'm');\n\n    // PARSING\n\n    addRegexToken('m',  match1to2);\n    addRegexToken('mm', match1to2, match2);\n    addParseToken(['m', 'mm'], MINUTE);\n\n    // MOMENTS\n\n    var getSetMinute = makeGetSet('Minutes', false);\n\n    addFormatToken('s', ['ss', 2], 0, 'second');\n\n    // ALIASES\n\n    addUnitAlias('second', 's');\n\n    // PARSING\n\n    addRegexToken('s',  match1to2);\n    addRegexToken('ss', match1to2, match2);\n    addParseToken(['s', 'ss'], SECOND);\n\n    // MOMENTS\n\n    var getSetSecond = makeGetSet('Seconds', false);\n\n    addFormatToken('S', 0, 0, function () {\n        return ~~(this.millisecond() / 100);\n    });\n\n    addFormatToken(0, ['SS', 2], 0, function () {\n        return ~~(this.millisecond() / 10);\n    });\n\n    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n    addFormatToken(0, ['SSSS', 4], 0, function () {\n        return this.millisecond() * 10;\n    });\n    addFormatToken(0, ['SSSSS', 5], 0, function () {\n        return this.millisecond() * 100;\n    });\n    addFormatToken(0, ['SSSSSS', 6], 0, function () {\n        return this.millisecond() * 1000;\n    });\n    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n        return this.millisecond() * 10000;\n    });\n    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n        return this.millisecond() * 100000;\n    });\n    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n        return this.millisecond() * 1000000;\n    });\n\n\n    // ALIASES\n\n    addUnitAlias('millisecond', 'ms');\n\n    // PARSING\n\n    addRegexToken('S',    match1to3, match1);\n    addRegexToken('SS',   match1to3, match2);\n    addRegexToken('SSS',  match1to3, match3);\n\n    var token;\n    for (token = 'SSSS'; token.length <= 9; token += 'S') {\n        addRegexToken(token, matchUnsigned);\n    }\n\n    function parseMs(input, array) {\n        array[MILLISECOND] = toInt(('0.' + input) * 1000);\n    }\n\n    for (token = 'S'; token.length <= 9; token += 'S') {\n        addParseToken(token, parseMs);\n    }\n    // MOMENTS\n\n    var getSetMillisecond = makeGetSet('Milliseconds', false);\n\n    addFormatToken('z',  0, 0, 'zoneAbbr');\n    addFormatToken('zz', 0, 0, 'zoneName');\n\n    // MOMENTS\n\n    function getZoneAbbr () {\n        return this._isUTC ? 'UTC' : '';\n    }\n\n    function getZoneName () {\n        return this._isUTC ? 'Coordinated Universal Time' : '';\n    }\n\n    var momentPrototype__proto = Moment.prototype;\n\n    momentPrototype__proto.add          = add_subtract__add;\n    momentPrototype__proto.calendar     = moment_calendar__calendar;\n    momentPrototype__proto.clone        = clone;\n    momentPrototype__proto.diff         = diff;\n    momentPrototype__proto.endOf        = endOf;\n    momentPrototype__proto.format       = moment_format__format;\n    momentPrototype__proto.from         = from;\n    momentPrototype__proto.fromNow      = fromNow;\n    momentPrototype__proto.to           = to;\n    momentPrototype__proto.toNow        = toNow;\n    momentPrototype__proto.get          = getSet;\n    momentPrototype__proto.invalidAt    = invalidAt;\n    momentPrototype__proto.isAfter      = isAfter;\n    momentPrototype__proto.isBefore     = isBefore;\n    momentPrototype__proto.isBetween    = isBetween;\n    momentPrototype__proto.isSame       = isSame;\n    momentPrototype__proto.isValid      = moment_valid__isValid;\n    momentPrototype__proto.lang         = lang;\n    momentPrototype__proto.locale       = locale;\n    momentPrototype__proto.localeData   = localeData;\n    momentPrototype__proto.max          = prototypeMax;\n    momentPrototype__proto.min          = prototypeMin;\n    momentPrototype__proto.parsingFlags = parsingFlags;\n    momentPrototype__proto.set          = getSet;\n    momentPrototype__proto.startOf      = startOf;\n    momentPrototype__proto.subtract     = add_subtract__subtract;\n    momentPrototype__proto.toArray      = toArray;\n    momentPrototype__proto.toObject     = toObject;\n    momentPrototype__proto.toDate       = toDate;\n    momentPrototype__proto.toISOString  = moment_format__toISOString;\n    momentPrototype__proto.toJSON       = moment_format__toISOString;\n    momentPrototype__proto.toString     = toString;\n    momentPrototype__proto.unix         = unix;\n    momentPrototype__proto.valueOf      = to_type__valueOf;\n\n    // Year\n    momentPrototype__proto.year       = getSetYear;\n    momentPrototype__proto.isLeapYear = getIsLeapYear;\n\n    // Week Year\n    momentPrototype__proto.weekYear    = getSetWeekYear;\n    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;\n\n    // Quarter\n    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;\n\n    // Month\n    momentPrototype__proto.month       = getSetMonth;\n    momentPrototype__proto.daysInMonth = getDaysInMonth;\n\n    // Week\n    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;\n    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;\n    momentPrototype__proto.weeksInYear    = getWeeksInYear;\n    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;\n\n    // Day\n    momentPrototype__proto.date       = getSetDayOfMonth;\n    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;\n    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;\n    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;\n    momentPrototype__proto.dayOfYear  = getSetDayOfYear;\n\n    // Hour\n    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;\n\n    // Minute\n    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;\n\n    // Second\n    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;\n\n    // Millisecond\n    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;\n\n    // Offset\n    momentPrototype__proto.utcOffset            = getSetOffset;\n    momentPrototype__proto.utc                  = setOffsetToUTC;\n    momentPrototype__proto.local                = setOffsetToLocal;\n    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;\n    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;\n    momentPrototype__proto.isDST                = isDaylightSavingTime;\n    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;\n    momentPrototype__proto.isLocal              = isLocal;\n    momentPrototype__proto.isUtcOffset          = isUtcOffset;\n    momentPrototype__proto.isUtc                = isUtc;\n    momentPrototype__proto.isUTC                = isUtc;\n\n    // Timezone\n    momentPrototype__proto.zoneAbbr = getZoneAbbr;\n    momentPrototype__proto.zoneName = getZoneName;\n\n    // Deprecations\n    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\n    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\n    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\n    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);\n\n    var momentPrototype = momentPrototype__proto;\n\n    function moment_moment__createUnix (input) {\n        return local__createLocal(input * 1000);\n    }\n\n    function moment_moment__createInZone () {\n        return local__createLocal.apply(null, arguments).parseZone();\n    }\n\n    var defaultCalendar = {\n        sameDay : '[Today at] LT',\n        nextDay : '[Tomorrow at] LT',\n        nextWeek : 'dddd [at] LT',\n        lastDay : '[Yesterday at] LT',\n        lastWeek : '[Last] dddd [at] LT',\n        sameElse : 'L'\n    };\n\n    function locale_calendar__calendar (key, mom, now) {\n        var output = this._calendar[key];\n        return typeof output === 'function' ? output.call(mom, now) : output;\n    }\n\n    var defaultLongDateFormat = {\n        LTS  : 'h:mm:ss A',\n        LT   : 'h:mm A',\n        L    : 'MM/DD/YYYY',\n        LL   : 'MMMM D, YYYY',\n        LLL  : 'MMMM D, YYYY h:mm A',\n        LLLL : 'dddd, MMMM D, YYYY h:mm A'\n    };\n\n    function longDateFormat (key) {\n        var format = this._longDateFormat[key],\n            formatUpper = this._longDateFormat[key.toUpperCase()];\n\n        if (format || !formatUpper) {\n            return format;\n        }\n\n        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\n            return val.slice(1);\n        });\n\n        return this._longDateFormat[key];\n    }\n\n    var defaultInvalidDate = 'Invalid date';\n\n    function invalidDate () {\n        return this._invalidDate;\n    }\n\n    var defaultOrdinal = '%d';\n    var defaultOrdinalParse = /\\d{1,2}/;\n\n    function ordinal (number) {\n        return this._ordinal.replace('%d', number);\n    }\n\n    function preParsePostFormat (string) {\n        return string;\n    }\n\n    var defaultRelativeTime = {\n        future : 'in %s',\n        past   : '%s ago',\n        s  : 'a few seconds',\n        m  : 'a minute',\n        mm : '%d minutes',\n        h  : 'an hour',\n        hh : '%d hours',\n        d  : 'a day',\n        dd : '%d days',\n        M  : 'a month',\n        MM : '%d months',\n        y  : 'a year',\n        yy : '%d years'\n    };\n\n    function relative__relativeTime (number, withoutSuffix, string, isFuture) {\n        var output = this._relativeTime[string];\n        return (typeof output === 'function') ?\n            output(number, withoutSuffix, string, isFuture) :\n            output.replace(/%d/i, number);\n    }\n\n    function pastFuture (diff, output) {\n        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);\n    }\n\n    function locale_set__set (config) {\n        var prop, i;\n        for (i in config) {\n            prop = config[i];\n            if (typeof prop === 'function') {\n                this[i] = prop;\n            } else {\n                this['_' + i] = prop;\n            }\n        }\n        // Lenient ordinal parsing accepts just a number in addition to\n        // number + (possibly) stuff coming from _ordinalParseLenient.\n        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\\d{1,2}/).source);\n    }\n\n    var prototype__proto = Locale.prototype;\n\n    prototype__proto._calendar       = defaultCalendar;\n    prototype__proto.calendar        = locale_calendar__calendar;\n    prototype__proto._longDateFormat = defaultLongDateFormat;\n    prototype__proto.longDateFormat  = longDateFormat;\n    prototype__proto._invalidDate    = defaultInvalidDate;\n    prototype__proto.invalidDate     = invalidDate;\n    prototype__proto._ordinal        = defaultOrdinal;\n    prototype__proto.ordinal         = ordinal;\n    prototype__proto._ordinalParse   = defaultOrdinalParse;\n    prototype__proto.preparse        = preParsePostFormat;\n    prototype__proto.postformat      = preParsePostFormat;\n    prototype__proto._relativeTime   = defaultRelativeTime;\n    prototype__proto.relativeTime    = relative__relativeTime;\n    prototype__proto.pastFuture      = pastFuture;\n    prototype__proto.set             = locale_set__set;\n\n    // Month\n    prototype__proto.months       =        localeMonths;\n    prototype__proto._months      = defaultLocaleMonths;\n    prototype__proto.monthsShort  =        localeMonthsShort;\n    prototype__proto._monthsShort = defaultLocaleMonthsShort;\n    prototype__proto.monthsParse  =        localeMonthsParse;\n\n    // Week\n    prototype__proto.week = localeWeek;\n    prototype__proto._week = defaultLocaleWeek;\n    prototype__proto.firstDayOfYear = localeFirstDayOfYear;\n    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;\n\n    // Day of Week\n    prototype__proto.weekdays       =        localeWeekdays;\n    prototype__proto._weekdays      = defaultLocaleWeekdays;\n    prototype__proto.weekdaysMin    =        localeWeekdaysMin;\n    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;\n    prototype__proto.weekdaysShort  =        localeWeekdaysShort;\n    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;\n    prototype__proto.weekdaysParse  =        localeWeekdaysParse;\n\n    // Hours\n    prototype__proto.isPM = localeIsPM;\n    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;\n    prototype__proto.meridiem = localeMeridiem;\n\n    function lists__get (format, index, field, setter) {\n        var locale = locale_locales__getLocale();\n        var utc = create_utc__createUTC().set(setter, index);\n        return locale[field](utc, format);\n    }\n\n    function list (format, index, field, count, setter) {\n        if (typeof format === 'number') {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n\n        if (index != null) {\n            return lists__get(format, index, field, setter);\n        }\n\n        var i;\n        var out = [];\n        for (i = 0; i < count; i++) {\n            out[i] = lists__get(format, i, field, setter);\n        }\n        return out;\n    }\n\n    function lists__listMonths (format, index) {\n        return list(format, index, 'months', 12, 'month');\n    }\n\n    function lists__listMonthsShort (format, index) {\n        return list(format, index, 'monthsShort', 12, 'month');\n    }\n\n    function lists__listWeekdays (format, index) {\n        return list(format, index, 'weekdays', 7, 'day');\n    }\n\n    function lists__listWeekdaysShort (format, index) {\n        return list(format, index, 'weekdaysShort', 7, 'day');\n    }\n\n    function lists__listWeekdaysMin (format, index) {\n        return list(format, index, 'weekdaysMin', 7, 'day');\n    }\n\n    locale_locales__getSetGlobalLocale('en', {\n        ordinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (toInt(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        }\n    });\n\n    // Side effect imports\n    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);\n    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);\n\n    var mathAbs = Math.abs;\n\n    function duration_abs__abs () {\n        var data           = this._data;\n\n        this._milliseconds = mathAbs(this._milliseconds);\n        this._days         = mathAbs(this._days);\n        this._months       = mathAbs(this._months);\n\n        data.milliseconds  = mathAbs(data.milliseconds);\n        data.seconds       = mathAbs(data.seconds);\n        data.minutes       = mathAbs(data.minutes);\n        data.hours         = mathAbs(data.hours);\n        data.months        = mathAbs(data.months);\n        data.years         = mathAbs(data.years);\n\n        return this;\n    }\n\n    function duration_add_subtract__addSubtract (duration, input, value, direction) {\n        var other = create__createDuration(input, value);\n\n        duration._milliseconds += direction * other._milliseconds;\n        duration._days         += direction * other._days;\n        duration._months       += direction * other._months;\n\n        return duration._bubble();\n    }\n\n    // supports only 2.0-style add(1, 's') or add(duration)\n    function duration_add_subtract__add (input, value) {\n        return duration_add_subtract__addSubtract(this, input, value, 1);\n    }\n\n    // supports only 2.0-style subtract(1, 's') or subtract(duration)\n    function duration_add_subtract__subtract (input, value) {\n        return duration_add_subtract__addSubtract(this, input, value, -1);\n    }\n\n    function absCeil (number) {\n        if (number < 0) {\n            return Math.floor(number);\n        } else {\n            return Math.ceil(number);\n        }\n    }\n\n    function bubble () {\n        var milliseconds = this._milliseconds;\n        var days         = this._days;\n        var months       = this._months;\n        var data         = this._data;\n        var seconds, minutes, hours, years, monthsFromDays;\n\n        // if we have a mix of positive and negative values, bubble down first\n        // check: https://github.com/moment/moment/issues/2166\n        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n                (milliseconds <= 0 && days <= 0 && months <= 0))) {\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n            days = 0;\n            months = 0;\n        }\n\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n\n        seconds           = absFloor(milliseconds / 1000);\n        data.seconds      = seconds % 60;\n\n        minutes           = absFloor(seconds / 60);\n        data.minutes      = minutes % 60;\n\n        hours             = absFloor(minutes / 60);\n        data.hours        = hours % 24;\n\n        days += absFloor(hours / 24);\n\n        // convert days to months\n        monthsFromDays = absFloor(daysToMonths(days));\n        months += monthsFromDays;\n        days -= absCeil(monthsToDays(monthsFromDays));\n\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n\n        data.days   = days;\n        data.months = months;\n        data.years  = years;\n\n        return this;\n    }\n\n    function daysToMonths (days) {\n        // 400 years have 146097 days (taking into account leap year rules)\n        // 400 years have 12 months === 4800\n        return days * 4800 / 146097;\n    }\n\n    function monthsToDays (months) {\n        // the reverse of daysToMonths\n        return months * 146097 / 4800;\n    }\n\n    function as (units) {\n        var days;\n        var months;\n        var milliseconds = this._milliseconds;\n\n        units = normalizeUnits(units);\n\n        if (units === 'month' || units === 'year') {\n            days   = this._days   + milliseconds / 864e5;\n            months = this._months + daysToMonths(days);\n            return units === 'month' ? months : months / 12;\n        } else {\n            // handle milliseconds separately because of floating point math errors (issue #1867)\n            days = this._days + Math.round(monthsToDays(this._months));\n            switch (units) {\n                case 'week'   : return days / 7     + milliseconds / 6048e5;\n                case 'day'    : return days         + milliseconds / 864e5;\n                case 'hour'   : return days * 24    + milliseconds / 36e5;\n                case 'minute' : return days * 1440  + milliseconds / 6e4;\n                case 'second' : return days * 86400 + milliseconds / 1000;\n                // Math.floor prevents floating point math errors here\n                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\n                default: throw new Error('Unknown unit ' + units);\n            }\n        }\n    }\n\n    // TODO: Use this.as('ms')?\n    function duration_as__valueOf () {\n        return (\n            this._milliseconds +\n            this._days * 864e5 +\n            (this._months % 12) * 2592e6 +\n            toInt(this._months / 12) * 31536e6\n        );\n    }\n\n    function makeAs (alias) {\n        return function () {\n            return this.as(alias);\n        };\n    }\n\n    var asMilliseconds = makeAs('ms');\n    var asSeconds      = makeAs('s');\n    var asMinutes      = makeAs('m');\n    var asHours        = makeAs('h');\n    var asDays         = makeAs('d');\n    var asWeeks        = makeAs('w');\n    var asMonths       = makeAs('M');\n    var asYears        = makeAs('y');\n\n    function duration_get__get (units) {\n        units = normalizeUnits(units);\n        return this[units + 's']();\n    }\n\n    function makeGetter(name) {\n        return function () {\n            return this._data[name];\n        };\n    }\n\n    var milliseconds = makeGetter('milliseconds');\n    var seconds      = makeGetter('seconds');\n    var minutes      = makeGetter('minutes');\n    var hours        = makeGetter('hours');\n    var days         = makeGetter('days');\n    var duration_get__months       = makeGetter('months');\n    var years        = makeGetter('years');\n\n    function weeks () {\n        return absFloor(this.days() / 7);\n    }\n\n    var round = Math.round;\n    var thresholds = {\n        s: 45,  // seconds to minute\n        m: 45,  // minutes to hour\n        h: 22,  // hours to day\n        d: 26,  // days to month\n        M: 11   // months to year\n    };\n\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n    }\n\n    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {\n        var duration = create__createDuration(posNegDuration).abs();\n        var seconds  = round(duration.as('s'));\n        var minutes  = round(duration.as('m'));\n        var hours    = round(duration.as('h'));\n        var days     = round(duration.as('d'));\n        var months   = round(duration.as('M'));\n        var years    = round(duration.as('y'));\n\n        var a = seconds < thresholds.s && ['s', seconds]  ||\n                minutes === 1          && ['m']           ||\n                minutes < thresholds.m && ['mm', minutes] ||\n                hours   === 1          && ['h']           ||\n                hours   < thresholds.h && ['hh', hours]   ||\n                days    === 1          && ['d']           ||\n                days    < thresholds.d && ['dd', days]    ||\n                months  === 1          && ['M']           ||\n                months  < thresholds.M && ['MM', months]  ||\n                years   === 1          && ['y']           || ['yy', years];\n\n        a[2] = withoutSuffix;\n        a[3] = +posNegDuration > 0;\n        a[4] = locale;\n        return substituteTimeAgo.apply(null, a);\n    }\n\n    // This function allows you to set a threshold for relative time strings\n    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {\n        if (thresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return thresholds[threshold];\n        }\n        thresholds[threshold] = limit;\n        return true;\n    }\n\n    function humanize (withSuffix) {\n        var locale = this.localeData();\n        var output = duration_humanize__relativeTime(this, !withSuffix, locale);\n\n        if (withSuffix) {\n            output = locale.pastFuture(+this, output);\n        }\n\n        return locale.postformat(output);\n    }\n\n    var iso_string__abs = Math.abs;\n\n    function iso_string__toISOString() {\n        // for ISO strings we do not use the normal bubbling rules:\n        //  * milliseconds bubble up until they become hours\n        //  * days do not bubble at all\n        //  * months bubble up until they become years\n        // This is because there is no context-free conversion between hours and days\n        // (think of clock changes)\n        // and also not between days and months (28-31 days per month)\n        var seconds = iso_string__abs(this._milliseconds) / 1000;\n        var days         = iso_string__abs(this._days);\n        var months       = iso_string__abs(this._months);\n        var minutes, hours, years;\n\n        // 3600 seconds -> 60 minutes -> 1 hour\n        minutes           = absFloor(seconds / 60);\n        hours             = absFloor(minutes / 60);\n        seconds %= 60;\n        minutes %= 60;\n\n        // 12 months -> 1 year\n        years  = absFloor(months / 12);\n        months %= 12;\n\n\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n        var Y = years;\n        var M = months;\n        var D = days;\n        var h = hours;\n        var m = minutes;\n        var s = seconds;\n        var total = this.asSeconds();\n\n        if (!total) {\n            // this is the same as C#'s (Noda) and python (isodate)...\n            // but not other JS (goog.date)\n            return 'P0D';\n        }\n\n        return (total < 0 ? '-' : '') +\n            'P' +\n            (Y ? Y + 'Y' : '') +\n            (M ? M + 'M' : '') +\n            (D ? D + 'D' : '') +\n            ((h || m || s) ? 'T' : '') +\n            (h ? h + 'H' : '') +\n            (m ? m + 'M' : '') +\n            (s ? s + 'S' : '');\n    }\n\n    var duration_prototype__proto = Duration.prototype;\n\n    duration_prototype__proto.abs            = duration_abs__abs;\n    duration_prototype__proto.add            = duration_add_subtract__add;\n    duration_prototype__proto.subtract       = duration_add_subtract__subtract;\n    duration_prototype__proto.as             = as;\n    duration_prototype__proto.asMilliseconds = asMilliseconds;\n    duration_prototype__proto.asSeconds      = asSeconds;\n    duration_prototype__proto.asMinutes      = asMinutes;\n    duration_prototype__proto.asHours        = asHours;\n    duration_prototype__proto.asDays         = asDays;\n    duration_prototype__proto.asWeeks        = asWeeks;\n    duration_prototype__proto.asMonths       = asMonths;\n    duration_prototype__proto.asYears        = asYears;\n    duration_prototype__proto.valueOf        = duration_as__valueOf;\n    duration_prototype__proto._bubble        = bubble;\n    duration_prototype__proto.get            = duration_get__get;\n    duration_prototype__proto.milliseconds   = milliseconds;\n    duration_prototype__proto.seconds        = seconds;\n    duration_prototype__proto.minutes        = minutes;\n    duration_prototype__proto.hours          = hours;\n    duration_prototype__proto.days           = days;\n    duration_prototype__proto.weeks          = weeks;\n    duration_prototype__proto.months         = duration_get__months;\n    duration_prototype__proto.years          = years;\n    duration_prototype__proto.humanize       = humanize;\n    duration_prototype__proto.toISOString    = iso_string__toISOString;\n    duration_prototype__proto.toString       = iso_string__toISOString;\n    duration_prototype__proto.toJSON         = iso_string__toISOString;\n    duration_prototype__proto.locale         = locale;\n    duration_prototype__proto.localeData     = localeData;\n\n    // Deprecations\n    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);\n    duration_prototype__proto.lang = lang;\n\n    // Side effect imports\n\n    addFormatToken('X', 0, 0, 'unix');\n    addFormatToken('x', 0, 0, 'valueOf');\n\n    // PARSING\n\n    addRegexToken('x', matchSigned);\n    addRegexToken('X', matchTimestamp);\n    addParseToken('X', function (input, array, config) {\n        config._d = new Date(parseFloat(input, 10) * 1000);\n    });\n    addParseToken('x', function (input, array, config) {\n        config._d = new Date(toInt(input));\n    });\n\n    // Side effect imports\n\n    ;\n\n    //! moment.js\n    //! version : 2.10.6\n    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n    //! license : MIT\n    //! momentjs.com\n\n    utils_hooks__hooks.version = '2.10.6';\n\n    setHookCallback(local__createLocal);\n\n    utils_hooks__hooks.fn                    = momentPrototype;\n    utils_hooks__hooks.min                   = min;\n    utils_hooks__hooks.max                   = max;\n    utils_hooks__hooks.utc                   = create_utc__createUTC;\n    utils_hooks__hooks.unix                  = moment_moment__createUnix;\n    utils_hooks__hooks.months                = lists__listMonths;\n    utils_hooks__hooks.isDate                = isDate;\n    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;\n    utils_hooks__hooks.invalid               = valid__createInvalid;\n    utils_hooks__hooks.duration              = create__createDuration;\n    utils_hooks__hooks.isMoment              = isMoment;\n    utils_hooks__hooks.weekdays              = lists__listWeekdays;\n    utils_hooks__hooks.parseZone             = moment_moment__createInZone;\n    utils_hooks__hooks.localeData            = locale_locales__getLocale;\n    utils_hooks__hooks.isDuration            = isDuration;\n    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;\n    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;\n    utils_hooks__hooks.defineLocale          = defineLocale;\n    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;\n    utils_hooks__hooks.normalizeUnits        = normalizeUnits;\n    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;\n\n    var _moment__default = utils_hooks__hooks;\n\n    //! moment.js locale configuration\n    //! locale : afrikaans (af)\n    //! author : Werner Mollentze : https://github.com/wernerm\n\n    var af = _moment__default.defineLocale('af', {\n        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),\n        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),\n        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),\n        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),\n        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),\n        meridiemParse: /vm|nm/i,\n        isPM : function (input) {\n            return /^nm$/i.test(input);\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours < 12) {\n                return isLower ? 'vm' : 'VM';\n            } else {\n                return isLower ? 'nm' : 'NM';\n            }\n        },\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[Vandag om] LT',\n            nextDay : '[Mre om] LT',\n            nextWeek : 'dddd [om] LT',\n            lastDay : '[Gister om] LT',\n            lastWeek : '[Laas] dddd [om] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'oor %s',\n            past : '%s gelede',\n            s : '\\'n paar sekondes',\n            m : '\\'n minuut',\n            mm : '%d minute',\n            h : '\\'n uur',\n            hh : '%d ure',\n            d : '\\'n dag',\n            dd : '%d dae',\n            M : '\\'n maand',\n            MM : '%d maande',\n            y : '\\'n jaar',\n            yy : '%d jaar'\n        },\n        ordinalParse: /\\d{1,2}(ste|de)/,\n        ordinal : function (number) {\n            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter\n        },\n        week : {\n            dow : 1, // Maandag is die eerste dag van die week.\n            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Moroccan Arabic (ar-ma)\n    //! author : ElFadili Yassine : https://github.com/ElFadiliY\n    //! author : Abdel Said : https://github.com/abdelsaid\n\n    var ar_ma = _moment__default.defineLocale('ar-ma', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[  ] LT',\n            nextDay: '[  ] LT',\n            nextWeek: 'dddd [ ] LT',\n            lastDay: '[  ] LT',\n            lastWeek: 'dddd [ ] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : ' %s',\n            s : '',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d ',\n            M : '',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        week : {\n            dow : 6, // Saturday is the first day of the week.\n            doy : 12  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Arabic Saudi Arabia (ar-sa)\n    //! author : Suhail Alkowaileet : https://github.com/xsoh\n\n    var ar_sa__symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    }, ar_sa__numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var ar_sa = _moment__default.defineLocale('ar-sa', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        meridiemParse: /|/,\n        isPM : function (input) {\n            return '' === input;\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 12) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay: '[  ] LT',\n            nextDay: '[  ] LT',\n            nextWeek: 'dddd [ ] LT',\n            lastDay: '[  ] LT',\n            lastWeek: 'dddd [ ] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : ' %s',\n            s : '',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d ',\n            M : '',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return ar_sa__numberMap[match];\n            }).replace(//g, ',');\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return ar_sa__symbolMap[match];\n            }).replace(/,/g, '');\n        },\n        week : {\n            dow : 6, // Saturday is the first day of the week.\n            doy : 12  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale  : Tunisian Arabic (ar-tn)\n\n    var ar_tn = _moment__default.defineLocale('ar-tn', {\n        months: '___________'.split('_'),\n        monthsShort: '___________'.split('_'),\n        weekdays: '______'.split('_'),\n        weekdaysShort: '______'.split('_'),\n        weekdaysMin: '______'.split('_'),\n        longDateFormat: {\n            LT: 'HH:mm',\n            LTS: 'HH:mm:ss',\n            L: 'DD/MM/YYYY',\n            LL: 'D MMMM YYYY',\n            LLL: 'D MMMM YYYY HH:mm',\n            LLLL: 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar: {\n            sameDay: '[  ] LT',\n            nextDay: '[  ] LT',\n            nextWeek: 'dddd [ ] LT',\n            lastDay: '[  ] LT',\n            lastWeek: 'dddd [ ] LT',\n            sameElse: 'L'\n        },\n        relativeTime: {\n            future: ' %s',\n            past: ' %s',\n            s: '',\n            m: '',\n            mm: '%d ',\n            h: '',\n            hh: '%d ',\n            d: '',\n            dd: '%d ',\n            M: '',\n            MM: '%d ',\n            y: '',\n            yy: '%d '\n        },\n        week: {\n            dow: 1, // Monday is the first day of the week.\n            doy: 4 // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! Locale: Arabic (ar)\n    //! Author: Abdel Said: https://github.com/abdelsaid\n    //! Changes in months, weekdays: Ahmed Elkhatib\n    //! Native plural forms: forabi https://github.com/forabi\n\n    var ar__symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    }, ar__numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    }, pluralForm = function (n) {\n        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;\n    }, plurals = {\n        s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n        m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n        h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n        d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n        M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],\n        y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']\n    }, pluralize = function (u) {\n        return function (number, withoutSuffix, string, isFuture) {\n            var f = pluralForm(number),\n                str = plurals[u][pluralForm(number)];\n            if (f === 2) {\n                str = str[withoutSuffix ? 0 : 1];\n            }\n            return str.replace(/%d/i, number);\n        };\n    }, ar__months = [\n        '  ',\n        ' ',\n        ' ',\n        ' ',\n        ' ',\n        ' ',\n        ' ',\n        ' ',\n        ' ',\n        '  ',\n        '  ',\n        '  '\n    ];\n\n    var ar = _moment__default.defineLocale('ar', {\n        months : ar__months,\n        monthsShort : ar__months,\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'D/\\u200FM/\\u200FYYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        meridiemParse: /|/,\n        isPM : function (input) {\n            return '' === input;\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 12) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay: '[  ] LT',\n            nextDay: '[  ] LT',\n            nextWeek: 'dddd [ ] LT',\n            lastDay: '[  ] LT',\n            lastWeek: 'dddd [ ] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : ' %s',\n            s : pluralize('s'),\n            m : pluralize('m'),\n            mm : pluralize('m'),\n            h : pluralize('h'),\n            hh : pluralize('h'),\n            d : pluralize('d'),\n            dd : pluralize('d'),\n            M : pluralize('M'),\n            MM : pluralize('M'),\n            y : pluralize('y'),\n            yy : pluralize('y')\n        },\n        preparse: function (string) {\n            return string.replace(/\\u200f/g, '').replace(/[]/g, function (match) {\n                return ar__numberMap[match];\n            }).replace(//g, ',');\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return ar__symbolMap[match];\n            }).replace(/,/g, '');\n        },\n        week : {\n            dow : 6, // Saturday is the first day of the week.\n            doy : 12  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : azerbaijani (az)\n    //! author : topchiyev : https://github.com/topchiyev\n\n    var az__suffixes = {\n        1: '-inci',\n        5: '-inci',\n        8: '-inci',\n        70: '-inci',\n        80: '-inci',\n        2: '-nci',\n        7: '-nci',\n        20: '-nci',\n        50: '-nci',\n        3: '-nc',\n        4: '-nc',\n        100: '-nc',\n        6: '-nc',\n        9: '-uncu',\n        10: '-uncu',\n        30: '-uncu',\n        60: '-nc',\n        90: '-nc'\n    };\n\n    var az = _moment__default.defineLocale('az', {\n        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),\n        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),\n        weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),\n        weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),\n        weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[bugn saat] LT',\n            nextDay : '[sabah saat] LT',\n            nextWeek : '[gln hft] dddd [saat] LT',\n            lastDay : '[dnn] LT',\n            lastWeek : '[ken hft] dddd [saat] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s sonra',\n            past : '%s vvl',\n            s : 'birne saniyy',\n            m : 'bir dqiq',\n            mm : '%d dqiq',\n            h : 'bir saat',\n            hh : '%d saat',\n            d : 'bir gn',\n            dd : '%d gn',\n            M : 'bir ay',\n            MM : '%d ay',\n            y : 'bir il',\n            yy : '%d il'\n        },\n        meridiemParse: /gec|shr|gndz|axam/,\n        isPM : function (input) {\n            return /^(gndz|axam)$/.test(input);\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return 'gec';\n            } else if (hour < 12) {\n                return 'shr';\n            } else if (hour < 17) {\n                return 'gndz';\n            } else {\n                return 'axam';\n            }\n        },\n        ordinalParse: /\\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,\n        ordinal : function (number) {\n            if (number === 0) {  // special case for zero\n                return number + '-nc';\n            }\n            var a = number % 10,\n                b = number % 100 - a,\n                c = number >= 100 ? 100 : null;\n            return number + (az__suffixes[a] || az__suffixes[b] || az__suffixes[c]);\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : belarusian (be)\n    //! author : Dmitry Demidov : https://github.com/demidov91\n    //! author: Praleska: http://praleska.pro/\n    //! Author : Menelion Elensle : https://github.com/Oire\n\n    function be__plural(word, num) {\n        var forms = word.split('_');\n        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);\n    }\n    function be__relativeTimeWithPlural(number, withoutSuffix, key) {\n        var format = {\n            'mm': withoutSuffix ? '__' : '__',\n            'hh': withoutSuffix ? '__' : '__',\n            'dd': '__',\n            'MM': '__',\n            'yy': '__'\n        };\n        if (key === 'm') {\n            return withoutSuffix ? '' : '';\n        }\n        else if (key === 'h') {\n            return withoutSuffix ? '' : '';\n        }\n        else {\n            return number + ' ' + be__plural(format[key], +number);\n        }\n    }\n    function be__monthsCaseReplace(m, format) {\n        var months = {\n            'nominative': '___________'.split('_'),\n            'accusative': '___________'.split('_')\n        },\n        nounCase = (/D[oD]?(\\[[^\\[\\]]*\\]|\\s+)+MMMM?/).test(format) ?\n            'accusative' :\n            'nominative';\n        return months[nounCase][m.month()];\n    }\n    function be__weekdaysCaseReplace(m, format) {\n        var weekdays = {\n            'nominative': '______'.split('_'),\n            'accusative': '______'.split('_')\n        },\n        nounCase = (/\\[ ?[] ?(?:|)? ?\\] ?dddd/).test(format) ?\n            'accusative' :\n            'nominative';\n        return weekdays[nounCase][m.day()];\n    }\n\n    var be = _moment__default.defineLocale('be', {\n        months : be__monthsCaseReplace,\n        monthsShort : '___________'.split('_'),\n        weekdays : be__weekdaysCaseReplace,\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY .',\n            LLL : 'D MMMM YYYY ., HH:mm',\n            LLLL : 'dddd, D MMMM YYYY ., HH:mm'\n        },\n        calendar : {\n            sameDay: '[ ] LT',\n            nextDay: '[ ] LT',\n            lastDay: '[ ] LT',\n            nextWeek: function () {\n                return '[] dddd [] LT';\n            },\n            lastWeek: function () {\n                switch (this.day()) {\n                case 0:\n                case 3:\n                case 5:\n                case 6:\n                    return '[ ] dddd [] LT';\n                case 1:\n                case 2:\n                case 4:\n                    return '[ ] dddd [] LT';\n                }\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : '%s ',\n            s : ' ',\n            m : be__relativeTimeWithPlural,\n            mm : be__relativeTimeWithPlural,\n            h : be__relativeTimeWithPlural,\n            hh : be__relativeTimeWithPlural,\n            d : '',\n            dd : be__relativeTimeWithPlural,\n            M : '',\n            MM : be__relativeTimeWithPlural,\n            y : '',\n            yy : be__relativeTimeWithPlural\n        },\n        meridiemParse: /|||/,\n        isPM : function (input) {\n            return /^(|)$/.test(input);\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 12) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        ordinalParse: /\\d{1,2}-(||)/,\n        ordinal: function (number, period) {\n            switch (period) {\n            case 'M':\n            case 'd':\n            case 'DDD':\n            case 'w':\n            case 'W':\n                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';\n            case 'D':\n                return number + '-';\n            default:\n                return number;\n            }\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : bulgarian (bg)\n    //! author : Krasen Borisov : https://github.com/kraz\n\n    var bg = _moment__default.defineLocale('bg', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'D.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY H:mm',\n            LLLL : 'dddd, D MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay : '[ ] LT',\n            nextDay : '[ ] LT',\n            nextWeek : 'dddd [] LT',\n            lastDay : '[ ] LT',\n            lastWeek : function () {\n                switch (this.day()) {\n                case 0:\n                case 3:\n                case 6:\n                    return '[ ] dddd [] LT';\n                case 1:\n                case 2:\n                case 4:\n                case 5:\n                    return '[ ] dddd [] LT';\n                }\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : ' %s',\n            s : ' ',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d ',\n            M : '',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        ordinalParse: /\\d{1,2}-(|||||)/,\n        ordinal : function (number) {\n            var lastDigit = number % 10,\n                last2Digits = number % 100;\n            if (number === 0) {\n                return number + '-';\n            } else if (last2Digits === 0) {\n                return number + '-';\n            } else if (last2Digits > 10 && last2Digits < 20) {\n                return number + '-';\n            } else if (lastDigit === 1) {\n                return number + '-';\n            } else if (lastDigit === 2) {\n                return number + '-';\n            } else if (lastDigit === 7 || lastDigit === 8) {\n                return number + '-';\n            } else {\n                return number + '-';\n            }\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Bengali (bn)\n    //! author : Kaushik Gandhi : https://github.com/kaushikgandhi\n\n    var bn__symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    },\n    bn__numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var bn = _moment__default.defineLocale('bn', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'A h:mm ',\n            LTS : 'A h:mm:ss ',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY, A h:mm ',\n            LLLL : 'dddd, D MMMM YYYY, A h:mm '\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : 'dddd, LT',\n            lastDay : '[] LT',\n            lastWeek : '[] dddd, LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : ' ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return bn__numberMap[match];\n            });\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return bn__symbolMap[match];\n            });\n        },\n        meridiemParse: /||||/,\n        isPM: function (input) {\n            return /^(||)$/.test(input);\n        },\n        //Bengali is a vast language its spoken\n        //in different forms in various parts of the world.\n        //I have just generalized with most common one used\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 10) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else if (hour < 20) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : tibetan (bo)\n    //! author : Thupten N. Chakrishar : https://github.com/vajradog\n\n    var bo__symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    },\n    bo__numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var bo = _moment__default.defineLocale('bo', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'A h:mm',\n            LTS : 'A h:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY, A h:mm',\n            LLLL : 'dddd, D MMMM YYYY, A h:mm'\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : '[], LT',\n            lastDay : '[] LT',\n            lastWeek : '[] dddd, LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : '',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d ',\n            M : '',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return bo__numberMap[match];\n            });\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return bo__symbolMap[match];\n            });\n        },\n        meridiemParse: /||||/,\n        isPM: function (input) {\n            return /^(||)$/.test(input);\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 10) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else if (hour < 20) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : breton (br)\n    //! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou\n\n    function relativeTimeWithMutation(number, withoutSuffix, key) {\n        var format = {\n            'mm': 'munutenn',\n            'MM': 'miz',\n            'dd': 'devezh'\n        };\n        return number + ' ' + mutation(format[key], number);\n    }\n    function specialMutationForYears(number) {\n        switch (lastNumber(number)) {\n        case 1:\n        case 3:\n        case 4:\n        case 5:\n        case 9:\n            return number + ' bloaz';\n        default:\n            return number + ' vloaz';\n        }\n    }\n    function lastNumber(number) {\n        if (number > 9) {\n            return lastNumber(number % 10);\n        }\n        return number;\n    }\n    function mutation(text, number) {\n        if (number === 2) {\n            return softMutation(text);\n        }\n        return text;\n    }\n    function softMutation(text) {\n        var mutationTable = {\n            'm': 'v',\n            'b': 'v',\n            'd': 'z'\n        };\n        if (mutationTable[text.charAt(0)] === undefined) {\n            return text;\n        }\n        return mutationTable[text.charAt(0)] + text.substring(1);\n    }\n\n    var br = _moment__default.defineLocale('br', {\n        months : 'Genver_C\\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),\n        monthsShort : 'Gen_C\\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),\n        weekdays : 'Sul_Lun_Meurzh_Merc\\'her_Yaou_Gwener_Sadorn'.split('_'),\n        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),\n        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),\n        longDateFormat : {\n            LT : 'h[e]mm A',\n            LTS : 'h[e]mm:ss A',\n            L : 'DD/MM/YYYY',\n            LL : 'D [a viz] MMMM YYYY',\n            LLL : 'D [a viz] MMMM YYYY h[e]mm A',\n            LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'\n        },\n        calendar : {\n            sameDay : '[Hiziv da] LT',\n            nextDay : '[Warc\\'hoazh da] LT',\n            nextWeek : 'dddd [da] LT',\n            lastDay : '[Dec\\'h da] LT',\n            lastWeek : 'dddd [paset da] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'a-benn %s',\n            past : '%s \\'zo',\n            s : 'un nebeud segondenno',\n            m : 'ur vunutenn',\n            mm : relativeTimeWithMutation,\n            h : 'un eur',\n            hh : '%d eur',\n            d : 'un devezh',\n            dd : relativeTimeWithMutation,\n            M : 'ur miz',\n            MM : relativeTimeWithMutation,\n            y : 'ur bloaz',\n            yy : specialMutationForYears\n        },\n        ordinalParse: /\\d{1,2}(a|vet)/,\n        ordinal : function (number) {\n            var output = (number === 1) ? 'a' : 'vet';\n            return number + output;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : bosnian (bs)\n    //! author : Nedim Cholich : https://github.com/frontyard\n    //! based on (hr) translation by Bojan Markovi\n\n    function bs__translate(number, withoutSuffix, key) {\n        var result = number + ' ';\n        switch (key) {\n        case 'm':\n            return withoutSuffix ? 'jedna minuta' : 'jedne minute';\n        case 'mm':\n            if (number === 1) {\n                result += 'minuta';\n            } else if (number === 2 || number === 3 || number === 4) {\n                result += 'minute';\n            } else {\n                result += 'minuta';\n            }\n            return result;\n        case 'h':\n            return withoutSuffix ? 'jedan sat' : 'jednog sata';\n        case 'hh':\n            if (number === 1) {\n                result += 'sat';\n            } else if (number === 2 || number === 3 || number === 4) {\n                result += 'sata';\n            } else {\n                result += 'sati';\n            }\n            return result;\n        case 'dd':\n            if (number === 1) {\n                result += 'dan';\n            } else {\n                result += 'dana';\n            }\n            return result;\n        case 'MM':\n            if (number === 1) {\n                result += 'mjesec';\n            } else if (number === 2 || number === 3 || number === 4) {\n                result += 'mjeseca';\n            } else {\n                result += 'mjeseci';\n            }\n            return result;\n        case 'yy':\n            if (number === 1) {\n                result += 'godina';\n            } else if (number === 2 || number === 3 || number === 4) {\n                result += 'godine';\n            } else {\n                result += 'godina';\n            }\n            return result;\n        }\n    }\n\n    var bs = _moment__default.defineLocale('bs', {\n        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),\n        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),\n        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),\n        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),\n        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD. MM. YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY H:mm',\n            LLLL : 'dddd, D. MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay  : '[danas u] LT',\n            nextDay  : '[sutra u] LT',\n            nextWeek : function () {\n                switch (this.day()) {\n                case 0:\n                    return '[u] [nedjelju] [u] LT';\n                case 3:\n                    return '[u] [srijedu] [u] LT';\n                case 6:\n                    return '[u] [subotu] [u] LT';\n                case 1:\n                case 2:\n                case 4:\n                case 5:\n                    return '[u] dddd [u] LT';\n                }\n            },\n            lastDay  : '[juer u] LT',\n            lastWeek : function () {\n                switch (this.day()) {\n                case 0:\n                case 3:\n                    return '[prolu] dddd [u] LT';\n                case 6:\n                    return '[prole] [subote] [u] LT';\n                case 1:\n                case 2:\n                case 4:\n                case 5:\n                    return '[proli] dddd [u] LT';\n                }\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'za %s',\n            past   : 'prije %s',\n            s      : 'par sekundi',\n            m      : bs__translate,\n            mm     : bs__translate,\n            h      : bs__translate,\n            hh     : bs__translate,\n            d      : 'dan',\n            dd     : bs__translate,\n            M      : 'mjesec',\n            MM     : bs__translate,\n            y      : 'godinu',\n            yy     : bs__translate\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : catalan (ca)\n    //! author : Juan G. Hurtado : https://github.com/juanghurtado\n\n    var ca = _moment__default.defineLocale('ca', {\n        months : 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),\n        monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),\n        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),\n        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),\n        weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'LT:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY H:mm',\n            LLLL : 'dddd D MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay : function () {\n                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';\n            },\n            nextDay : function () {\n                return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';\n            },\n            nextWeek : function () {\n                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';\n            },\n            lastDay : function () {\n                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';\n            },\n            lastWeek : function () {\n                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'en %s',\n            past : 'fa %s',\n            s : 'uns segons',\n            m : 'un minut',\n            mm : '%d minuts',\n            h : 'una hora',\n            hh : '%d hores',\n            d : 'un dia',\n            dd : '%d dies',\n            M : 'un mes',\n            MM : '%d mesos',\n            y : 'un any',\n            yy : '%d anys'\n        },\n        ordinalParse: /\\d{1,2}(r|n|t||a)/,\n        ordinal : function (number, period) {\n            var output = (number === 1) ? 'r' :\n                (number === 2) ? 'n' :\n                (number === 3) ? 'r' :\n                (number === 4) ? 't' : '';\n            if (period === 'w' || period === 'W') {\n                output = 'a';\n            }\n            return number + output;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : czech (cs)\n    //! author : petrbela : https://github.com/petrbela\n\n    var cs__months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),\n        cs__monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');\n    function cs__plural(n) {\n        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);\n    }\n    function cs__translate(number, withoutSuffix, key, isFuture) {\n        var result = number + ' ';\n        switch (key) {\n        case 's':  // a few seconds / in a few seconds / a few seconds ago\n            return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';\n        case 'm':  // a minute / in a minute / a minute ago\n            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');\n        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago\n            if (withoutSuffix || isFuture) {\n                return result + (cs__plural(number) ? 'minuty' : 'minut');\n            } else {\n                return result + 'minutami';\n            }\n            break;\n        case 'h':  // an hour / in an hour / an hour ago\n            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');\n        case 'hh': // 9 hours / in 9 hours / 9 hours ago\n            if (withoutSuffix || isFuture) {\n                return result + (cs__plural(number) ? 'hodiny' : 'hodin');\n            } else {\n                return result + 'hodinami';\n            }\n            break;\n        case 'd':  // a day / in a day / a day ago\n            return (withoutSuffix || isFuture) ? 'den' : 'dnem';\n        case 'dd': // 9 days / in 9 days / 9 days ago\n            if (withoutSuffix || isFuture) {\n                return result + (cs__plural(number) ? 'dny' : 'dn');\n            } else {\n                return result + 'dny';\n            }\n            break;\n        case 'M':  // a month / in a month / a month ago\n            return (withoutSuffix || isFuture) ? 'msc' : 'mscem';\n        case 'MM': // 9 months / in 9 months / 9 months ago\n            if (withoutSuffix || isFuture) {\n                return result + (cs__plural(number) ? 'msce' : 'msc');\n            } else {\n                return result + 'msci';\n            }\n            break;\n        case 'y':  // a year / in a year / a year ago\n            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';\n        case 'yy': // 9 years / in 9 years / 9 years ago\n            if (withoutSuffix || isFuture) {\n                return result + (cs__plural(number) ? 'roky' : 'let');\n            } else {\n                return result + 'lety';\n            }\n            break;\n        }\n    }\n\n    var cs = _moment__default.defineLocale('cs', {\n        months : cs__months,\n        monthsShort : cs__monthsShort,\n        monthsParse : (function (months, monthsShort) {\n            var i, _monthsParse = [];\n            for (i = 0; i < 12; i++) {\n                // use custom parser to solve problem with July (ervenec)\n                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');\n            }\n            return _monthsParse;\n        }(cs__months, cs__monthsShort)),\n        weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),\n        weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),\n        weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),\n        longDateFormat : {\n            LT: 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY H:mm',\n            LLLL : 'dddd D. MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay: '[dnes v] LT',\n            nextDay: '[ztra v] LT',\n            nextWeek: function () {\n                switch (this.day()) {\n                case 0:\n                    return '[v nedli v] LT';\n                case 1:\n                case 2:\n                    return '[v] dddd [v] LT';\n                case 3:\n                    return '[ve stedu v] LT';\n                case 4:\n                    return '[ve tvrtek v] LT';\n                case 5:\n                    return '[v ptek v] LT';\n                case 6:\n                    return '[v sobotu v] LT';\n                }\n            },\n            lastDay: '[vera v] LT',\n            lastWeek: function () {\n                switch (this.day()) {\n                case 0:\n                    return '[minulou nedli v] LT';\n                case 1:\n                case 2:\n                    return '[minul] dddd [v] LT';\n                case 3:\n                    return '[minulou stedu v] LT';\n                case 4:\n                case 5:\n                    return '[minul] dddd [v] LT';\n                case 6:\n                    return '[minulou sobotu v] LT';\n                }\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'za %s',\n            past : 'ped %s',\n            s : cs__translate,\n            m : cs__translate,\n            mm : cs__translate,\n            h : cs__translate,\n            hh : cs__translate,\n            d : cs__translate,\n            dd : cs__translate,\n            M : cs__translate,\n            MM : cs__translate,\n            y : cs__translate,\n            yy : cs__translate\n        },\n        ordinalParse : /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : chuvash (cv)\n    //! author : Anatoly Mironov : https://github.com/mirontoli\n\n    var cv = _moment__default.defineLocale('cv', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD-MM-YYYY',\n            LL : 'YYYY [] MMMM [] D[-]',\n            LLL : 'YYYY [] MMMM [] D[-], HH:mm',\n            LLLL : 'dddd, YYYY [] MMMM [] D[-], HH:mm'\n        },\n        calendar : {\n            sameDay: '[] LT []',\n            nextDay: '[] LT []',\n            lastDay: '[] LT []',\n            nextWeek: '[] dddd LT []',\n            lastWeek: '[] dddd LT []',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : function (output) {\n                var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';\n                return output + affix;\n            },\n            past : '%s ',\n            s : '- ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        ordinalParse: /\\d{1,2}-/,\n        ordinal : '%d-',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Welsh (cy)\n    //! author : Robert Allen\n\n    var cy = _moment__default.defineLocale('cy', {\n        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),\n        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),\n        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),\n        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),\n        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),\n        // time formats are the same as en-gb\n        longDateFormat: {\n            LT: 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L: 'DD/MM/YYYY',\n            LL: 'D MMMM YYYY',\n            LLL: 'D MMMM YYYY HH:mm',\n            LLLL: 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar: {\n            sameDay: '[Heddiw am] LT',\n            nextDay: '[Yfory am] LT',\n            nextWeek: 'dddd [am] LT',\n            lastDay: '[Ddoe am] LT',\n            lastWeek: 'dddd [diwethaf am] LT',\n            sameElse: 'L'\n        },\n        relativeTime: {\n            future: 'mewn %s',\n            past: '%s yn l',\n            s: 'ychydig eiliadau',\n            m: 'munud',\n            mm: '%d munud',\n            h: 'awr',\n            hh: '%d awr',\n            d: 'diwrnod',\n            dd: '%d diwrnod',\n            M: 'mis',\n            MM: '%d mis',\n            y: 'blwyddyn',\n            yy: '%d flynedd'\n        },\n        ordinalParse: /\\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,\n        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh\n        ordinal: function (number) {\n            var b = number,\n                output = '',\n                lookup = [\n                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed\n                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed\n                ];\n            if (b > 20) {\n                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {\n                    output = 'fed'; // not 30ain, 70ain or 90ain\n                } else {\n                    output = 'ain';\n                }\n            } else if (b > 0) {\n                output = lookup[b];\n            }\n            return number + output;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : danish (da)\n    //! author : Ulrik Nielsen : https://github.com/mrbase\n\n    var da = _moment__default.defineLocale('da', {\n        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),\n        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),\n        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),\n        weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),\n        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY HH:mm',\n            LLLL : 'dddd [d.] D. MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[I dag kl.] LT',\n            nextDay : '[I morgen kl.] LT',\n            nextWeek : 'dddd [kl.] LT',\n            lastDay : '[I gr kl.] LT',\n            lastWeek : '[sidste] dddd [kl] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'om %s',\n            past : '%s siden',\n            s : 'f sekunder',\n            m : 'et minut',\n            mm : '%d minutter',\n            h : 'en time',\n            hh : '%d timer',\n            d : 'en dag',\n            dd : '%d dage',\n            M : 'en mned',\n            MM : '%d mneder',\n            y : 'et r',\n            yy : '%d r'\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : austrian german (de-at)\n    //! author : lluchs : https://github.com/lluchs\n    //! author: Menelion Elensle: https://github.com/Oire\n    //! author : Martin Groller : https://github.com/MadMG\n\n    function de_at__processRelativeTime(number, withoutSuffix, key, isFuture) {\n        var format = {\n            'm': ['eine Minute', 'einer Minute'],\n            'h': ['eine Stunde', 'einer Stunde'],\n            'd': ['ein Tag', 'einem Tag'],\n            'dd': [number + ' Tage', number + ' Tagen'],\n            'M': ['ein Monat', 'einem Monat'],\n            'MM': [number + ' Monate', number + ' Monaten'],\n            'y': ['ein Jahr', 'einem Jahr'],\n            'yy': [number + ' Jahre', number + ' Jahren']\n        };\n        return withoutSuffix ? format[key][0] : format[key][1];\n    }\n\n    var de_at = _moment__default.defineLocale('de-at', {\n        months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),\n        monthsShort : 'Jn._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),\n        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),\n        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),\n        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),\n        longDateFormat : {\n            LT: 'HH:mm',\n            LTS: 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY HH:mm',\n            LLLL : 'dddd, D. MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[Heute um] LT [Uhr]',\n            sameElse: 'L',\n            nextDay: '[Morgen um] LT [Uhr]',\n            nextWeek: 'dddd [um] LT [Uhr]',\n            lastDay: '[Gestern um] LT [Uhr]',\n            lastWeek: '[letzten] dddd [um] LT [Uhr]'\n        },\n        relativeTime : {\n            future : 'in %s',\n            past : 'vor %s',\n            s : 'ein paar Sekunden',\n            m : de_at__processRelativeTime,\n            mm : '%d Minuten',\n            h : de_at__processRelativeTime,\n            hh : '%d Stunden',\n            d : de_at__processRelativeTime,\n            dd : de_at__processRelativeTime,\n            M : de_at__processRelativeTime,\n            MM : de_at__processRelativeTime,\n            y : de_at__processRelativeTime,\n            yy : de_at__processRelativeTime\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : german (de)\n    //! author : lluchs : https://github.com/lluchs\n    //! author: Menelion Elensle: https://github.com/Oire\n\n    function de__processRelativeTime(number, withoutSuffix, key, isFuture) {\n        var format = {\n            'm': ['eine Minute', 'einer Minute'],\n            'h': ['eine Stunde', 'einer Stunde'],\n            'd': ['ein Tag', 'einem Tag'],\n            'dd': [number + ' Tage', number + ' Tagen'],\n            'M': ['ein Monat', 'einem Monat'],\n            'MM': [number + ' Monate', number + ' Monaten'],\n            'y': ['ein Jahr', 'einem Jahr'],\n            'yy': [number + ' Jahre', number + ' Jahren']\n        };\n        return withoutSuffix ? format[key][0] : format[key][1];\n    }\n\n    var de = _moment__default.defineLocale('de', {\n        months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),\n        monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),\n        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),\n        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),\n        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),\n        longDateFormat : {\n            LT: 'HH:mm',\n            LTS: 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY HH:mm',\n            LLLL : 'dddd, D. MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[Heute um] LT [Uhr]',\n            sameElse: 'L',\n            nextDay: '[Morgen um] LT [Uhr]',\n            nextWeek: 'dddd [um] LT [Uhr]',\n            lastDay: '[Gestern um] LT [Uhr]',\n            lastWeek: '[letzten] dddd [um] LT [Uhr]'\n        },\n        relativeTime : {\n            future : 'in %s',\n            past : 'vor %s',\n            s : 'ein paar Sekunden',\n            m : de__processRelativeTime,\n            mm : '%d Minuten',\n            h : de__processRelativeTime,\n            hh : '%d Stunden',\n            d : de__processRelativeTime,\n            dd : de__processRelativeTime,\n            M : de__processRelativeTime,\n            MM : de__processRelativeTime,\n            y : de__processRelativeTime,\n            yy : de__processRelativeTime\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : modern greek (el)\n    //! author : Aggelos Karalias : https://github.com/mehiel\n\n    var el = _moment__default.defineLocale('el', {\n        monthsNominativeEl : '___________'.split('_'),\n        monthsGenitiveEl : '___________'.split('_'),\n        months : function (momentToFormat, format) {\n            if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'\n                return this._monthsGenitiveEl[momentToFormat.month()];\n            } else {\n                return this._monthsNominativeEl[momentToFormat.month()];\n            }\n        },\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        meridiem : function (hours, minutes, isLower) {\n            if (hours > 11) {\n                return isLower ? '' : '';\n            } else {\n                return isLower ? '' : '';\n            }\n        },\n        isPM : function (input) {\n            return ((input + '').toLowerCase()[0] === '');\n        },\n        meridiemParse : /[]\\.??\\.?/i,\n        longDateFormat : {\n            LT : 'h:mm A',\n            LTS : 'h:mm:ss A',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY h:mm A',\n            LLLL : 'dddd, D MMMM YYYY h:mm A'\n        },\n        calendarEl : {\n            sameDay : '[ {}] LT',\n            nextDay : '[ {}] LT',\n            nextWeek : 'dddd [{}] LT',\n            lastDay : '[ {}] LT',\n            lastWeek : function () {\n                switch (this.day()) {\n                    case 6:\n                        return '[ ] dddd [{}] LT';\n                    default:\n                        return '[ ] dddd [{}] LT';\n                }\n            },\n            sameElse : 'L'\n        },\n        calendar : function (key, mom) {\n            var output = this._calendarEl[key],\n                hours = mom && mom.hours();\n            if (typeof output === 'function') {\n                output = output.apply(mom);\n            }\n            return output.replace('{}', (hours % 12 === 1 ? '' : ''));\n        },\n        relativeTime : {\n            future : ' %s',\n            past : '%s ',\n            s : ' ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        ordinalParse: /\\d{1,2}/,\n        ordinal: '%d',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : australian english (en-au)\n\n    var en_au = _moment__default.defineLocale('en-au', {\n        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n        longDateFormat : {\n            LT : 'h:mm A',\n            LTS : 'h:mm:ss A',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY h:mm A',\n            LLLL : 'dddd, D MMMM YYYY h:mm A'\n        },\n        calendar : {\n            sameDay : '[Today at] LT',\n            nextDay : '[Tomorrow at] LT',\n            nextWeek : 'dddd [at] LT',\n            lastDay : '[Yesterday at] LT',\n            lastWeek : '[Last] dddd [at] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'in %s',\n            past : '%s ago',\n            s : 'a few seconds',\n            m : 'a minute',\n            mm : '%d minutes',\n            h : 'an hour',\n            hh : '%d hours',\n            d : 'a day',\n            dd : '%d days',\n            M : 'a month',\n            MM : '%d months',\n            y : 'a year',\n            yy : '%d years'\n        },\n        ordinalParse: /\\d{1,2}(st|nd|rd|th)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (~~(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : canadian english (en-ca)\n    //! author : Jonathan Abourbih : https://github.com/jonbca\n\n    var en_ca = _moment__default.defineLocale('en-ca', {\n        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n        longDateFormat : {\n            LT : 'h:mm A',\n            LTS : 'h:mm:ss A',\n            L : 'YYYY-MM-DD',\n            LL : 'D MMMM, YYYY',\n            LLL : 'D MMMM, YYYY h:mm A',\n            LLLL : 'dddd, D MMMM, YYYY h:mm A'\n        },\n        calendar : {\n            sameDay : '[Today at] LT',\n            nextDay : '[Tomorrow at] LT',\n            nextWeek : 'dddd [at] LT',\n            lastDay : '[Yesterday at] LT',\n            lastWeek : '[Last] dddd [at] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'in %s',\n            past : '%s ago',\n            s : 'a few seconds',\n            m : 'a minute',\n            mm : '%d minutes',\n            h : 'an hour',\n            hh : '%d hours',\n            d : 'a day',\n            dd : '%d days',\n            M : 'a month',\n            MM : '%d months',\n            y : 'a year',\n            yy : '%d years'\n        },\n        ordinalParse: /\\d{1,2}(st|nd|rd|th)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (~~(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : great britain english (en-gb)\n    //! author : Chris Gedrim : https://github.com/chrisgedrim\n\n    var en_gb = _moment__default.defineLocale('en-gb', {\n        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[Today at] LT',\n            nextDay : '[Tomorrow at] LT',\n            nextWeek : 'dddd [at] LT',\n            lastDay : '[Yesterday at] LT',\n            lastWeek : '[Last] dddd [at] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'in %s',\n            past : '%s ago',\n            s : 'a few seconds',\n            m : 'a minute',\n            mm : '%d minutes',\n            h : 'an hour',\n            hh : '%d hours',\n            d : 'a day',\n            dd : '%d days',\n            M : 'a month',\n            MM : '%d months',\n            y : 'a year',\n            yy : '%d years'\n        },\n        ordinalParse: /\\d{1,2}(st|nd|rd|th)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (~~(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : esperanto (eo)\n    //! author : Colin Dean : https://github.com/colindean\n    //! komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.\n    //!          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!\n\n    var eo = _moment__default.defineLocale('eo', {\n        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),\n        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),\n        weekdays : 'Dimano_Lundo_Mardo_Merkredo_ado_Vendredo_Sabato'.split('_'),\n        weekdaysShort : 'Dim_Lun_Mard_Merk_a_Ven_Sab'.split('_'),\n        weekdaysMin : 'Di_Lu_Ma_Me_a_Ve_Sa'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'YYYY-MM-DD',\n            LL : 'D[-an de] MMMM, YYYY',\n            LLL : 'D[-an de] MMMM, YYYY HH:mm',\n            LLLL : 'dddd, [la] D[-an de] MMMM, YYYY HH:mm'\n        },\n        meridiemParse: /[ap]\\.t\\.m/i,\n        isPM: function (input) {\n            return input.charAt(0).toLowerCase() === 'p';\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours > 11) {\n                return isLower ? 'p.t.m.' : 'P.T.M.';\n            } else {\n                return isLower ? 'a.t.m.' : 'A.T.M.';\n            }\n        },\n        calendar : {\n            sameDay : '[Hodia je] LT',\n            nextDay : '[Morga je] LT',\n            nextWeek : 'dddd [je] LT',\n            lastDay : '[Hiera je] LT',\n            lastWeek : '[pasinta] dddd [je] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'je %s',\n            past : 'anta %s',\n            s : 'sekundoj',\n            m : 'minuto',\n            mm : '%d minutoj',\n            h : 'horo',\n            hh : '%d horoj',\n            d : 'tago',//ne 'diurno', ar estas uzita por proksimumo\n            dd : '%d tagoj',\n            M : 'monato',\n            MM : '%d monatoj',\n            y : 'jaro',\n            yy : '%d jaroj'\n        },\n        ordinalParse: /\\d{1,2}a/,\n        ordinal : '%da',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : spanish (es)\n    //! author : Julio Napur : https://github.com/julionc\n\n    var monthsShortDot = 'Ene._Feb._Mar._Abr._May._Jun._Jul._Ago._Sep._Oct._Nov._Dic.'.split('_'),\n        es__monthsShort = 'Ene_Feb_Mar_Abr_May_Jun_Jul_Ago_Sep_Oct_Nov_Dic'.split('_');\n\n    var es = _moment__default.defineLocale('es', {\n        months : 'Enero_Febrero_Marzo_Abril_Mayo_Junio_Julio_Agosto_Septiembre_Octubre_Noviembre_Diciembre'.split('_'),\n        monthsShort : function (m, format) {\n            if (/-MMM-/.test(format)) {\n                return es__monthsShort[m.month()];\n            } else {\n                return monthsShortDot[m.month()];\n            }\n        },\n        weekdays : 'Domingo_Lunes_Martes_Mircoles_Jueves_Viernes_Sbado'.split('_'),\n        weekdaysShort : 'Dom._Lun._Mar._Mi._Jue._Vie._Sb.'.split('_'),\n        weekdaysMin : 'Do_Lu_Ma_Mi_Ju_Vi_S'.split('_'),\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D [de] MMMM [de] YYYY',\n            LLL : 'D [de] MMMM [de] YYYY H:mm',\n            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'\n        },\n        calendar : {\n            sameDay : function () {\n                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            nextDay : function () {\n                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            nextWeek : function () {\n                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            lastDay : function () {\n                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            lastWeek : function () {\n                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'en %s',\n            past : 'hace %s',\n            s : 'unos segundos',\n            m : 'un minuto',\n            mm : '%d minutos',\n            h : 'una hora',\n            hh : '%d horas',\n            d : 'un da',\n            dd : '%d das',\n            M : 'un mes',\n            MM : '%d meses',\n            y : 'un ao',\n            yy : '%d aos'\n        },\n        ordinalParse : /\\d{1,2}/,\n        ordinal : '%d',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : estonian (et)\n    //! author : Henry Kehlmann : https://github.com/madhenry\n    //! improvements : Illimar Tambek : https://github.com/ragulka\n\n    function et__processRelativeTime(number, withoutSuffix, key, isFuture) {\n        var format = {\n            's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],\n            'm' : ['he minuti', 'ks minut'],\n            'mm': [number + ' minuti', number + ' minutit'],\n            'h' : ['he tunni', 'tund aega', 'ks tund'],\n            'hh': [number + ' tunni', number + ' tundi'],\n            'd' : ['he peva', 'ks pev'],\n            'M' : ['kuu aja', 'kuu aega', 'ks kuu'],\n            'MM': [number + ' kuu', number + ' kuud'],\n            'y' : ['he aasta', 'aasta', 'ks aasta'],\n            'yy': [number + ' aasta', number + ' aastat']\n        };\n        if (withoutSuffix) {\n            return format[key][2] ? format[key][2] : format[key][1];\n        }\n        return isFuture ? format[key][0] : format[key][1];\n    }\n\n    var et = _moment__default.defineLocale('et', {\n        months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),\n        monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),\n        weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),\n        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),\n        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),\n        longDateFormat : {\n            LT   : 'H:mm',\n            LTS : 'H:mm:ss',\n            L    : 'DD.MM.YYYY',\n            LL   : 'D. MMMM YYYY',\n            LLL  : 'D. MMMM YYYY H:mm',\n            LLLL : 'dddd, D. MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay  : '[Tna,] LT',\n            nextDay  : '[Homme,] LT',\n            nextWeek : '[Jrgmine] dddd LT',\n            lastDay  : '[Eile,] LT',\n            lastWeek : '[Eelmine] dddd LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s prast',\n            past   : '%s tagasi',\n            s      : et__processRelativeTime,\n            m      : et__processRelativeTime,\n            mm     : et__processRelativeTime,\n            h      : et__processRelativeTime,\n            hh     : et__processRelativeTime,\n            d      : et__processRelativeTime,\n            dd     : '%d peva',\n            M      : et__processRelativeTime,\n            MM     : et__processRelativeTime,\n            y      : et__processRelativeTime,\n            yy     : et__processRelativeTime\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : euskara (eu)\n    //! author : Eneko Illarramendi : https://github.com/eillarra\n\n    var eu = _moment__default.defineLocale('eu', {\n        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),\n        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),\n        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),\n        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),\n        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'YYYY-MM-DD',\n            LL : 'YYYY[ko] MMMM[ren] D[a]',\n            LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',\n            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',\n            l : 'YYYY-M-D',\n            ll : 'YYYY[ko] MMM D[a]',\n            lll : 'YYYY[ko] MMM D[a] HH:mm',\n            llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'\n        },\n        calendar : {\n            sameDay : '[gaur] LT[etan]',\n            nextDay : '[bihar] LT[etan]',\n            nextWeek : 'dddd LT[etan]',\n            lastDay : '[atzo] LT[etan]',\n            lastWeek : '[aurreko] dddd LT[etan]',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s barru',\n            past : 'duela %s',\n            s : 'segundo batzuk',\n            m : 'minutu bat',\n            mm : '%d minutu',\n            h : 'ordu bat',\n            hh : '%d ordu',\n            d : 'egun bat',\n            dd : '%d egun',\n            M : 'hilabete bat',\n            MM : '%d hilabete',\n            y : 'urte bat',\n            yy : '%d urte'\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Persian (fa)\n    //! author : Ebrahim Byagowi : https://github.com/ebraminio\n\n    var fa__symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    }, fa__numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var fa = _moment__default.defineLocale('fa', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '\\u200c__\\u200c__\\u200c__'.split('_'),\n        weekdaysShort : '\\u200c__\\u200c__\\u200c__'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        meridiemParse: /  |  /,\n        isPM: function (input) {\n            return /  /.test(input);\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 12) {\n                return '  ';\n            } else {\n                return '  ';\n            }\n        },\n        calendar : {\n            sameDay : '[ ] LT',\n            nextDay : '[ ] LT',\n            nextWeek : 'dddd [] LT',\n            lastDay : '[ ] LT',\n            lastWeek : 'dddd [] [] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : '%s ',\n            s : ' ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        preparse: function (string) {\n            return string.replace(/[-]/g, function (match) {\n                return fa__numberMap[match];\n            }).replace(//g, ',');\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return fa__symbolMap[match];\n            }).replace(/,/g, '');\n        },\n        ordinalParse: /\\d{1,2}/,\n        ordinal : '%d',\n        week : {\n            dow : 6, // Saturday is the first day of the week.\n            doy : 12 // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : finnish (fi)\n    //! author : Tarmo Aidantausta : https://github.com/bleadof\n\n    var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),\n        numbersFuture = [\n            'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',\n            numbersPast[7], numbersPast[8], numbersPast[9]\n        ];\n    function fi__translate(number, withoutSuffix, key, isFuture) {\n        var result = '';\n        switch (key) {\n        case 's':\n            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';\n        case 'm':\n            return isFuture ? 'minuutin' : 'minuutti';\n        case 'mm':\n            result = isFuture ? 'minuutin' : 'minuuttia';\n            break;\n        case 'h':\n            return isFuture ? 'tunnin' : 'tunti';\n        case 'hh':\n            result = isFuture ? 'tunnin' : 'tuntia';\n            break;\n        case 'd':\n            return isFuture ? 'pivn' : 'piv';\n        case 'dd':\n            result = isFuture ? 'pivn' : 'piv';\n            break;\n        case 'M':\n            return isFuture ? 'kuukauden' : 'kuukausi';\n        case 'MM':\n            result = isFuture ? 'kuukauden' : 'kuukautta';\n            break;\n        case 'y':\n            return isFuture ? 'vuoden' : 'vuosi';\n        case 'yy':\n            result = isFuture ? 'vuoden' : 'vuotta';\n            break;\n        }\n        result = verbalNumber(number, isFuture) + ' ' + result;\n        return result;\n    }\n    function verbalNumber(number, isFuture) {\n        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;\n    }\n\n    var fi = _moment__default.defineLocale('fi', {\n        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),\n        monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),\n        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),\n        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),\n        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),\n        longDateFormat : {\n            LT : 'HH.mm',\n            LTS : 'HH.mm.ss',\n            L : 'DD.MM.YYYY',\n            LL : 'Do MMMM[ta] YYYY',\n            LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',\n            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',\n            l : 'D.M.YYYY',\n            ll : 'Do MMM YYYY',\n            lll : 'Do MMM YYYY, [klo] HH.mm',\n            llll : 'ddd, Do MMM YYYY, [klo] HH.mm'\n        },\n        calendar : {\n            sameDay : '[tnn] [klo] LT',\n            nextDay : '[huomenna] [klo] LT',\n            nextWeek : 'dddd [klo] LT',\n            lastDay : '[eilen] [klo] LT',\n            lastWeek : '[viime] dddd[na] [klo] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s pst',\n            past : '%s sitten',\n            s : fi__translate,\n            m : fi__translate,\n            mm : fi__translate,\n            h : fi__translate,\n            hh : fi__translate,\n            d : fi__translate,\n            dd : fi__translate,\n            M : fi__translate,\n            MM : fi__translate,\n            y : fi__translate,\n            yy : fi__translate\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : faroese (fo)\n    //! author : Ragnar Johannesen : https://github.com/ragnar123\n\n    var fo = _moment__default.defineLocale('fo', {\n        months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),\n        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),\n        weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),\n        weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),\n        weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D. MMMM, YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[ dag kl.] LT',\n            nextDay : '[ morgin kl.] LT',\n            nextWeek : 'dddd [kl.] LT',\n            lastDay : '[ gjr kl.] LT',\n            lastWeek : '[sstu] dddd [kl] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'um %s',\n            past : '%s sani',\n            s : 'f sekund',\n            m : 'ein minutt',\n            mm : '%d minuttir',\n            h : 'ein tmi',\n            hh : '%d tmar',\n            d : 'ein dagur',\n            dd : '%d dagar',\n            M : 'ein mnai',\n            MM : '%d mnair',\n            y : 'eitt r',\n            yy : '%d r'\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : canadian french (fr-ca)\n    //! author : Jonathan Abourbih : https://github.com/jonbca\n\n    var fr_ca = _moment__default.defineLocale('fr-ca', {\n        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),\n        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),\n        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),\n        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),\n        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'YYYY-MM-DD',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[Aujourd\\'hui ] LT',\n            nextDay: '[Demain ] LT',\n            nextWeek: 'dddd [] LT',\n            lastDay: '[Hier ] LT',\n            lastWeek: 'dddd [dernier ] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'dans %s',\n            past : 'il y a %s',\n            s : 'quelques secondes',\n            m : 'une minute',\n            mm : '%d minutes',\n            h : 'une heure',\n            hh : '%d heures',\n            d : 'un jour',\n            dd : '%d jours',\n            M : 'un mois',\n            MM : '%d mois',\n            y : 'un an',\n            yy : '%d ans'\n        },\n        ordinalParse: /\\d{1,2}(er|e)/,\n        ordinal : function (number) {\n            return number + (number === 1 ? 'er' : 'e');\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : french (fr)\n    //! author : John Fischer : https://github.com/jfroffice\n\n    var fr = _moment__default.defineLocale('fr', {\n        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),\n        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),\n        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),\n        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),\n        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[Aujourd\\'hui ] LT',\n            nextDay: '[Demain ] LT',\n            nextWeek: 'dddd [] LT',\n            lastDay: '[Hier ] LT',\n            lastWeek: 'dddd [dernier ] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'dans %s',\n            past : 'il y a %s',\n            s : 'quelques secondes',\n            m : 'une minute',\n            mm : '%d minutes',\n            h : 'une heure',\n            hh : '%d heures',\n            d : 'un jour',\n            dd : '%d jours',\n            M : 'un mois',\n            MM : '%d mois',\n            y : 'un an',\n            yy : '%d ans'\n        },\n        ordinalParse: /\\d{1,2}(er|)/,\n        ordinal : function (number) {\n            return number + (number === 1 ? 'er' : '');\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : frisian (fy)\n    //! author : Robin van der Vliet : https://github.com/robin0van0der0v\n\n    var fy__monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),\n        fy__monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');\n\n    var fy = _moment__default.defineLocale('fy', {\n        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),\n        monthsShort : function (m, format) {\n            if (/-MMM-/.test(format)) {\n                return fy__monthsShortWithoutDots[m.month()];\n            } else {\n                return fy__monthsShortWithDots[m.month()];\n            }\n        },\n        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),\n        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),\n        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD-MM-YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[hjoed om] LT',\n            nextDay: '[moarn om] LT',\n            nextWeek: 'dddd [om] LT',\n            lastDay: '[juster om] LT',\n            lastWeek: '[frne] dddd [om] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'oer %s',\n            past : '%s lyn',\n            s : 'in pear sekonden',\n            m : 'ien mint',\n            mm : '%d minuten',\n            h : 'ien oere',\n            hh : '%d oeren',\n            d : 'ien dei',\n            dd : '%d dagen',\n            M : 'ien moanne',\n            MM : '%d moannen',\n            y : 'ien jier',\n            yy : '%d jierren'\n        },\n        ordinalParse: /\\d{1,2}(ste|de)/,\n        ordinal : function (number) {\n            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : galician (gl)\n    //! author : Juan G. Hurtado : https://github.com/juanghurtado\n\n    var gl = _moment__default.defineLocale('gl', {\n        months : 'Xaneiro_Febreiro_Marzo_Abril_Maio_Xuo_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro'.split('_'),\n        monthsShort : 'Xan._Feb._Mar._Abr._Mai._Xu._Xul._Ago._Set._Out._Nov._Dec.'.split('_'),\n        weekdays : 'Domingo_Luns_Martes_Mrcores_Xoves_Venres_Sbado'.split('_'),\n        weekdaysShort : 'Dom._Lun._Mar._Mr._Xov._Ven._Sb.'.split('_'),\n        weekdaysMin : 'Do_Lu_Ma_M_Xo_Ve_S'.split('_'),\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY H:mm',\n            LLLL : 'dddd D MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay : function () {\n                return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            nextDay : function () {\n                return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';\n            },\n            nextWeek : function () {\n                return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';\n            },\n            lastDay : function () {\n                return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';\n            },\n            lastWeek : function () {\n                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : function (str) {\n                if (str === 'uns segundos') {\n                    return 'nuns segundos';\n                }\n                return 'en ' + str;\n            },\n            past : 'hai %s',\n            s : 'uns segundos',\n            m : 'un minuto',\n            mm : '%d minutos',\n            h : 'unha hora',\n            hh : '%d horas',\n            d : 'un da',\n            dd : '%d das',\n            M : 'un mes',\n            MM : '%d meses',\n            y : 'un ano',\n            yy : '%d anos'\n        },\n        ordinalParse : /\\d{1,2}/,\n        ordinal : '%d',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Hebrew (he)\n    //! author : Tomer Cohen : https://github.com/tomer\n    //! author : Moshe Simantov : https://github.com/DevelopmentIL\n    //! author : Tal Ater : https://github.com/TalAter\n\n    var he = _moment__default.defineLocale('he', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D []MMMM YYYY',\n            LLL : 'D []MMMM YYYY HH:mm',\n            LLLL : 'dddd, D []MMMM YYYY HH:mm',\n            l : 'D/M/YYYY',\n            ll : 'D MMM YYYY',\n            lll : 'D MMM YYYY HH:mm',\n            llll : 'ddd, D MMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[ ]LT',\n            nextDay : '[ ]LT',\n            nextWeek : 'dddd [] LT',\n            lastDay : '[ ]LT',\n            lastWeek : '[] dddd [ ] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : ' %s',\n            s : ' ',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : function (number) {\n                if (number === 2) {\n                    return '';\n                }\n                return number + ' ';\n            },\n            d : '',\n            dd : function (number) {\n                if (number === 2) {\n                    return '';\n                }\n                return number + ' ';\n            },\n            M : '',\n            MM : function (number) {\n                if (number === 2) {\n                    return '';\n                }\n                return number + ' ';\n            },\n            y : '',\n            yy : function (number) {\n                if (number === 2) {\n                    return '';\n                } else if (number % 10 === 0 && number !== 10) {\n                    return number + ' ';\n                }\n                return number + ' ';\n            }\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : hindi (hi)\n    //! author : Mayank Singhal : https://github.com/mayanksinghal\n\n    var hi__symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    },\n    hi__numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var hi = _moment__default.defineLocale('hi', {\n        months : '___________'.split('_'),\n        monthsShort : '._.__.___._._._._._.'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'A h:mm ',\n            LTS : 'A h:mm:ss ',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY, A h:mm ',\n            LLLL : 'dddd, D MMMM YYYY, A h:mm '\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : 'dddd, LT',\n            lastDay : '[] LT',\n            lastWeek : '[] dddd, LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : '  ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return hi__numberMap[match];\n            });\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return hi__symbolMap[match];\n            });\n        },\n        // Hindi notation for meridiems are quite fuzzy in practice. While there exists\n        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.\n        meridiemParse: /|||/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '') {\n                return hour < 4 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour;\n            } else if (meridiem === '') {\n                return hour >= 10 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 10) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else if (hour < 20) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : hrvatski (hr)\n    //! author : Bojan Markovi : https://github.com/bmarkovic\n\n    function hr__translate(number, withoutSuffix, key) {\n        var result = number + ' ';\n        switch (key) {\n        case 'm':\n            return withoutSuffix ? 'jedna minuta' : 'jedne minute';\n        case 'mm':\n            if (number === 1) {\n                result += 'minuta';\n            } else if (number === 2 || number === 3 || number === 4) {\n                result += 'minute';\n            } else {\n                result += 'minuta';\n            }\n            return result;\n        case 'h':\n            return withoutSuffix ? 'jedan sat' : 'jednog sata';\n        case 'hh':\n            if (number === 1) {\n                result += 'sat';\n            } else if (number === 2 || number === 3 || number === 4) {\n                result += 'sata';\n            } else {\n                result += 'sati';\n            }\n            return result;\n        case 'dd':\n            if (number === 1) {\n                result += 'dan';\n            } else {\n                result += 'dana';\n            }\n            return result;\n        case 'MM':\n            if (number === 1) {\n                result += 'mjesec';\n            } else if (number === 2 || number === 3 || number === 4) {\n                result += 'mjeseca';\n            } else {\n                result += 'mjeseci';\n            }\n            return result;\n        case 'yy':\n            if (number === 1) {\n                result += 'godina';\n            } else if (number === 2 || number === 3 || number === 4) {\n                result += 'godine';\n            } else {\n                result += 'godina';\n            }\n            return result;\n        }\n    }\n\n    var hr = _moment__default.defineLocale('hr', {\n        months : 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_'),\n        monthsShort : 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),\n        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),\n        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),\n        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD. MM. YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY H:mm',\n            LLLL : 'dddd, D. MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay  : '[danas u] LT',\n            nextDay  : '[sutra u] LT',\n            nextWeek : function () {\n                switch (this.day()) {\n                case 0:\n                    return '[u] [nedjelju] [u] LT';\n                case 3:\n                    return '[u] [srijedu] [u] LT';\n                case 6:\n                    return '[u] [subotu] [u] LT';\n                case 1:\n                case 2:\n                case 4:\n                case 5:\n                    return '[u] dddd [u] LT';\n                }\n            },\n            lastDay  : '[juer u] LT',\n            lastWeek : function () {\n                switch (this.day()) {\n                case 0:\n                case 3:\n                    return '[prolu] dddd [u] LT';\n                case 6:\n                    return '[prole] [subote] [u] LT';\n                case 1:\n                case 2:\n                case 4:\n                case 5:\n                    return '[proli] dddd [u] LT';\n                }\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'za %s',\n            past   : 'prije %s',\n            s      : 'par sekundi',\n            m      : hr__translate,\n            mm     : hr__translate,\n            h      : hr__translate,\n            hh     : hr__translate,\n            d      : 'dan',\n            dd     : hr__translate,\n            M      : 'mjesec',\n            MM     : hr__translate,\n            y      : 'godinu',\n            yy     : hr__translate\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : hungarian (hu)\n    //! author : Adam Brunner : https://github.com/adambrunner\n\n    var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');\n    function hu__translate(number, withoutSuffix, key, isFuture) {\n        var num = number,\n            suffix;\n        switch (key) {\n        case 's':\n            return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';\n        case 'm':\n            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');\n        case 'mm':\n            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');\n        case 'h':\n            return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');\n        case 'hh':\n            return num + (isFuture || withoutSuffix ? ' ra' : ' rja');\n        case 'd':\n            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');\n        case 'dd':\n            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');\n        case 'M':\n            return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');\n        case 'MM':\n            return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');\n        case 'y':\n            return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');\n        case 'yy':\n            return num + (isFuture || withoutSuffix ? ' v' : ' ve');\n        }\n        return '';\n    }\n    function week(isFuture) {\n        return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';\n    }\n\n    var hu = _moment__default.defineLocale('hu', {\n        months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),\n        monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),\n        weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),\n        weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),\n        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'YYYY.MM.DD.',\n            LL : 'YYYY. MMMM D.',\n            LLL : 'YYYY. MMMM D. H:mm',\n            LLLL : 'YYYY. MMMM D., dddd H:mm'\n        },\n        meridiemParse: /de|du/i,\n        isPM: function (input) {\n            return input.charAt(1).toLowerCase() === 'u';\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours < 12) {\n                return isLower === true ? 'de' : 'DE';\n            } else {\n                return isLower === true ? 'du' : 'DU';\n            }\n        },\n        calendar : {\n            sameDay : '[ma] LT[-kor]',\n            nextDay : '[holnap] LT[-kor]',\n            nextWeek : function () {\n                return week.call(this, true);\n            },\n            lastDay : '[tegnap] LT[-kor]',\n            lastWeek : function () {\n                return week.call(this, false);\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s mlva',\n            past : '%s',\n            s : hu__translate,\n            m : hu__translate,\n            mm : hu__translate,\n            h : hu__translate,\n            hh : hu__translate,\n            d : hu__translate,\n            dd : hu__translate,\n            M : hu__translate,\n            MM : hu__translate,\n            y : hu__translate,\n            yy : hu__translate\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Armenian (hy-am)\n    //! author : Armendarabyan : https://github.com/armendarabyan\n\n    function hy_am__monthsCaseReplace(m, format) {\n        var months = {\n            'nominative': '___________'.split('_'),\n            'accusative': '___________'.split('_')\n        },\n        nounCase = (/D[oD]?(\\[[^\\[\\]]*\\]|\\s+)+MMMM?/).test(format) ?\n            'accusative' :\n            'nominative';\n        return months[nounCase][m.month()];\n    }\n    function hy_am__monthsShortCaseReplace(m, format) {\n        var monthsShort = '___________'.split('_');\n        return monthsShort[m.month()];\n    }\n    function hy_am__weekdaysCaseReplace(m, format) {\n        var weekdays = '______'.split('_');\n        return weekdays[m.day()];\n    }\n\n    var hy_am = _moment__default.defineLocale('hy-am', {\n        months : hy_am__monthsCaseReplace,\n        monthsShort : hy_am__monthsShortCaseReplace,\n        weekdays : hy_am__weekdaysCaseReplace,\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY .',\n            LLL : 'D MMMM YYYY ., HH:mm',\n            LLLL : 'dddd, D MMMM YYYY ., HH:mm'\n        },\n        calendar : {\n            sameDay: '[] LT',\n            nextDay: '[] LT',\n            lastDay: '[] LT',\n            nextWeek: function () {\n                return 'dddd [ ] LT';\n            },\n            lastWeek: function () {\n                return '[] dddd [ ] LT';\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : '  ',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d ',\n            M : '',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        meridiemParse: /|||/,\n        isPM: function (input) {\n            return /^(|)$/.test(input);\n        },\n        meridiem : function (hour) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 12) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        ordinalParse: /\\d{1,2}|\\d{1,2}-(|)/,\n        ordinal: function (number, period) {\n            switch (period) {\n            case 'DDD':\n            case 'w':\n            case 'W':\n            case 'DDDo':\n                if (number === 1) {\n                    return number + '-';\n                }\n                return number + '-';\n            default:\n                return number;\n            }\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Bahasa Indonesia (id)\n    //! author : Mohammad Satrio Utomo : https://github.com/tyok\n    //! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan\n\n    var id = _moment__default.defineLocale('id', {\n        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),\n        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),\n        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),\n        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),\n        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),\n        longDateFormat : {\n            LT : 'HH.mm',\n            LTS : 'HH.mm.ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY [pukul] HH.mm',\n            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'\n        },\n        meridiemParse: /pagi|siang|sore|malam/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === 'pagi') {\n                return hour;\n            } else if (meridiem === 'siang') {\n                return hour >= 11 ? hour : hour + 12;\n            } else if (meridiem === 'sore' || meridiem === 'malam') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours < 11) {\n                return 'pagi';\n            } else if (hours < 15) {\n                return 'siang';\n            } else if (hours < 19) {\n                return 'sore';\n            } else {\n                return 'malam';\n            }\n        },\n        calendar : {\n            sameDay : '[Hari ini pukul] LT',\n            nextDay : '[Besok pukul] LT',\n            nextWeek : 'dddd [pukul] LT',\n            lastDay : '[Kemarin pukul] LT',\n            lastWeek : 'dddd [lalu pukul] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'dalam %s',\n            past : '%s yang lalu',\n            s : 'beberapa detik',\n            m : 'semenit',\n            mm : '%d menit',\n            h : 'sejam',\n            hh : '%d jam',\n            d : 'sehari',\n            dd : '%d hari',\n            M : 'sebulan',\n            MM : '%d bulan',\n            y : 'setahun',\n            yy : '%d tahun'\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : icelandic (is)\n    //! author : Hinrik rn Sigursson : https://github.com/hinrik\n\n    function is__plural(n) {\n        if (n % 100 === 11) {\n            return true;\n        } else if (n % 10 === 1) {\n            return false;\n        }\n        return true;\n    }\n    function is__translate(number, withoutSuffix, key, isFuture) {\n        var result = number + ' ';\n        switch (key) {\n        case 's':\n            return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';\n        case 'm':\n            return withoutSuffix ? 'mnta' : 'mntu';\n        case 'mm':\n            if (is__plural(number)) {\n                return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');\n            } else if (withoutSuffix) {\n                return result + 'mnta';\n            }\n            return result + 'mntu';\n        case 'hh':\n            if (is__plural(number)) {\n                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');\n            }\n            return result + 'klukkustund';\n        case 'd':\n            if (withoutSuffix) {\n                return 'dagur';\n            }\n            return isFuture ? 'dag' : 'degi';\n        case 'dd':\n            if (is__plural(number)) {\n                if (withoutSuffix) {\n                    return result + 'dagar';\n                }\n                return result + (isFuture ? 'daga' : 'dgum');\n            } else if (withoutSuffix) {\n                return result + 'dagur';\n            }\n            return result + (isFuture ? 'dag' : 'degi');\n        case 'M':\n            if (withoutSuffix) {\n                return 'mnuur';\n            }\n            return isFuture ? 'mnu' : 'mnui';\n        case 'MM':\n            if (is__plural(number)) {\n                if (withoutSuffix) {\n                    return result + 'mnuir';\n                }\n                return result + (isFuture ? 'mnui' : 'mnuum');\n            } else if (withoutSuffix) {\n                return result + 'mnuur';\n            }\n            return result + (isFuture ? 'mnu' : 'mnui');\n        case 'y':\n            return withoutSuffix || isFuture ? 'r' : 'ri';\n        case 'yy':\n            if (is__plural(number)) {\n                return result + (withoutSuffix || isFuture ? 'r' : 'rum');\n            }\n            return result + (withoutSuffix || isFuture ? 'r' : 'ri');\n        }\n    }\n\n    var is = _moment__default.defineLocale('is', {\n        months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),\n        monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),\n        weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),\n        weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),\n        weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY [kl.] H:mm',\n            LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'\n        },\n        calendar : {\n            sameDay : '[ dag kl.] LT',\n            nextDay : '[ morgun kl.] LT',\n            nextWeek : 'dddd [kl.] LT',\n            lastDay : '[ gr kl.] LT',\n            lastWeek : '[sasta] dddd [kl.] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'eftir %s',\n            past : 'fyrir %s san',\n            s : is__translate,\n            m : is__translate,\n            mm : is__translate,\n            h : 'klukkustund',\n            hh : is__translate,\n            d : is__translate,\n            dd : is__translate,\n            M : is__translate,\n            MM : is__translate,\n            y : is__translate,\n            yy : is__translate\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : italian (it)\n    //! author : Lorenzo : https://github.com/aliem\n    //! author: Mattia Larentis: https://github.com/nostalgiaz\n\n    var it = _moment__default.defineLocale('it', {\n        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),\n        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),\n        weekdays : 'Domenica_Luned_Marted_Mercoled_Gioved_Venerd_Sabato'.split('_'),\n        weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),\n        weekdaysMin : 'D_L_Ma_Me_G_V_S'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[Oggi alle] LT',\n            nextDay: '[Domani alle] LT',\n            nextWeek: 'dddd [alle] LT',\n            lastDay: '[Ieri alle] LT',\n            lastWeek: function () {\n                switch (this.day()) {\n                    case 0:\n                        return '[la scorsa] dddd [alle] LT';\n                    default:\n                        return '[lo scorso] dddd [alle] LT';\n                }\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : function (s) {\n                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;\n            },\n            past : '%s fa',\n            s : 'alcuni secondi',\n            m : 'un minuto',\n            mm : '%d minuti',\n            h : 'un\\'ora',\n            hh : '%d ore',\n            d : 'un giorno',\n            dd : '%d giorni',\n            M : 'un mese',\n            MM : '%d mesi',\n            y : 'un anno',\n            yy : '%d anni'\n        },\n        ordinalParse : /\\d{1,2}/,\n        ordinal: '%d',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : japanese (ja)\n    //! author : LI Long : https://github.com/baryon\n\n    var ja = _moment__default.defineLocale('ja', {\n        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'Ahm',\n            LTS : 'Ahms',\n            L : 'YYYY/MM/DD',\n            LL : 'YYYYMD',\n            LLL : 'YYYYMDAhm',\n            LLLL : 'YYYYMDAhm dddd'\n        },\n        meridiemParse: /|/i,\n        isPM : function (input) {\n            return input === '';\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 12) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : '[]dddd LT',\n            lastDay : '[] LT',\n            lastWeek : '[]dddd LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s',\n            past : '%s',\n            s : '',\n            m : '1',\n            mm : '%d',\n            h : '1',\n            hh : '%d',\n            d : '1',\n            dd : '%d',\n            M : '1',\n            MM : '%d',\n            y : '1',\n            yy : '%d'\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Boso Jowo (jv)\n    //! author : Rony Lantip : https://github.com/lantip\n    //! reference: http://jv.wikipedia.org/wiki/Basa_Jawa\n\n    var jv = _moment__default.defineLocale('jv', {\n        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),\n        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),\n        weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),\n        weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),\n        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),\n        longDateFormat : {\n            LT : 'HH.mm',\n            LTS : 'HH.mm.ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY [pukul] HH.mm',\n            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'\n        },\n        meridiemParse: /enjing|siyang|sonten|ndalu/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === 'enjing') {\n                return hour;\n            } else if (meridiem === 'siyang') {\n                return hour >= 11 ? hour : hour + 12;\n            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours < 11) {\n                return 'enjing';\n            } else if (hours < 15) {\n                return 'siyang';\n            } else if (hours < 19) {\n                return 'sonten';\n            } else {\n                return 'ndalu';\n            }\n        },\n        calendar : {\n            sameDay : '[Dinten puniko pukul] LT',\n            nextDay : '[Mbenjang pukul] LT',\n            nextWeek : 'dddd [pukul] LT',\n            lastDay : '[Kala wingi pukul] LT',\n            lastWeek : 'dddd [kepengker pukul] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'wonten ing %s',\n            past : '%s ingkang kepengker',\n            s : 'sawetawis detik',\n            m : 'setunggal menit',\n            mm : '%d menit',\n            h : 'setunggal jam',\n            hh : '%d jam',\n            d : 'sedinten',\n            dd : '%d dinten',\n            M : 'sewulan',\n            MM : '%d wulan',\n            y : 'setaun',\n            yy : '%d taun'\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Georgian (ka)\n    //! author : Irakli Janiashvili : https://github.com/irakli-janiashvili\n\n    function ka__monthsCaseReplace(m, format) {\n        var months = {\n            'nominative': '___________'.split('_'),\n            'accusative': '___________'.split('_')\n        },\n        nounCase = (/D[oD] *MMMM?/).test(format) ?\n            'accusative' :\n            'nominative';\n        return months[nounCase][m.month()];\n    }\n    function ka__weekdaysCaseReplace(m, format) {\n        var weekdays = {\n            'nominative': '______'.split('_'),\n            'accusative': '______'.split('_')\n        },\n        nounCase = (/(|)/).test(format) ?\n            'accusative' :\n            'nominative';\n        return weekdays[nounCase][m.day()];\n    }\n\n    var ka = _moment__default.defineLocale('ka', {\n        months : ka__monthsCaseReplace,\n        monthsShort : '___________'.split('_'),\n        weekdays : ka__weekdaysCaseReplace,\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'h:mm A',\n            LTS : 'h:mm:ss A',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY h:mm A',\n            LLLL : 'dddd, D MMMM YYYY h:mm A'\n        },\n        calendar : {\n            sameDay : '[] LT[-]',\n            nextDay : '[] LT[-]',\n            lastDay : '[] LT[-]',\n            nextWeek : '[] dddd LT[-]',\n            lastWeek : '[] dddd LT-',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : function (s) {\n                return (/(|||)/).test(s) ?\n                    s.replace(/$/, '') :\n                    s + '';\n            },\n            past : function (s) {\n                if ((/(||||)/).test(s)) {\n                    return s.replace(/(|)$/, ' ');\n                }\n                if ((//).test(s)) {\n                    return s.replace(/$/, ' ');\n                }\n            },\n            s : ' ',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d ',\n            M : '',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        ordinalParse: /0|1-|-\\d{1,2}|\\d{1,2}-/,\n        ordinal : function (number) {\n            if (number === 0) {\n                return number;\n            }\n            if (number === 1) {\n                return number + '-';\n            }\n            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {\n                return '-' + number;\n            }\n            return number + '-';\n        },\n        week : {\n            dow : 1,\n            doy : 7\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : khmer (km)\n    //! author : Kruy Vanna : https://github.com/kruyvanna\n\n    var km = _moment__default.defineLocale('km', {\n        months: '___________'.split('_'),\n        monthsShort: '___________'.split('_'),\n        weekdays: '______'.split('_'),\n        weekdaysShort: '______'.split('_'),\n        weekdaysMin: '______'.split('_'),\n        longDateFormat: {\n            LT: 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L: 'DD/MM/YYYY',\n            LL: 'D MMMM YYYY',\n            LLL: 'D MMMM YYYY HH:mm',\n            LLLL: 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar: {\n            sameDay: '[ ] LT',\n            nextDay: '[ ] LT',\n            nextWeek: 'dddd [] LT',\n            lastDay: '[ ] LT',\n            lastWeek: 'dddd [] [] LT',\n            sameElse: 'L'\n        },\n        relativeTime: {\n            future: '%s',\n            past: '%s',\n            s: '',\n            m: '',\n            mm: '%d ',\n            h: '',\n            hh: '%d ',\n            d: '',\n            dd: '%d ',\n            M: '',\n            MM: '%d ',\n            y: '',\n            yy: '%d '\n        },\n        week: {\n            dow: 1, // Monday is the first day of the week.\n            doy: 4 // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : korean (ko)\n    //!\n    //! authors\n    //!\n    //! - Kyungwook, Park : https://github.com/kyungw00k\n    //! - Jeeeyul Lee <jeeeyul@gmail.com>\n\n    var ko = _moment__default.defineLocale('ko', {\n        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'A h m',\n            LTS : 'A h m s',\n            L : 'YYYY.MM.DD',\n            LL : 'YYYY MMMM D',\n            LLL : 'YYYY MMMM D A h m',\n            LLLL : 'YYYY MMMM D dddd A h m'\n        },\n        calendar : {\n            sameDay : ' LT',\n            nextDay : ' LT',\n            nextWeek : 'dddd LT',\n            lastDay : ' LT',\n            lastWeek : ' dddd LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : '',\n            ss : '%d',\n            m : '',\n            mm : '%d',\n            h : '',\n            hh : '%d',\n            d : '',\n            dd : '%d',\n            M : '',\n            MM : '%d',\n            y : '',\n            yy : '%d'\n        },\n        ordinalParse : /\\d{1,2}/,\n        ordinal : '%d',\n        meridiemParse : /|/,\n        isPM : function (token) {\n            return token === '';\n        },\n        meridiem : function (hour, minute, isUpper) {\n            return hour < 12 ? '' : '';\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Luxembourgish (lb)\n    //! author : mweimerskirch : https://github.com/mweimerskirch, David Raison : https://github.com/kwisatz\n\n    function lb__processRelativeTime(number, withoutSuffix, key, isFuture) {\n        var format = {\n            'm': ['eng Minutt', 'enger Minutt'],\n            'h': ['eng Stonn', 'enger Stonn'],\n            'd': ['een Dag', 'engem Dag'],\n            'M': ['ee Mount', 'engem Mount'],\n            'y': ['ee Joer', 'engem Joer']\n        };\n        return withoutSuffix ? format[key][0] : format[key][1];\n    }\n    function processFutureTime(string) {\n        var number = string.substr(0, string.indexOf(' '));\n        if (eifelerRegelAppliesToNumber(number)) {\n            return 'a ' + string;\n        }\n        return 'an ' + string;\n    }\n    function processPastTime(string) {\n        var number = string.substr(0, string.indexOf(' '));\n        if (eifelerRegelAppliesToNumber(number)) {\n            return 'viru ' + string;\n        }\n        return 'virun ' + string;\n    }\n    /**\n     * Returns true if the word before the given number loses the '-n' ending.\n     * e.g. 'an 10 Deeg' but 'a 5 Deeg'\n     *\n     * @param number {integer}\n     * @returns {boolean}\n     */\n    function eifelerRegelAppliesToNumber(number) {\n        number = parseInt(number, 10);\n        if (isNaN(number)) {\n            return false;\n        }\n        if (number < 0) {\n            // Negative Number --> always true\n            return true;\n        } else if (number < 10) {\n            // Only 1 digit\n            if (4 <= number && number <= 7) {\n                return true;\n            }\n            return false;\n        } else if (number < 100) {\n            // 2 digits\n            var lastDigit = number % 10, firstDigit = number / 10;\n            if (lastDigit === 0) {\n                return eifelerRegelAppliesToNumber(firstDigit);\n            }\n            return eifelerRegelAppliesToNumber(lastDigit);\n        } else if (number < 10000) {\n            // 3 or 4 digits --> recursively check first digit\n            while (number >= 10) {\n                number = number / 10;\n            }\n            return eifelerRegelAppliesToNumber(number);\n        } else {\n            // Anything larger than 4 digits: recursively check first n-3 digits\n            number = number / 1000;\n            return eifelerRegelAppliesToNumber(number);\n        }\n    }\n\n    var lb = _moment__default.defineLocale('lb', {\n        months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),\n        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),\n        weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),\n        weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),\n        weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),\n        longDateFormat: {\n            LT: 'H:mm [Auer]',\n            LTS: 'H:mm:ss [Auer]',\n            L: 'DD.MM.YYYY',\n            LL: 'D. MMMM YYYY',\n            LLL: 'D. MMMM YYYY H:mm [Auer]',\n            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'\n        },\n        calendar: {\n            sameDay: '[Haut um] LT',\n            sameElse: 'L',\n            nextDay: '[Muer um] LT',\n            nextWeek: 'dddd [um] LT',\n            lastDay: '[Gschter um] LT',\n            lastWeek: function () {\n                // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule\n                switch (this.day()) {\n                    case 2:\n                    case 4:\n                        return '[Leschten] dddd [um] LT';\n                    default:\n                        return '[Leschte] dddd [um] LT';\n                }\n            }\n        },\n        relativeTime : {\n            future : processFutureTime,\n            past : processPastTime,\n            s : 'e puer Sekonnen',\n            m : lb__processRelativeTime,\n            mm : '%d Minutten',\n            h : lb__processRelativeTime,\n            hh : '%d Stonnen',\n            d : lb__processRelativeTime,\n            dd : '%d Deeg',\n            M : lb__processRelativeTime,\n            MM : '%d Mint',\n            y : lb__processRelativeTime,\n            yy : '%d Joer'\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal: '%d.',\n        week: {\n            dow: 1, // Monday is the first day of the week.\n            doy: 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Lithuanian (lt)\n    //! author : Mindaugas Mozras : https://github.com/mmozuras\n\n    var lt__units = {\n        'm' : 'minut_minuts_minut',\n        'mm': 'minuts_minui_minutes',\n        'h' : 'valanda_valandos_valand',\n        'hh': 'valandos_valand_valandas',\n        'd' : 'diena_dienos_dien',\n        'dd': 'dienos_dien_dienas',\n        'M' : 'mnuo_mnesio_mnes',\n        'MM': 'mnesiai_mnesi_mnesius',\n        'y' : 'metai_met_metus',\n        'yy': 'metai_met_metus'\n    },\n    weekDays = 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_');\n    function translateSeconds(number, withoutSuffix, key, isFuture) {\n        if (withoutSuffix) {\n            return 'kelios sekunds';\n        } else {\n            return isFuture ? 'keli sekundi' : 'kelias sekundes';\n        }\n    }\n    function lt__monthsCaseReplace(m, format) {\n        var months = {\n                'nominative': 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),\n                'accusative': 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_')\n            },\n            nounCase = (/D[oD]?(\\[[^\\[\\]]*\\]|\\s+)+MMMM?/).test(format) ?\n                'accusative' :\n                'nominative';\n        return months[nounCase][m.month()];\n    }\n    function translateSingular(number, withoutSuffix, key, isFuture) {\n        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);\n    }\n    function special(number) {\n        return number % 10 === 0 || (number > 10 && number < 20);\n    }\n    function forms(key) {\n        return lt__units[key].split('_');\n    }\n    function lt__translate(number, withoutSuffix, key, isFuture) {\n        var result = number + ' ';\n        if (number === 1) {\n            return result + translateSingular(number, withoutSuffix, key[0], isFuture);\n        } else if (withoutSuffix) {\n            return result + (special(number) ? forms(key)[1] : forms(key)[0]);\n        } else {\n            if (isFuture) {\n                return result + forms(key)[1];\n            } else {\n                return result + (special(number) ? forms(key)[1] : forms(key)[2]);\n            }\n        }\n    }\n    function relativeWeekDay(moment, format) {\n        var nominative = format.indexOf('dddd HH:mm') === -1,\n            weekDay = weekDays[moment.day()];\n        return nominative ? weekDay : weekDay.substring(0, weekDay.length - 2) + '';\n    }\n\n    var lt = _moment__default.defineLocale('lt', {\n        months : lt__monthsCaseReplace,\n        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),\n        weekdays : relativeWeekDay,\n        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),\n        weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'YYYY-MM-DD',\n            LL : 'YYYY [m.] MMMM D [d.]',\n            LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',\n            LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',\n            l : 'YYYY-MM-DD',\n            ll : 'YYYY [m.] MMMM D [d.]',\n            lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',\n            llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'\n        },\n        calendar : {\n            sameDay : '[iandien] LT',\n            nextDay : '[Rytoj] LT',\n            nextWeek : 'dddd LT',\n            lastDay : '[Vakar] LT',\n            lastWeek : '[Prajus] dddd LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'po %s',\n            past : 'prie %s',\n            s : translateSeconds,\n            m : translateSingular,\n            mm : lt__translate,\n            h : translateSingular,\n            hh : lt__translate,\n            d : translateSingular,\n            dd : lt__translate,\n            M : translateSingular,\n            MM : lt__translate,\n            y : translateSingular,\n            yy : lt__translate\n        },\n        ordinalParse: /\\d{1,2}-oji/,\n        ordinal : function (number) {\n            return number + '-oji';\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : latvian (lv)\n    //! author : Kristaps Karlsons : https://github.com/skakri\n    //! author : Jnis Elmeris : https://github.com/JanisE\n\n    var lv__units = {\n        'm': 'mintes_mintm_minte_mintes'.split('_'),\n        'mm': 'mintes_mintm_minte_mintes'.split('_'),\n        'h': 'stundas_stundm_stunda_stundas'.split('_'),\n        'hh': 'stundas_stundm_stunda_stundas'.split('_'),\n        'd': 'dienas_dienm_diena_dienas'.split('_'),\n        'dd': 'dienas_dienm_diena_dienas'.split('_'),\n        'M': 'mnea_mneiem_mnesis_mnei'.split('_'),\n        'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),\n        'y': 'gada_gadiem_gads_gadi'.split('_'),\n        'yy': 'gada_gadiem_gads_gadi'.split('_')\n    };\n    /**\n     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.\n     */\n    function lv__format(forms, number, withoutSuffix) {\n        if (withoutSuffix) {\n            // E.g. \"21 minte\", \"3 mintes\".\n            return number % 10 === 1 && number !== 11 ? forms[2] : forms[3];\n        } else {\n            // E.g. \"21 mintes\" as in \"pc 21 mintes\".\n            // E.g. \"3 mintm\" as in \"pc 3 mintm\".\n            return number % 10 === 1 && number !== 11 ? forms[0] : forms[1];\n        }\n    }\n    function lv__relativeTimeWithPlural(number, withoutSuffix, key) {\n        return number + ' ' + lv__format(lv__units[key], number, withoutSuffix);\n    }\n    function relativeTimeWithSingular(number, withoutSuffix, key) {\n        return lv__format(lv__units[key], number, withoutSuffix);\n    }\n    function relativeSeconds(number, withoutSuffix) {\n        return withoutSuffix ? 'daas sekundes' : 'dam sekundm';\n    }\n\n    var lv = _moment__default.defineLocale('lv', {\n        months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),\n        monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),\n        weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),\n        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),\n        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY.',\n            LL : 'YYYY. [gada] D. MMMM',\n            LLL : 'YYYY. [gada] D. MMMM, HH:mm',\n            LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'\n        },\n        calendar : {\n            sameDay : '[odien pulksten] LT',\n            nextDay : '[Rt pulksten] LT',\n            nextWeek : 'dddd [pulksten] LT',\n            lastDay : '[Vakar pulksten] LT',\n            lastWeek : '[Pagju] dddd [pulksten] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'pc %s',\n            past : 'pirms %s',\n            s : relativeSeconds,\n            m : relativeTimeWithSingular,\n            mm : lv__relativeTimeWithPlural,\n            h : relativeTimeWithSingular,\n            hh : lv__relativeTimeWithPlural,\n            d : relativeTimeWithSingular,\n            dd : lv__relativeTimeWithPlural,\n            M : relativeTimeWithSingular,\n            MM : lv__relativeTimeWithPlural,\n            y : relativeTimeWithSingular,\n            yy : lv__relativeTimeWithPlural\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Montenegrin (me)\n    //! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac\n\n    var me__translator = {\n        words: { //Different grammatical cases\n            m: ['jedan minut', 'jednog minuta'],\n            mm: ['minut', 'minuta', 'minuta'],\n            h: ['jedan sat', 'jednog sata'],\n            hh: ['sat', 'sata', 'sati'],\n            dd: ['dan', 'dana', 'dana'],\n            MM: ['mjesec', 'mjeseca', 'mjeseci'],\n            yy: ['godina', 'godine', 'godina']\n        },\n        correctGrammaticalCase: function (number, wordKey) {\n            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);\n        },\n        translate: function (number, withoutSuffix, key) {\n            var wordKey = me__translator.words[key];\n            if (key.length === 1) {\n                return withoutSuffix ? wordKey[0] : wordKey[1];\n            } else {\n                return number + ' ' + me__translator.correctGrammaticalCase(number, wordKey);\n            }\n        }\n    };\n\n    var me = _moment__default.defineLocale('me', {\n        months: ['januar', 'februar', 'mart', 'april', 'maj', 'jun', 'jul', 'avgust', 'septembar', 'oktobar', 'novembar', 'decembar'],\n        monthsShort: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun', 'jul', 'avg.', 'sep.', 'okt.', 'nov.', 'dec.'],\n        weekdays: ['nedjelja', 'ponedjeljak', 'utorak', 'srijeda', 'etvrtak', 'petak', 'subota'],\n        weekdaysShort: ['ned.', 'pon.', 'uto.', 'sri.', 'et.', 'pet.', 'sub.'],\n        weekdaysMin: ['ne', 'po', 'ut', 'sr', 'e', 'pe', 'su'],\n        longDateFormat: {\n            LT: 'H:mm',\n            LTS : 'H:mm:ss',\n            L: 'DD. MM. YYYY',\n            LL: 'D. MMMM YYYY',\n            LLL: 'D. MMMM YYYY H:mm',\n            LLLL: 'dddd, D. MMMM YYYY H:mm'\n        },\n        calendar: {\n            sameDay: '[danas u] LT',\n            nextDay: '[sjutra u] LT',\n\n            nextWeek: function () {\n                switch (this.day()) {\n                case 0:\n                    return '[u] [nedjelju] [u] LT';\n                case 3:\n                    return '[u] [srijedu] [u] LT';\n                case 6:\n                    return '[u] [subotu] [u] LT';\n                case 1:\n                case 2:\n                case 4:\n                case 5:\n                    return '[u] dddd [u] LT';\n                }\n            },\n            lastDay  : '[jue u] LT',\n            lastWeek : function () {\n                var lastWeekDays = [\n                    '[prole] [nedjelje] [u] LT',\n                    '[prolog] [ponedjeljka] [u] LT',\n                    '[prolog] [utorka] [u] LT',\n                    '[prole] [srijede] [u] LT',\n                    '[prolog] [etvrtka] [u] LT',\n                    '[prolog] [petka] [u] LT',\n                    '[prole] [subote] [u] LT'\n                ];\n                return lastWeekDays[this.day()];\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'za %s',\n            past   : 'prije %s',\n            s      : 'nekoliko sekundi',\n            m      : me__translator.translate,\n            mm     : me__translator.translate,\n            h      : me__translator.translate,\n            hh     : me__translator.translate,\n            d      : 'dan',\n            dd     : me__translator.translate,\n            M      : 'mjesec',\n            MM     : me__translator.translate,\n            y      : 'godinu',\n            yy     : me__translator.translate\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : macedonian (mk)\n    //! author : Borislav Mickov : https://github.com/B0k0\n\n    var mk = _moment__default.defineLocale('mk', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : 'e_o_____a'.split('_'),\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'D.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY H:mm',\n            LLLL : 'dddd, D MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay : '[ ] LT',\n            nextDay : '[ ] LT',\n            nextWeek : 'dddd [] LT',\n            lastDay : '[ ] LT',\n            lastWeek : function () {\n                switch (this.day()) {\n                case 0:\n                case 3:\n                case 6:\n                    return '[ ] dddd [] LT';\n                case 1:\n                case 2:\n                case 4:\n                case 5:\n                    return '[ ] dddd [] LT';\n                }\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : ' %s',\n            s : ' ',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d ',\n            M : '',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        ordinalParse: /\\d{1,2}-(|||||)/,\n        ordinal : function (number) {\n            var lastDigit = number % 10,\n                last2Digits = number % 100;\n            if (number === 0) {\n                return number + '-';\n            } else if (last2Digits === 0) {\n                return number + '-';\n            } else if (last2Digits > 10 && last2Digits < 20) {\n                return number + '-';\n            } else if (lastDigit === 1) {\n                return number + '-';\n            } else if (lastDigit === 2) {\n                return number + '-';\n            } else if (lastDigit === 7 || lastDigit === 8) {\n                return number + '-';\n            } else {\n                return number + '-';\n            }\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : malayalam (ml)\n    //! author : Floyd Pink : https://github.com/floydpink\n\n    var ml = _moment__default.defineLocale('ml', {\n        months : '___________'.split('_'),\n        monthsShort : '._._._.___._._._._._.'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'A h:mm -',\n            LTS : 'A h:mm:ss -',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY, A h:mm -',\n            LLLL : 'dddd, D MMMM YYYY, A h:mm -'\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : 'dddd, LT',\n            lastDay : '[] LT',\n            lastWeek : '[] dddd, LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : ' ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        meridiemParse: /|| ||/i,\n        isPM : function (input) {\n            return /^( ||)$/.test(input);\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 12) {\n                return '';\n            } else if (hour < 17) {\n                return ' ';\n            } else if (hour < 20) {\n                return '';\n            } else {\n                return '';\n            }\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Marathi (mr)\n    //! author : Harshad Kale : https://github.com/kalehv\n\n    var mr__symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    },\n    mr__numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var mr = _moment__default.defineLocale('mr', {\n        months : '___________'.split('_'),\n        monthsShort: '._._._._._._._._._._._.'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'A h:mm ',\n            LTS : 'A h:mm:ss ',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY, A h:mm ',\n            LLLL : 'dddd, D MMMM YYYY, A h:mm '\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : 'dddd, LT',\n            lastDay : '[] LT',\n            lastWeek: '[] dddd, LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : '',\n            m: ' ',\n            mm: '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return mr__numberMap[match];\n            });\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return mr__symbolMap[match];\n            });\n        },\n        meridiemParse: /|||/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '') {\n                return hour < 4 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour;\n            } else if (meridiem === '') {\n                return hour >= 10 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour + 12;\n            }\n        },\n        meridiem: function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 10) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else if (hour < 20) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Bahasa Malaysia (ms-MY)\n    //! author : Weldan Jamili : https://github.com/weldan\n\n    var ms_my = _moment__default.defineLocale('ms-my', {\n        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),\n        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),\n        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),\n        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),\n        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),\n        longDateFormat : {\n            LT : 'HH.mm',\n            LTS : 'HH.mm.ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY [pukul] HH.mm',\n            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'\n        },\n        meridiemParse: /pagi|tengahari|petang|malam/,\n        meridiemHour: function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === 'pagi') {\n                return hour;\n            } else if (meridiem === 'tengahari') {\n                return hour >= 11 ? hour : hour + 12;\n            } else if (meridiem === 'petang' || meridiem === 'malam') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours < 11) {\n                return 'pagi';\n            } else if (hours < 15) {\n                return 'tengahari';\n            } else if (hours < 19) {\n                return 'petang';\n            } else {\n                return 'malam';\n            }\n        },\n        calendar : {\n            sameDay : '[Hari ini pukul] LT',\n            nextDay : '[Esok pukul] LT',\n            nextWeek : 'dddd [pukul] LT',\n            lastDay : '[Kelmarin pukul] LT',\n            lastWeek : 'dddd [lepas pukul] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'dalam %s',\n            past : '%s yang lepas',\n            s : 'beberapa saat',\n            m : 'seminit',\n            mm : '%d minit',\n            h : 'sejam',\n            hh : '%d jam',\n            d : 'sehari',\n            dd : '%d hari',\n            M : 'sebulan',\n            MM : '%d bulan',\n            y : 'setahun',\n            yy : '%d tahun'\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Bahasa Malaysia (ms-MY)\n    //! author : Weldan Jamili : https://github.com/weldan\n\n    var locale_ms = _moment__default.defineLocale('ms', {\n        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),\n        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),\n        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),\n        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),\n        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),\n        longDateFormat : {\n            LT : 'HH.mm',\n            LTS : 'HH.mm.ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY [pukul] HH.mm',\n            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'\n        },\n        meridiemParse: /pagi|tengahari|petang|malam/,\n        meridiemHour: function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === 'pagi') {\n                return hour;\n            } else if (meridiem === 'tengahari') {\n                return hour >= 11 ? hour : hour + 12;\n            } else if (meridiem === 'petang' || meridiem === 'malam') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours < 11) {\n                return 'pagi';\n            } else if (hours < 15) {\n                return 'tengahari';\n            } else if (hours < 19) {\n                return 'petang';\n            } else {\n                return 'malam';\n            }\n        },\n        calendar : {\n            sameDay : '[Hari ini pukul] LT',\n            nextDay : '[Esok pukul] LT',\n            nextWeek : 'dddd [pukul] LT',\n            lastDay : '[Kelmarin pukul] LT',\n            lastWeek : 'dddd [lepas pukul] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'dalam %s',\n            past : '%s yang lepas',\n            s : 'beberapa saat',\n            m : 'seminit',\n            mm : '%d minit',\n            h : 'sejam',\n            hh : '%d jam',\n            d : 'sehari',\n            dd : '%d hari',\n            M : 'sebulan',\n            MM : '%d bulan',\n            y : 'setahun',\n            yy : '%d tahun'\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Burmese (my)\n    //! author : Squar team, mysquar.com\n\n    var my__symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    }, my__numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var my = _moment__default.defineLocale('my', {\n        months: '___________'.split('_'),\n        monthsShort: '___________'.split('_'),\n        weekdays: '______'.split('_'),\n        weekdaysShort: '______'.split('_'),\n        weekdaysMin: '______'.split('_'),\n\n        longDateFormat: {\n            LT: 'HH:mm',\n            LTS: 'HH:mm:ss',\n            L: 'DD/MM/YYYY',\n            LL: 'D MMMM YYYY',\n            LLL: 'D MMMM YYYY HH:mm',\n            LLLL: 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar: {\n            sameDay: '[.] LT []',\n            nextDay: '[] LT []',\n            nextWeek: 'dddd LT []',\n            lastDay: '[.] LT []',\n            lastWeek: '[] dddd LT []',\n            sameElse: 'L'\n        },\n        relativeTime: {\n            future: ' %s ',\n            past: ' %s ',\n            s: '.',\n            m: '',\n            mm: '%d ',\n            h: '',\n            hh: '%d ',\n            d: '',\n            dd: '%d ',\n            M: '',\n            MM: '%d ',\n            y: '',\n            yy: '%d '\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return my__numberMap[match];\n            });\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return my__symbolMap[match];\n            });\n        },\n        week: {\n            dow: 1, // Monday is the first day of the week.\n            doy: 4 // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : norwegian bokml (nb)\n    //! authors : Espen Hovlandsdal : https://github.com/rexxars\n    //!           Sigurd Gartmann : https://github.com/sigurdga\n\n    var nb = _moment__default.defineLocale('nb', {\n        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),\n        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),\n        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),\n        weekdaysShort : 'sn_man_tirs_ons_tors_fre_lr'.split('_'),\n        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),\n        longDateFormat : {\n            LT : 'H.mm',\n            LTS : 'H.mm.ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY [kl.] H.mm',\n            LLLL : 'dddd D. MMMM YYYY [kl.] H.mm'\n        },\n        calendar : {\n            sameDay: '[i dag kl.] LT',\n            nextDay: '[i morgen kl.] LT',\n            nextWeek: 'dddd [kl.] LT',\n            lastDay: '[i gr kl.] LT',\n            lastWeek: '[forrige] dddd [kl.] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'om %s',\n            past : 'for %s siden',\n            s : 'noen sekunder',\n            m : 'ett minutt',\n            mm : '%d minutter',\n            h : 'en time',\n            hh : '%d timer',\n            d : 'en dag',\n            dd : '%d dager',\n            M : 'en mned',\n            MM : '%d mneder',\n            y : 'ett r',\n            yy : '%d r'\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : nepali/nepalese\n    //! author : suvash : https://github.com/suvash\n\n    var ne__symbolMap = {\n        '1': '',\n        '2': '',\n        '3': '',\n        '4': '',\n        '5': '',\n        '6': '',\n        '7': '',\n        '8': '',\n        '9': '',\n        '0': ''\n    },\n    ne__numberMap = {\n        '': '1',\n        '': '2',\n        '': '3',\n        '': '4',\n        '': '5',\n        '': '6',\n        '': '7',\n        '': '8',\n        '': '9',\n        '': '0'\n    };\n\n    var ne = _moment__default.defineLocale('ne', {\n        months : '___________'.split('_'),\n        monthsShort : '._.__.___._._._._._.'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '._._._._._._.'.split('_'),\n        weekdaysMin : '._.__._._._.'.split('_'),\n        longDateFormat : {\n            LT : 'A h:mm ',\n            LTS : 'A h:mm:ss ',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY, A h:mm ',\n            LLLL : 'dddd, D MMMM YYYY, A h:mm '\n        },\n        preparse: function (string) {\n            return string.replace(/[]/g, function (match) {\n                return ne__numberMap[match];\n            });\n        },\n        postformat: function (string) {\n            return string.replace(/\\d/g, function (match) {\n                return ne__symbolMap[match];\n            });\n        },\n        meridiemParse: /|||||/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '') {\n                return hour < 3 ? hour : hour + 12;\n            } else if (meridiem === '') {\n                return hour;\n            } else if (meridiem === '') {\n                return hour >= 10 ? hour : hour + 12;\n            } else if (meridiem === '' || meridiem === '') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 3) {\n                return '';\n            } else if (hour < 10) {\n                return '';\n            } else if (hour < 15) {\n                return '';\n            } else if (hour < 18) {\n                return '';\n            } else if (hour < 20) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : '[] dddd[,] LT',\n            lastDay : '[] LT',\n            lastWeek : '[] dddd[,] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s',\n            past : '%s ',\n            s : ' ',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : dutch (nl)\n    //! author : Joris Rling : https://github.com/jjupiter\n\n    var nl__monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),\n        nl__monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');\n\n    var nl = _moment__default.defineLocale('nl', {\n        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),\n        monthsShort : function (m, format) {\n            if (/-MMM-/.test(format)) {\n                return nl__monthsShortWithoutDots[m.month()];\n            } else {\n                return nl__monthsShortWithDots[m.month()];\n            }\n        },\n        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),\n        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),\n        weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD-MM-YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[vandaag om] LT',\n            nextDay: '[morgen om] LT',\n            nextWeek: 'dddd [om] LT',\n            lastDay: '[gisteren om] LT',\n            lastWeek: '[afgelopen] dddd [om] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'over %s',\n            past : '%s geleden',\n            s : 'een paar seconden',\n            m : 'n minuut',\n            mm : '%d minuten',\n            h : 'n uur',\n            hh : '%d uur',\n            d : 'n dag',\n            dd : '%d dagen',\n            M : 'n maand',\n            MM : '%d maanden',\n            y : 'n jaar',\n            yy : '%d jaar'\n        },\n        ordinalParse: /\\d{1,2}(ste|de)/,\n        ordinal : function (number) {\n            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : norwegian nynorsk (nn)\n    //! author : https://github.com/mechuwind\n\n    var nn = _moment__default.defineLocale('nn', {\n        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),\n        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),\n        weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),\n        weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),\n        weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[I dag klokka] LT',\n            nextDay: '[I morgon klokka] LT',\n            nextWeek: 'dddd [klokka] LT',\n            lastDay: '[I gr klokka] LT',\n            lastWeek: '[Fregande] dddd [klokka] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'om %s',\n            past : 'for %s sidan',\n            s : 'nokre sekund',\n            m : 'eit minutt',\n            mm : '%d minutt',\n            h : 'ein time',\n            hh : '%d timar',\n            d : 'ein dag',\n            dd : '%d dagar',\n            M : 'ein mnad',\n            MM : '%d mnader',\n            y : 'eit r',\n            yy : '%d r'\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : polish (pl)\n    //! author : Rafal Hirsz : https://github.com/evoL\n\n    var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),\n        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');\n    function pl__plural(n) {\n        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);\n    }\n    function pl__translate(number, withoutSuffix, key) {\n        var result = number + ' ';\n        switch (key) {\n        case 'm':\n            return withoutSuffix ? 'minuta' : 'minut';\n        case 'mm':\n            return result + (pl__plural(number) ? 'minuty' : 'minut');\n        case 'h':\n            return withoutSuffix  ? 'godzina'  : 'godzin';\n        case 'hh':\n            return result + (pl__plural(number) ? 'godziny' : 'godzin');\n        case 'MM':\n            return result + (pl__plural(number) ? 'miesice' : 'miesicy');\n        case 'yy':\n            return result + (pl__plural(number) ? 'lata' : 'lat');\n        }\n    }\n\n    var pl = _moment__default.defineLocale('pl', {\n        months : function (momentToFormat, format) {\n            if (format === '') {\n                // Hack: if format empty we know this is used to generate\n                // RegExp by moment. Give then back both valid forms of months\n                // in RegExp ready format.\n                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';\n            } else if (/D MMMM/.test(format)) {\n                return monthsSubjective[momentToFormat.month()];\n            } else {\n                return monthsNominative[momentToFormat.month()];\n            }\n        },\n        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),\n        weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),\n        weekdaysShort : 'nie_pon_wt_r_czw_pt_sb'.split('_'),\n        weekdaysMin : 'N_Pn_Wt_r_Cz_Pt_So'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[Dzi o] LT',\n            nextDay: '[Jutro o] LT',\n            nextWeek: '[W] dddd [o] LT',\n            lastDay: '[Wczoraj o] LT',\n            lastWeek: function () {\n                switch (this.day()) {\n                case 0:\n                    return '[W zesz niedziel o] LT';\n                case 3:\n                    return '[W zesz rod o] LT';\n                case 6:\n                    return '[W zesz sobot o] LT';\n                default:\n                    return '[W zeszy] dddd [o] LT';\n                }\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'za %s',\n            past : '%s temu',\n            s : 'kilka sekund',\n            m : pl__translate,\n            mm : pl__translate,\n            h : pl__translate,\n            hh : pl__translate,\n            d : '1 dzie',\n            dd : '%d dni',\n            M : 'miesic',\n            MM : pl__translate,\n            y : 'rok',\n            yy : pl__translate\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : brazilian portuguese (pt-br)\n    //! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira\n\n    var pt_br = _moment__default.defineLocale('pt-br', {\n        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),\n        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),\n        weekdays : 'Domingo_Segunda-Feira_Tera-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sbado'.split('_'),\n        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),\n        weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D [de] MMMM [de] YYYY',\n            LLL : 'D [de] MMMM [de] YYYY [s] HH:mm',\n            LLLL : 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'\n        },\n        calendar : {\n            sameDay: '[Hoje s] LT',\n            nextDay: '[Amanh s] LT',\n            nextWeek: 'dddd [s] LT',\n            lastDay: '[Ontem s] LT',\n            lastWeek: function () {\n                return (this.day() === 0 || this.day() === 6) ?\n                    '[ltimo] dddd [s] LT' : // Saturday + Sunday\n                    '[ltima] dddd [s] LT'; // Monday - Friday\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'em %s',\n            past : '%s atrs',\n            s : 'poucos segundos',\n            m : 'um minuto',\n            mm : '%d minutos',\n            h : 'uma hora',\n            hh : '%d horas',\n            d : 'um dia',\n            dd : '%d dias',\n            M : 'um ms',\n            MM : '%d meses',\n            y : 'um ano',\n            yy : '%d anos'\n        },\n        ordinalParse: /\\d{1,2}/,\n        ordinal : '%d'\n    });\n\n    //! moment.js locale configuration\n    //! locale : portuguese (pt)\n    //! author : Jefferson : https://github.com/jalex79\n\n    var pt = _moment__default.defineLocale('pt', {\n        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),\n        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),\n        weekdays : 'Domingo_Segunda-Feira_Tera-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sbado'.split('_'),\n        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),\n        weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D [de] MMMM [de] YYYY',\n            LLL : 'D [de] MMMM [de] YYYY HH:mm',\n            LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[Hoje s] LT',\n            nextDay: '[Amanh s] LT',\n            nextWeek: 'dddd [s] LT',\n            lastDay: '[Ontem s] LT',\n            lastWeek: function () {\n                return (this.day() === 0 || this.day() === 6) ?\n                    '[ltimo] dddd [s] LT' : // Saturday + Sunday\n                    '[ltima] dddd [s] LT'; // Monday - Friday\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'em %s',\n            past : 'h %s',\n            s : 'segundos',\n            m : 'um minuto',\n            mm : '%d minutos',\n            h : 'uma hora',\n            hh : '%d horas',\n            d : 'um dia',\n            dd : '%d dias',\n            M : 'um ms',\n            MM : '%d meses',\n            y : 'um ano',\n            yy : '%d anos'\n        },\n        ordinalParse: /\\d{1,2}/,\n        ordinal : '%d',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : romanian (ro)\n    //! author : Vlad Gurdiga : https://github.com/gurdiga\n    //! author : Valentin Agachi : https://github.com/avaly\n\n    function ro__relativeTimeWithPlural(number, withoutSuffix, key) {\n        var format = {\n                'mm': 'minute',\n                'hh': 'ore',\n                'dd': 'zile',\n                'MM': 'luni',\n                'yy': 'ani'\n            },\n            separator = ' ';\n        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {\n            separator = ' de ';\n        }\n        return number + separator + format[key];\n    }\n\n    var ro = _moment__default.defineLocale('ro', {\n        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),\n        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),\n        weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),\n        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),\n        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY H:mm',\n            LLLL : 'dddd, D MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay: '[azi la] LT',\n            nextDay: '[mine la] LT',\n            nextWeek: 'dddd [la] LT',\n            lastDay: '[ieri la] LT',\n            lastWeek: '[fosta] dddd [la] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'peste %s',\n            past : '%s n urm',\n            s : 'cteva secunde',\n            m : 'un minut',\n            mm : ro__relativeTimeWithPlural,\n            h : 'o or',\n            hh : ro__relativeTimeWithPlural,\n            d : 'o zi',\n            dd : ro__relativeTimeWithPlural,\n            M : 'o lun',\n            MM : ro__relativeTimeWithPlural,\n            y : 'un an',\n            yy : ro__relativeTimeWithPlural\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : russian (ru)\n    //! author : Viktorminator : https://github.com/Viktorminator\n    //! Author : Menelion Elensle : https://github.com/Oire\n\n    function ru__plural(word, num) {\n        var forms = word.split('_');\n        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);\n    }\n    function ru__relativeTimeWithPlural(number, withoutSuffix, key) {\n        var format = {\n            'mm': withoutSuffix ? '__' : '__',\n            'hh': '__',\n            'dd': '__',\n            'MM': '__',\n            'yy': '__'\n        };\n        if (key === 'm') {\n            return withoutSuffix ? '' : '';\n        }\n        else {\n            return number + ' ' + ru__plural(format[key], +number);\n        }\n    }\n    function ru__monthsCaseReplace(m, format) {\n        var months = {\n            'nominative': '___________'.split('_'),\n            'accusative': '___________'.split('_')\n        },\n        nounCase = (/D[oD]?(\\[[^\\[\\]]*\\]|\\s+)+MMMM?/).test(format) ?\n            'accusative' :\n            'nominative';\n        return months[nounCase][m.month()];\n    }\n    function ru__monthsShortCaseReplace(m, format) {\n        var monthsShort = {\n            'nominative': '___________'.split('_'),\n            'accusative': '___________'.split('_')\n        },\n        nounCase = (/D[oD]?(\\[[^\\[\\]]*\\]|\\s+)+MMMM?/).test(format) ?\n            'accusative' :\n            'nominative';\n        return monthsShort[nounCase][m.month()];\n    }\n    function ru__weekdaysCaseReplace(m, format) {\n        var weekdays = {\n            'nominative': '______'.split('_'),\n            'accusative': '______'.split('_')\n        },\n        nounCase = (/\\[ ?[] ?(?:||)? ?\\] ?dddd/).test(format) ?\n            'accusative' :\n            'nominative';\n        return weekdays[nounCase][m.day()];\n    }\n\n    var ru = _moment__default.defineLocale('ru', {\n        months : ru__monthsCaseReplace,\n        monthsShort : ru__monthsShortCaseReplace,\n        weekdays : ru__weekdaysCaseReplace,\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        monthsParse : [/^/i, /^/i, /^/i, /^/i, /^[|]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY .',\n            LLL : 'D MMMM YYYY ., HH:mm',\n            LLLL : 'dddd, D MMMM YYYY ., HH:mm'\n        },\n        calendar : {\n            sameDay: '[ ] LT',\n            nextDay: '[ ] LT',\n            lastDay: '[ ] LT',\n            nextWeek: function () {\n                return this.day() === 2 ? '[] dddd [] LT' : '[] dddd [] LT';\n            },\n            lastWeek: function (now) {\n                if (now.week() !== this.week()) {\n                    switch (this.day()) {\n                    case 0:\n                        return '[ ] dddd [] LT';\n                    case 1:\n                    case 2:\n                    case 4:\n                        return '[ ] dddd [] LT';\n                    case 3:\n                    case 5:\n                    case 6:\n                        return '[ ] dddd [] LT';\n                    }\n                } else {\n                    if (this.day() === 2) {\n                        return '[] dddd [] LT';\n                    } else {\n                        return '[] dddd [] LT';\n                    }\n                }\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : '%s ',\n            s : ' ',\n            m : ru__relativeTimeWithPlural,\n            mm : ru__relativeTimeWithPlural,\n            h : '',\n            hh : ru__relativeTimeWithPlural,\n            d : '',\n            dd : ru__relativeTimeWithPlural,\n            M : '',\n            MM : ru__relativeTimeWithPlural,\n            y : '',\n            yy : ru__relativeTimeWithPlural\n        },\n        meridiemParse: /|||/i,\n        isPM : function (input) {\n            return /^(|)$/.test(input);\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 12) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        ordinalParse: /\\d{1,2}-(||)/,\n        ordinal: function (number, period) {\n            switch (period) {\n            case 'M':\n            case 'd':\n            case 'DDD':\n                return number + '-';\n            case 'D':\n                return number + '-';\n            case 'w':\n            case 'W':\n                return number + '-';\n            default:\n                return number;\n            }\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Sinhalese (si)\n    //! author : Sampath Sitinamaluwa : https://github.com/sampathsris\n\n    var si = _moment__default.defineLocale('si', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'a h:mm',\n            LTS : 'a h:mm:ss',\n            L : 'YYYY/MM/DD',\n            LL : 'YYYY MMMM D',\n            LLL : 'YYYY MMMM D, a h:mm',\n            LLLL : 'YYYY MMMM D [] dddd, a h:mm:ss'\n        },\n        calendar : {\n            sameDay : '[] LT[]',\n            nextDay : '[] LT[]',\n            nextWeek : 'dddd LT[]',\n            lastDay : '[] LT[]',\n            lastWeek : '[] dddd LT[]',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s',\n            past : '%s ',\n            s : ' ',\n            m : '',\n            mm : ' %d',\n            h : '',\n            hh : ' %d',\n            d : '',\n            dd : ' %d',\n            M : '',\n            MM : ' %d',\n            y : '',\n            yy : ' %d'\n        },\n        ordinalParse: /\\d{1,2} /,\n        ordinal : function (number) {\n            return number + ' ';\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours > 11) {\n                return isLower ? '..' : ' ';\n            } else {\n                return isLower ? '..' : ' ';\n            }\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : slovak (sk)\n    //! author : Martin Minka : https://github.com/k2s\n    //! based on work of petrbela : https://github.com/petrbela\n\n    var sk__months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),\n        sk__monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');\n    function sk__plural(n) {\n        return (n > 1) && (n < 5);\n    }\n    function sk__translate(number, withoutSuffix, key, isFuture) {\n        var result = number + ' ';\n        switch (key) {\n        case 's':  // a few seconds / in a few seconds / a few seconds ago\n            return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';\n        case 'm':  // a minute / in a minute / a minute ago\n            return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');\n        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago\n            if (withoutSuffix || isFuture) {\n                return result + (sk__plural(number) ? 'minty' : 'mint');\n            } else {\n                return result + 'mintami';\n            }\n            break;\n        case 'h':  // an hour / in an hour / an hour ago\n            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');\n        case 'hh': // 9 hours / in 9 hours / 9 hours ago\n            if (withoutSuffix || isFuture) {\n                return result + (sk__plural(number) ? 'hodiny' : 'hodn');\n            } else {\n                return result + 'hodinami';\n            }\n            break;\n        case 'd':  // a day / in a day / a day ago\n            return (withoutSuffix || isFuture) ? 'de' : 'dom';\n        case 'dd': // 9 days / in 9 days / 9 days ago\n            if (withoutSuffix || isFuture) {\n                return result + (sk__plural(number) ? 'dni' : 'dn');\n            } else {\n                return result + 'dami';\n            }\n            break;\n        case 'M':  // a month / in a month / a month ago\n            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';\n        case 'MM': // 9 months / in 9 months / 9 months ago\n            if (withoutSuffix || isFuture) {\n                return result + (sk__plural(number) ? 'mesiace' : 'mesiacov');\n            } else {\n                return result + 'mesiacmi';\n            }\n            break;\n        case 'y':  // a year / in a year / a year ago\n            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';\n        case 'yy': // 9 years / in 9 years / 9 years ago\n            if (withoutSuffix || isFuture) {\n                return result + (sk__plural(number) ? 'roky' : 'rokov');\n            } else {\n                return result + 'rokmi';\n            }\n            break;\n        }\n    }\n\n    var sk = _moment__default.defineLocale('sk', {\n        months : sk__months,\n        monthsShort : sk__monthsShort,\n        monthsParse : (function (months, monthsShort) {\n            var i, _monthsParse = [];\n            for (i = 0; i < 12; i++) {\n                // use custom parser to solve problem with July (ervenec)\n                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');\n            }\n            return _monthsParse;\n        }(sk__months, sk__monthsShort)),\n        weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),\n        weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),\n        weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),\n        longDateFormat : {\n            LT: 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY H:mm',\n            LLLL : 'dddd D. MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay: '[dnes o] LT',\n            nextDay: '[zajtra o] LT',\n            nextWeek: function () {\n                switch (this.day()) {\n                case 0:\n                    return '[v nedeu o] LT';\n                case 1:\n                case 2:\n                    return '[v] dddd [o] LT';\n                case 3:\n                    return '[v stredu o] LT';\n                case 4:\n                    return '[vo tvrtok o] LT';\n                case 5:\n                    return '[v piatok o] LT';\n                case 6:\n                    return '[v sobotu o] LT';\n                }\n            },\n            lastDay: '[vera o] LT',\n            lastWeek: function () {\n                switch (this.day()) {\n                case 0:\n                    return '[minul nedeu o] LT';\n                case 1:\n                case 2:\n                    return '[minul] dddd [o] LT';\n                case 3:\n                    return '[minul stredu o] LT';\n                case 4:\n                case 5:\n                    return '[minul] dddd [o] LT';\n                case 6:\n                    return '[minul sobotu o] LT';\n                }\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'za %s',\n            past : 'pred %s',\n            s : sk__translate,\n            m : sk__translate,\n            mm : sk__translate,\n            h : sk__translate,\n            hh : sk__translate,\n            d : sk__translate,\n            dd : sk__translate,\n            M : sk__translate,\n            MM : sk__translate,\n            y : sk__translate,\n            yy : sk__translate\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : slovenian (sl)\n    //! author : Robert Sedovek : https://github.com/sedovsek\n\n    function sl__processRelativeTime(number, withoutSuffix, key, isFuture) {\n        var result = number + ' ';\n        switch (key) {\n        case 's':\n            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';\n        case 'm':\n            return withoutSuffix ? 'ena minuta' : 'eno minuto';\n        case 'mm':\n            if (number === 1) {\n                result += withoutSuffix ? 'minuta' : 'minuto';\n            } else if (number === 2) {\n                result += withoutSuffix || isFuture ? 'minuti' : 'minutama';\n            } else if (number < 5) {\n                result += withoutSuffix || isFuture ? 'minute' : 'minutami';\n            } else {\n                result += withoutSuffix || isFuture ? 'minut' : 'minutami';\n            }\n            return result;\n        case 'h':\n            return withoutSuffix ? 'ena ura' : 'eno uro';\n        case 'hh':\n            if (number === 1) {\n                result += withoutSuffix ? 'ura' : 'uro';\n            } else if (number === 2) {\n                result += withoutSuffix || isFuture ? 'uri' : 'urama';\n            } else if (number < 5) {\n                result += withoutSuffix || isFuture ? 'ure' : 'urami';\n            } else {\n                result += withoutSuffix || isFuture ? 'ur' : 'urami';\n            }\n            return result;\n        case 'd':\n            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';\n        case 'dd':\n            if (number === 1) {\n                result += withoutSuffix || isFuture ? 'dan' : 'dnem';\n            } else if (number === 2) {\n                result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';\n            } else {\n                result += withoutSuffix || isFuture ? 'dni' : 'dnevi';\n            }\n            return result;\n        case 'M':\n            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';\n        case 'MM':\n            if (number === 1) {\n                result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';\n            } else if (number === 2) {\n                result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';\n            } else if (number < 5) {\n                result += withoutSuffix || isFuture ? 'mesece' : 'meseci';\n            } else {\n                result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';\n            }\n            return result;\n        case 'y':\n            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';\n        case 'yy':\n            if (number === 1) {\n                result += withoutSuffix || isFuture ? 'leto' : 'letom';\n            } else if (number === 2) {\n                result += withoutSuffix || isFuture ? 'leti' : 'letoma';\n            } else if (number < 5) {\n                result += withoutSuffix || isFuture ? 'leta' : 'leti';\n            } else {\n                result += withoutSuffix || isFuture ? 'let' : 'leti';\n            }\n            return result;\n        }\n    }\n\n    var sl = _moment__default.defineLocale('sl', {\n        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),\n        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),\n        weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),\n        weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),\n        weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),\n        longDateFormat : {\n            LT : 'H:mm',\n            LTS : 'H:mm:ss',\n            L : 'DD. MM. YYYY',\n            LL : 'D. MMMM YYYY',\n            LLL : 'D. MMMM YYYY H:mm',\n            LLLL : 'dddd, D. MMMM YYYY H:mm'\n        },\n        calendar : {\n            sameDay  : '[danes ob] LT',\n            nextDay  : '[jutri ob] LT',\n\n            nextWeek : function () {\n                switch (this.day()) {\n                case 0:\n                    return '[v] [nedeljo] [ob] LT';\n                case 3:\n                    return '[v] [sredo] [ob] LT';\n                case 6:\n                    return '[v] [soboto] [ob] LT';\n                case 1:\n                case 2:\n                case 4:\n                case 5:\n                    return '[v] dddd [ob] LT';\n                }\n            },\n            lastDay  : '[veraj ob] LT',\n            lastWeek : function () {\n                switch (this.day()) {\n                case 0:\n                    return '[prejnjo] [nedeljo] [ob] LT';\n                case 3:\n                    return '[prejnjo] [sredo] [ob] LT';\n                case 6:\n                    return '[prejnjo] [soboto] [ob] LT';\n                case 1:\n                case 2:\n                case 4:\n                case 5:\n                    return '[prejnji] dddd [ob] LT';\n                }\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'ez %s',\n            past   : 'pred %s',\n            s      : sl__processRelativeTime,\n            m      : sl__processRelativeTime,\n            mm     : sl__processRelativeTime,\n            h      : sl__processRelativeTime,\n            hh     : sl__processRelativeTime,\n            d      : sl__processRelativeTime,\n            dd     : sl__processRelativeTime,\n            M      : sl__processRelativeTime,\n            MM     : sl__processRelativeTime,\n            y      : sl__processRelativeTime,\n            yy     : sl__processRelativeTime\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Albanian (sq)\n    //! author : Flakrim Ismani : https://github.com/flakerimi\n    //! author: Menelion Elensle: https://github.com/Oire (tests)\n    //! author : Oerd Cukalla : https://github.com/oerd (fixes)\n\n    var sq = _moment__default.defineLocale('sq', {\n        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),\n        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),\n        weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),\n        weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),\n        weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),\n        meridiemParse: /PD|MD/,\n        isPM: function (input) {\n            return input.charAt(0) === 'M';\n        },\n        meridiem : function (hours, minutes, isLower) {\n            return hours < 12 ? 'PD' : 'MD';\n        },\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[Sot n] LT',\n            nextDay : '[Nesr n] LT',\n            nextWeek : 'dddd [n] LT',\n            lastDay : '[Dje n] LT',\n            lastWeek : 'dddd [e kaluar n] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'n %s',\n            past : '%s m par',\n            s : 'disa sekonda',\n            m : 'nj minut',\n            mm : '%d minuta',\n            h : 'nj or',\n            hh : '%d or',\n            d : 'nj dit',\n            dd : '%d dit',\n            M : 'nj muaj',\n            MM : '%d muaj',\n            y : 'nj vit',\n            yy : '%d vite'\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Serbian-cyrillic (sr-cyrl)\n    //! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j\n\n    var sr_cyrl__translator = {\n        words: { //Different grammatical cases\n            m: [' ', ' '],\n            mm: ['', '', ''],\n            h: [' ', ' '],\n            hh: ['', '', ''],\n            dd: ['', '', ''],\n            MM: ['', '', ''],\n            yy: ['', '', '']\n        },\n        correctGrammaticalCase: function (number, wordKey) {\n            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);\n        },\n        translate: function (number, withoutSuffix, key) {\n            var wordKey = sr_cyrl__translator.words[key];\n            if (key.length === 1) {\n                return withoutSuffix ? wordKey[0] : wordKey[1];\n            } else {\n                return number + ' ' + sr_cyrl__translator.correctGrammaticalCase(number, wordKey);\n            }\n        }\n    };\n\n    var sr_cyrl = _moment__default.defineLocale('sr-cyrl', {\n        months: ['', '', '', '', '', '', '', '', '', '', '', ''],\n        monthsShort: ['.', '.', '.', '.', '', '', '', '.', '.', '.', '.', '.'],\n        weekdays: ['', '', '', '', '', '', ''],\n        weekdaysShort: ['.', '.', '.', '.', '.', '.', '.'],\n        weekdaysMin: ['', '', '', '', '', '', ''],\n        longDateFormat: {\n            LT: 'H:mm',\n            LTS : 'H:mm:ss',\n            L: 'DD. MM. YYYY',\n            LL: 'D. MMMM YYYY',\n            LLL: 'D. MMMM YYYY H:mm',\n            LLLL: 'dddd, D. MMMM YYYY H:mm'\n        },\n        calendar: {\n            sameDay: '[ ] LT',\n            nextDay: '[ ] LT',\n            nextWeek: function () {\n                switch (this.day()) {\n                case 0:\n                    return '[] [] [] LT';\n                case 3:\n                    return '[] [] [] LT';\n                case 6:\n                    return '[] [] [] LT';\n                case 1:\n                case 2:\n                case 4:\n                case 5:\n                    return '[] dddd [] LT';\n                }\n            },\n            lastDay  : '[ ] LT',\n            lastWeek : function () {\n                var lastWeekDays = [\n                    '[] [] [] LT',\n                    '[] [] [] LT',\n                    '[] [] [] LT',\n                    '[] [] [] LT',\n                    '[] [] [] LT',\n                    '[] [] [] LT',\n                    '[] [] [] LT'\n                ];\n                return lastWeekDays[this.day()];\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past   : ' %s',\n            s      : ' ',\n            m      : sr_cyrl__translator.translate,\n            mm     : sr_cyrl__translator.translate,\n            h      : sr_cyrl__translator.translate,\n            hh     : sr_cyrl__translator.translate,\n            d      : '',\n            dd     : sr_cyrl__translator.translate,\n            M      : '',\n            MM     : sr_cyrl__translator.translate,\n            y      : '',\n            yy     : sr_cyrl__translator.translate\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Serbian-latin (sr)\n    //! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j\n\n    var sr__translator = {\n        words: { //Different grammatical cases\n            m: ['jedan minut', 'jedne minute'],\n            mm: ['minut', 'minute', 'minuta'],\n            h: ['jedan sat', 'jednog sata'],\n            hh: ['sat', 'sata', 'sati'],\n            dd: ['dan', 'dana', 'dana'],\n            MM: ['mesec', 'meseca', 'meseci'],\n            yy: ['godina', 'godine', 'godina']\n        },\n        correctGrammaticalCase: function (number, wordKey) {\n            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);\n        },\n        translate: function (number, withoutSuffix, key) {\n            var wordKey = sr__translator.words[key];\n            if (key.length === 1) {\n                return withoutSuffix ? wordKey[0] : wordKey[1];\n            } else {\n                return number + ' ' + sr__translator.correctGrammaticalCase(number, wordKey);\n            }\n        }\n    };\n\n    var sr = _moment__default.defineLocale('sr', {\n        months: ['januar', 'februar', 'mart', 'april', 'maj', 'jun', 'jul', 'avgust', 'septembar', 'oktobar', 'novembar', 'decembar'],\n        monthsShort: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun', 'jul', 'avg.', 'sep.', 'okt.', 'nov.', 'dec.'],\n        weekdays: ['nedelja', 'ponedeljak', 'utorak', 'sreda', 'etvrtak', 'petak', 'subota'],\n        weekdaysShort: ['ned.', 'pon.', 'uto.', 'sre.', 'et.', 'pet.', 'sub.'],\n        weekdaysMin: ['ne', 'po', 'ut', 'sr', 'e', 'pe', 'su'],\n        longDateFormat: {\n            LT: 'H:mm',\n            LTS : 'H:mm:ss',\n            L: 'DD. MM. YYYY',\n            LL: 'D. MMMM YYYY',\n            LLL: 'D. MMMM YYYY H:mm',\n            LLLL: 'dddd, D. MMMM YYYY H:mm'\n        },\n        calendar: {\n            sameDay: '[danas u] LT',\n            nextDay: '[sutra u] LT',\n            nextWeek: function () {\n                switch (this.day()) {\n                case 0:\n                    return '[u] [nedelju] [u] LT';\n                case 3:\n                    return '[u] [sredu] [u] LT';\n                case 6:\n                    return '[u] [subotu] [u] LT';\n                case 1:\n                case 2:\n                case 4:\n                case 5:\n                    return '[u] dddd [u] LT';\n                }\n            },\n            lastDay  : '[jue u] LT',\n            lastWeek : function () {\n                var lastWeekDays = [\n                    '[prole] [nedelje] [u] LT',\n                    '[prolog] [ponedeljka] [u] LT',\n                    '[prolog] [utorka] [u] LT',\n                    '[prole] [srede] [u] LT',\n                    '[prolog] [etvrtka] [u] LT',\n                    '[prolog] [petka] [u] LT',\n                    '[prole] [subote] [u] LT'\n                ];\n                return lastWeekDays[this.day()];\n            },\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'za %s',\n            past   : 'pre %s',\n            s      : 'nekoliko sekundi',\n            m      : sr__translator.translate,\n            mm     : sr__translator.translate,\n            h      : sr__translator.translate,\n            hh     : sr__translator.translate,\n            d      : 'dan',\n            dd     : sr__translator.translate,\n            M      : 'mesec',\n            MM     : sr__translator.translate,\n            y      : 'godinu',\n            yy     : sr__translator.translate\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : swedish (sv)\n    //! author : Jens Alm : https://github.com/ulmus\n\n    var sv = _moment__default.defineLocale('sv', {\n        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),\n        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),\n        weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),\n        weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),\n        weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'YYYY-MM-DD',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[Idag] LT',\n            nextDay: '[Imorgon] LT',\n            lastDay: '[Igr] LT',\n            nextWeek: '[P] dddd LT',\n            lastWeek: '[I] dddd[s] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'om %s',\n            past : 'fr %s sedan',\n            s : 'ngra sekunder',\n            m : 'en minut',\n            mm : '%d minuter',\n            h : 'en timme',\n            hh : '%d timmar',\n            d : 'en dag',\n            dd : '%d dagar',\n            M : 'en mnad',\n            MM : '%d mnader',\n            y : 'ett r',\n            yy : '%d r'\n        },\n        ordinalParse: /\\d{1,2}(e|a)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (~~(number % 100 / 10) === 1) ? 'e' :\n                (b === 1) ? 'a' :\n                (b === 2) ? 'a' :\n                (b === 3) ? 'e' : 'e';\n            return number + output;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : tamil (ta)\n    //! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404\n\n    var ta = _moment__default.defineLocale('ta', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY, HH:mm',\n            LLLL : 'dddd, D MMMM YYYY, HH:mm'\n        },\n        calendar : {\n            sameDay : '[] LT',\n            nextDay : '[] LT',\n            nextWeek : 'dddd, LT',\n            lastDay : '[] LT',\n            lastWeek : '[ ] dddd, LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s ',\n            past : '%s ',\n            s : '  ',\n            m : ' ',\n            mm : '%d ',\n            h : '  ',\n            hh : '%d  ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        ordinalParse: /\\d{1,2}/,\n        ordinal : function (number) {\n            return number + '';\n        },\n        // refer http://ta.wikipedia.org/s/1er1\n        meridiemParse: /|||||/,\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 2) {\n                return ' ';\n            } else if (hour < 6) {\n                return ' ';  // \n            } else if (hour < 10) {\n                return ' '; // \n            } else if (hour < 14) {\n                return ' '; // \n            } else if (hour < 18) {\n                return ' '; // \n            } else if (hour < 22) {\n                return ' '; // \n            } else {\n                return ' ';\n            }\n        },\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '') {\n                return hour < 2 ? hour : hour + 12;\n            } else if (meridiem === '' || meridiem === '') {\n                return hour;\n            } else if (meridiem === '') {\n                return hour >= 10 ? hour : hour + 12;\n            } else {\n                return hour + 12;\n            }\n        },\n        week : {\n            dow : 0, // Sunday is the first day of the week.\n            doy : 6  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : thai (th)\n    //! author : Kridsada Thanabulpong : https://github.com/sirn\n\n    var th = _moment__default.defineLocale('th', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'), // yes, three characters difference\n        weekdaysMin : '._._._._._._.'.split('_'),\n        longDateFormat : {\n            LT : 'H  m ',\n            LTS : 'H  m  s ',\n            L : 'YYYY/MM/DD',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY  H  m ',\n            LLLL : 'dddd D MMMM YYYY  H  m '\n        },\n        meridiemParse: /|/,\n        isPM: function (input) {\n            return input === '';\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 12) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay : '[ ] LT',\n            nextDay : '[ ] LT',\n            nextWeek : 'dddd[ ] LT',\n            lastDay : '[ ] LT',\n            lastWeek : '[]dddd[ ] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : '%s',\n            s : '',\n            m : '1 ',\n            mm : '%d ',\n            h : '1 ',\n            hh : '%d ',\n            d : '1 ',\n            dd : '%d ',\n            M : '1 ',\n            MM : '%d ',\n            y : '1 ',\n            yy : '%d '\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Tagalog/Filipino (tl-ph)\n    //! author : Dan Hagman\n\n    var tl_ph = _moment__default.defineLocale('tl-ph', {\n        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),\n        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),\n        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),\n        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),\n        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'MM/D/YYYY',\n            LL : 'MMMM D, YYYY',\n            LLL : 'MMMM D, YYYY HH:mm',\n            LLLL : 'dddd, MMMM DD, YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[Ngayon sa] LT',\n            nextDay: '[Bukas sa] LT',\n            nextWeek: 'dddd [sa] LT',\n            lastDay: '[Kahapon sa] LT',\n            lastWeek: 'dddd [huling linggo] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'sa loob ng %s',\n            past : '%s ang nakalipas',\n            s : 'ilang segundo',\n            m : 'isang minuto',\n            mm : '%d minuto',\n            h : 'isang oras',\n            hh : '%d oras',\n            d : 'isang araw',\n            dd : '%d araw',\n            M : 'isang buwan',\n            MM : '%d buwan',\n            y : 'isang taon',\n            yy : '%d taon'\n        },\n        ordinalParse: /\\d{1,2}/,\n        ordinal : function (number) {\n            return number;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : turkish (tr)\n    //! authors : Erhan Gundogan : https://github.com/erhangundogan,\n    //!           Burak Yiit Kaya: https://github.com/BYK\n\n    var tr__suffixes = {\n        1: '\\'inci',\n        5: '\\'inci',\n        8: '\\'inci',\n        70: '\\'inci',\n        80: '\\'inci',\n        2: '\\'nci',\n        7: '\\'nci',\n        20: '\\'nci',\n        50: '\\'nci',\n        3: '\\'nc',\n        4: '\\'nc',\n        100: '\\'nc',\n        6: '\\'nc',\n        9: '\\'uncu',\n        10: '\\'uncu',\n        30: '\\'uncu',\n        60: '\\'nc',\n        90: '\\'nc'\n    };\n\n    var tr = _moment__default.defineLocale('tr', {\n        months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),\n        monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),\n        weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),\n        weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),\n        weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd, D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay : '[bugn saat] LT',\n            nextDay : '[yarn saat] LT',\n            nextWeek : '[haftaya] dddd [saat] LT',\n            lastDay : '[dn] LT',\n            lastWeek : '[geen hafta] dddd [saat] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : '%s sonra',\n            past : '%s nce',\n            s : 'birka saniye',\n            m : 'bir dakika',\n            mm : '%d dakika',\n            h : 'bir saat',\n            hh : '%d saat',\n            d : 'bir gn',\n            dd : '%d gn',\n            M : 'bir ay',\n            MM : '%d ay',\n            y : 'bir yl',\n            yy : '%d yl'\n        },\n        ordinalParse: /\\d{1,2}'(inci|nci|nc|nc|uncu|nc)/,\n        ordinal : function (number) {\n            if (number === 0) {  // special case for zero\n                return number + '\\'nc';\n            }\n            var a = number % 10,\n                b = number % 100 - a,\n                c = number >= 100 ? 100 : null;\n            return number + (tr__suffixes[a] || tr__suffixes[b] || tr__suffixes[c]);\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : talossan (tzl)\n    //! author : Robin van der Vliet : https://github.com/robin0van0der0v with the help of Iust Canun\n\n\n    var tzl = _moment__default.defineLocale('tzl', {\n        months : 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),\n        monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),\n        weekdays : 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),\n        weekdaysShort : 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),\n        weekdaysMin : 'S_L_Ma_M_Xh_Vi_S'.split('_'),\n        longDateFormat : {\n            LT : 'HH.mm',\n            LTS : 'LT.ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D. MMMM [dallas] YYYY',\n            LLL : 'D. MMMM [dallas] YYYY LT',\n            LLLL : 'dddd, [li] D. MMMM [dallas] YYYY LT'\n        },\n        meridiem : function (hours, minutes, isLower) {\n            if (hours > 11) {\n                return isLower ? 'd\\'o' : 'D\\'O';\n            } else {\n                return isLower ? 'd\\'a' : 'D\\'A';\n            }\n        },\n        calendar : {\n            sameDay : '[oxhi ] LT',\n            nextDay : '[dem ] LT',\n            nextWeek : 'dddd [] LT',\n            lastDay : '[ieiri ] LT',\n            lastWeek : '[sr el] dddd [lasteu ] LT',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : 'osprei %s',\n            past : 'ja%s',\n            s : tzl__processRelativeTime,\n            m : tzl__processRelativeTime,\n            mm : tzl__processRelativeTime,\n            h : tzl__processRelativeTime,\n            hh : tzl__processRelativeTime,\n            d : tzl__processRelativeTime,\n            dd : tzl__processRelativeTime,\n            M : tzl__processRelativeTime,\n            MM : tzl__processRelativeTime,\n            y : tzl__processRelativeTime,\n            yy : tzl__processRelativeTime\n        },\n        ordinalParse: /\\d{1,2}\\./,\n        ordinal : '%d.',\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    function tzl__processRelativeTime(number, withoutSuffix, key, isFuture) {\n        var format = {\n            's': ['viensas secunds', '\\'iensas secunds'],\n            'm': ['\\'n mut', '\\'iens mut'],\n            'mm': [number + ' muts', ' ' + number + ' muts'],\n            'h': ['\\'n ora', '\\'iensa ora'],\n            'hh': [number + ' oras', ' ' + number + ' oras'],\n            'd': ['\\'n ziua', '\\'iensa ziua'],\n            'dd': [number + ' ziuas', ' ' + number + ' ziuas'],\n            'M': ['\\'n mes', '\\'iens mes'],\n            'MM': [number + ' mesen', ' ' + number + ' mesen'],\n            'y': ['\\'n ar', '\\'iens ar'],\n            'yy': [number + ' ars', ' ' + number + ' ars']\n        };\n        return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1].trim());\n    }\n\n    //! moment.js locale configuration\n    //! locale : Morocco Central Atlas Tamazit in Latin (tzm-latn)\n    //! author : Abdel Said : https://github.com/abdelsaid\n\n    var tzm_latn = _moment__default.defineLocale('tzm-latn', {\n        months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),\n        monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),\n        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),\n        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),\n        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[asdkh g] LT',\n            nextDay: '[aska g] LT',\n            nextWeek: 'dddd [g] LT',\n            lastDay: '[assant g] LT',\n            lastWeek: 'dddd [g] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : 'dadkh s yan %s',\n            past : 'yan %s',\n            s : 'imik',\n            m : 'minu',\n            mm : '%d minu',\n            h : 'saa',\n            hh : '%d tassain',\n            d : 'ass',\n            dd : '%d ossan',\n            M : 'ayowr',\n            MM : '%d iyyirn',\n            y : 'asgas',\n            yy : '%d isgasn'\n        },\n        week : {\n            dow : 6, // Saturday is the first day of the week.\n            doy : 12  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : Morocco Central Atlas Tamazit (tzm)\n    //! author : Abdel Said : https://github.com/abdelsaid\n\n    var tzm = _moment__default.defineLocale('tzm', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS: 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'dddd D MMMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[ ] LT',\n            nextDay: '[ ] LT',\n            nextWeek: 'dddd [] LT',\n            lastDay: '[ ] LT',\n            lastWeek: 'dddd [] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : '   %s',\n            past : ' %s',\n            s : '',\n            m : '',\n            mm : '%d ',\n            h : '',\n            hh : '%d ',\n            d : '',\n            dd : '%d o',\n            M : 'o',\n            MM : '%d ',\n            y : '',\n            yy : '%d '\n        },\n        week : {\n            dow : 6, // Saturday is the first day of the week.\n            doy : 12  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : ukrainian (uk)\n    //! author : zemlanin : https://github.com/zemlanin\n    //! Author : Menelion Elensle : https://github.com/Oire\n\n    function uk__plural(word, num) {\n        var forms = word.split('_');\n        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);\n    }\n    function uk__relativeTimeWithPlural(number, withoutSuffix, key) {\n        var format = {\n            'mm': '__',\n            'hh': '__',\n            'dd': '__',\n            'MM': '__',\n            'yy': '__'\n        };\n        if (key === 'm') {\n            return withoutSuffix ? '' : '';\n        }\n        else if (key === 'h') {\n            return withoutSuffix ? '' : '';\n        }\n        else {\n            return number + ' ' + uk__plural(format[key], +number);\n        }\n    }\n    function uk__monthsCaseReplace(m, format) {\n        var months = {\n            'nominative': '___________'.split('_'),\n            'accusative': '___________'.split('_')\n        },\n        nounCase = (/D[oD]? *MMMM?/).test(format) ?\n            'accusative' :\n            'nominative';\n        return months[nounCase][m.month()];\n    }\n    function uk__weekdaysCaseReplace(m, format) {\n        var weekdays = {\n            'nominative': '______'.split('_'),\n            'accusative': '______'.split('_'),\n            'genitive': '______'.split('_')\n        },\n        nounCase = (/(\\[[]\\]) ?dddd/).test(format) ?\n            'accusative' :\n            ((/\\[?(?:|)? ?\\] ?dddd/).test(format) ?\n                'genitive' :\n                'nominative');\n        return weekdays[nounCase][m.day()];\n    }\n    function processHoursFunction(str) {\n        return function () {\n            return str + '' + (this.hours() === 11 ? '' : '') + '] LT';\n        };\n    }\n\n    var uk = _moment__default.defineLocale('uk', {\n        months : uk__monthsCaseReplace,\n        monthsShort : '___________'.split('_'),\n        weekdays : uk__weekdaysCaseReplace,\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD.MM.YYYY',\n            LL : 'D MMMM YYYY .',\n            LLL : 'D MMMM YYYY ., HH:mm',\n            LLLL : 'dddd, D MMMM YYYY ., HH:mm'\n        },\n        calendar : {\n            sameDay: processHoursFunction('[ '),\n            nextDay: processHoursFunction('[ '),\n            lastDay: processHoursFunction('[ '),\n            nextWeek: processHoursFunction('[] dddd ['),\n            lastWeek: function () {\n                switch (this.day()) {\n                case 0:\n                case 3:\n                case 5:\n                case 6:\n                    return processHoursFunction('[] dddd [').call(this);\n                case 1:\n                case 2:\n                case 4:\n                    return processHoursFunction('[] dddd [').call(this);\n                }\n            },\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : ' %s',\n            past : '%s ',\n            s : ' ',\n            m : uk__relativeTimeWithPlural,\n            mm : uk__relativeTimeWithPlural,\n            h : '',\n            hh : uk__relativeTimeWithPlural,\n            d : '',\n            dd : uk__relativeTimeWithPlural,\n            M : '',\n            MM : uk__relativeTimeWithPlural,\n            y : '',\n            yy : uk__relativeTimeWithPlural\n        },\n        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason\n        meridiemParse: /|||/,\n        isPM: function (input) {\n            return /^(|)$/.test(input);\n        },\n        meridiem : function (hour, minute, isLower) {\n            if (hour < 4) {\n                return '';\n            } else if (hour < 12) {\n                return '';\n            } else if (hour < 17) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        ordinalParse: /\\d{1,2}-(|)/,\n        ordinal: function (number, period) {\n            switch (period) {\n            case 'M':\n            case 'd':\n            case 'DDD':\n            case 'w':\n            case 'W':\n                return number + '-';\n            case 'D':\n                return number + '-';\n            default:\n                return number;\n            }\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 1st is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : uzbek (uz)\n    //! author : Sardor Muminov : https://github.com/muminoff\n\n    var uz = _moment__default.defineLocale('uz', {\n        months : '___________'.split('_'),\n        monthsShort : '___________'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM YYYY',\n            LLL : 'D MMMM YYYY HH:mm',\n            LLLL : 'D MMMM YYYY, dddd HH:mm'\n        },\n        calendar : {\n            sameDay : '[ ] LT []',\n            nextDay : '[] LT []',\n            nextWeek : 'dddd [ ] LT []',\n            lastDay : '[ ] LT []',\n            lastWeek : '[] dddd [ ] LT []',\n            sameElse : 'L'\n        },\n        relativeTime : {\n            future : ' %s ',\n            past : '  %s ',\n            s : '',\n            m : ' ',\n            mm : '%d ',\n            h : ' ',\n            hh : '%d ',\n            d : ' ',\n            dd : '%d ',\n            M : ' ',\n            MM : '%d ',\n            y : ' ',\n            yy : '%d '\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 7  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : vietnamese (vi)\n    //! author : Bang Nguyen : https://github.com/bangnk\n\n    var vi = _moment__default.defineLocale('vi', {\n        months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),\n        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),\n        weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),\n        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),\n        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),\n        longDateFormat : {\n            LT : 'HH:mm',\n            LTS : 'HH:mm:ss',\n            L : 'DD/MM/YYYY',\n            LL : 'D MMMM [nm] YYYY',\n            LLL : 'D MMMM [nm] YYYY HH:mm',\n            LLLL : 'dddd, D MMMM [nm] YYYY HH:mm',\n            l : 'DD/M/YYYY',\n            ll : 'D MMM YYYY',\n            lll : 'D MMM YYYY HH:mm',\n            llll : 'ddd, D MMM YYYY HH:mm'\n        },\n        calendar : {\n            sameDay: '[Hm nay lc] LT',\n            nextDay: '[Ngy mai lc] LT',\n            nextWeek: 'dddd [tun ti lc] LT',\n            lastDay: '[Hm qua lc] LT',\n            lastWeek: 'dddd [tun ri lc] LT',\n            sameElse: 'L'\n        },\n        relativeTime : {\n            future : '%s ti',\n            past : '%s trc',\n            s : 'vi giy',\n            m : 'mt pht',\n            mm : '%d pht',\n            h : 'mt gi',\n            hh : '%d gi',\n            d : 'mt ngy',\n            dd : '%d ngy',\n            M : 'mt thng',\n            MM : '%d thng',\n            y : 'mt nm',\n            yy : '%d nm'\n        },\n        ordinalParse: /\\d{1,2}/,\n        ordinal : function (number) {\n            return number;\n        },\n        week : {\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : chinese (zh-cn)\n    //! author : suupic : https://github.com/suupic\n    //! author : Zeno Zeng : https://github.com/zenozeng\n\n    var zh_cn = _moment__default.defineLocale('zh-cn', {\n        months : '___________'.split('_'),\n        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'Ahmm',\n            LTS : 'Ahms',\n            L : 'YYYY-MM-DD',\n            LL : 'YYYYMMMD',\n            LLL : 'YYYYMMMDAhmm',\n            LLLL : 'YYYYMMMDddddAhmm',\n            l : 'YYYY-MM-DD',\n            ll : 'YYYYMMMD',\n            lll : 'YYYYMMMDAhmm',\n            llll : 'YYYYMMMDddddAhmm'\n        },\n        meridiemParse: /|||||/,\n        meridiemHour: function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '' || meridiem === '' ||\n                    meridiem === '') {\n                return hour;\n            } else if (meridiem === '' || meridiem === '') {\n                return hour + 12;\n            } else {\n                // ''\n                return hour >= 11 ? hour : hour + 12;\n            }\n        },\n        meridiem : function (hour, minute, isLower) {\n            var hm = hour * 100 + minute;\n            if (hm < 600) {\n                return '';\n            } else if (hm < 900) {\n                return '';\n            } else if (hm < 1130) {\n                return '';\n            } else if (hm < 1230) {\n                return '';\n            } else if (hm < 1800) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay : function () {\n                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';\n            },\n            nextDay : function () {\n                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';\n            },\n            lastDay : function () {\n                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';\n            },\n            nextWeek : function () {\n                var startOfWeek, prefix;\n                startOfWeek = _moment__default().startOf('week');\n                prefix = this.unix() - startOfWeek.unix() >= 7 * 24 * 3600 ? '[]' : '[]';\n                return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';\n            },\n            lastWeek : function () {\n                var startOfWeek, prefix;\n                startOfWeek = _moment__default().startOf('week');\n                prefix = this.unix() < startOfWeek.unix()  ? '[]' : '[]';\n                return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';\n            },\n            sameElse : 'LL'\n        },\n        ordinalParse: /\\d{1,2}(||)/,\n        ordinal : function (number, period) {\n            switch (period) {\n            case 'd':\n            case 'D':\n            case 'DDD':\n                return number + '';\n            case 'M':\n                return number + '';\n            case 'w':\n            case 'W':\n                return number + '';\n            default:\n                return number;\n            }\n        },\n        relativeTime : {\n            future : '%s',\n            past : '%s',\n            s : '',\n            m : '1 ',\n            mm : '%d ',\n            h : '1 ',\n            hh : '%d ',\n            d : '1 ',\n            dd : '%d ',\n            M : '1 ',\n            MM : '%d ',\n            y : '1 ',\n            yy : '%d '\n        },\n        week : {\n            // GB/T 7408-1994ISO 8601:1988\n            dow : 1, // Monday is the first day of the week.\n            doy : 4  // The week that contains Jan 4th is the first week of the year.\n        }\n    });\n\n    //! moment.js locale configuration\n    //! locale : traditional chinese (zh-tw)\n    //! author : Ben : https://github.com/ben-lin\n\n    var zh_tw = _moment__default.defineLocale('zh-tw', {\n        months : '___________'.split('_'),\n        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),\n        weekdays : '______'.split('_'),\n        weekdaysShort : '______'.split('_'),\n        weekdaysMin : '______'.split('_'),\n        longDateFormat : {\n            LT : 'Ahmm',\n            LTS : 'Ahms',\n            L : 'YYYYMMMD',\n            LL : 'YYYYMMMD',\n            LLL : 'YYYYMMMDAhmm',\n            LLLL : 'YYYYMMMDddddAhmm',\n            l : 'YYYYMMMD',\n            ll : 'YYYYMMMD',\n            lll : 'YYYYMMMDAhmm',\n            llll : 'YYYYMMMDddddAhmm'\n        },\n        meridiemParse: /||||/,\n        meridiemHour : function (hour, meridiem) {\n            if (hour === 12) {\n                hour = 0;\n            }\n            if (meridiem === '' || meridiem === '') {\n                return hour;\n            } else if (meridiem === '') {\n                return hour >= 11 ? hour : hour + 12;\n            } else if (meridiem === '' || meridiem === '') {\n                return hour + 12;\n            }\n        },\n        meridiem : function (hour, minute, isLower) {\n            var hm = hour * 100 + minute;\n            if (hm < 900) {\n                return '';\n            } else if (hm < 1130) {\n                return '';\n            } else if (hm < 1230) {\n                return '';\n            } else if (hm < 1800) {\n                return '';\n            } else {\n                return '';\n            }\n        },\n        calendar : {\n            sameDay : '[]LT',\n            nextDay : '[]LT',\n            nextWeek : '[]ddddLT',\n            lastDay : '[]LT',\n            lastWeek : '[]ddddLT',\n            sameElse : 'L'\n        },\n        ordinalParse: /\\d{1,2}(||)/,\n        ordinal : function (number, period) {\n            switch (period) {\n            case 'd' :\n            case 'D' :\n            case 'DDD' :\n                return number + '';\n            case 'M' :\n                return number + '';\n            case 'w' :\n            case 'W' :\n                return number + '';\n            default :\n                return number;\n            }\n        },\n        relativeTime : {\n            future : '%s',\n            past : '%s',\n            s : '',\n            m : '',\n            mm : '%d',\n            h : '',\n            hh : '%d',\n            d : '',\n            dd : '%d',\n            M : '',\n            MM : '%d',\n            y : '',\n            yy : '%d'\n        }\n    });\n\n    var moment_with_locales = _moment__default;\n    moment_with_locales.locale('en');\n\n    return moment_with_locales;\n\n}));","/**\n* @version: 2.1.19\n* @author: Dan Grossman http://www.dangrossman.info/\n* @copyright: Copyright (c) 2012-2015 Dan Grossman. All rights reserved.\n* @license: Licensed under the MIT license. See http://www.opensource.org/licenses/mit-license.php\n* @website: https://www.improvely.com/\n*/\n\n(function(root, factory) {\n\n  if (typeof define === 'function' && define.amd) {\n    define(['moment', 'jquery', 'exports'], function(momentjs, $, exports) {\n      root.daterangepicker = factory(root, exports, momentjs, $);\n    });\n\n  } else if (typeof exports !== 'undefined') {\n      var momentjs = require('moment');\n      var jQuery = (typeof window != 'undefined') ? window.jQuery : undefined;  //isomorphic issue\n      if (!jQuery) {\n          try {\n              jQuery = require('jquery');\n              if (!jQuery.fn) jQuery.fn = {}; //isomorphic issue\n          } catch (err) {\n              if (!jQuery) throw new Error('jQuery dependency not found');\n          }\n      }\n\n    factory(root, exports, momentjs, jQuery);\n\n  // Finally, as a browser global.\n  } else {\n    root.daterangepicker = factory(root, {}, root.moment || moment, (root.jQuery || root.Zepto || root.ender || root.$));\n  }\n\n}(this || {}, function(root, daterangepicker, moment, $) { // 'this' doesn't exist on a server\n\n    var DateRangePicker = function(element, options, cb) {\n\n        //default settings for options\n        this.parentEl = 'body';\n        this.element = $(element);\n        this.startDate = moment().startOf('day');\n        this.endDate = moment().endOf('day');\n        this.minDate = false;\n        this.maxDate = false;\n        this.dateLimit = false;\n        this.autoApply = false;\n        this.singleDatePicker = false;\n        this.showDropdowns = false;\n        this.showWeekNumbers = false;\n        this.showISOWeekNumbers = false;\n        this.timePicker = false;\n        this.timePicker24Hour = false;\n        this.timePickerIncrement = 1;\n        this.timePickerSeconds = false;\n        this.linkedCalendars = true;\n        this.autoUpdateInput = true;\n        this.alwaysShowCalendars = false;\n        this.ranges = {};\n\n        this.opens = 'right';\n        if (this.element.hasClass('pull-right'))\n            this.opens = 'left';\n\n        this.drops = 'down';\n        if (this.element.hasClass('dropup'))\n            this.drops = 'up';\n\n        this.buttonClasses = 'btn btn-sm';\n        this.applyClass = 'btn-success';\n        this.cancelClass = 'btn-default';\n\n        this.locale = {\n            format: 'MM/DD/YYYY',\n            separator: ' - ',\n            applyLabel: 'Apply',\n            cancelLabel: 'Cancel',\n            weekLabel: 'W',\n            customRangeLabel: 'Custom Range',\n            daysOfWeek: moment.weekdaysMin(),\n            monthNames: moment.monthsShort(),\n            firstDay: moment.localeData().firstDayOfWeek()\n        };\n\n        this.callback = function() { };\n\n        //some state information\n        this.isShowing = false;\n        this.leftCalendar = {};\n        this.rightCalendar = {};\n\n        //custom options from user\n        if (typeof options !== 'object' || options === null)\n            options = {};\n\n        //allow setting options with data attributes\n        //data-api options will be overwritten with custom javascript options\n        options = $.extend(this.element.data(), options);\n\n        //html template for the picker UI\n        if (typeof options.template !== 'string' && !(options.template instanceof $))\n            options.template = '<div class=\"daterangepicker dropdown-menu\">' +\n                '<div class=\"calendar left\">' +\n                    '<div class=\"daterangepicker_input\">' +\n                      '<input class=\"input-mini\" type=\"text\" name=\"daterangepicker_start\" value=\"\" />' +\n                      '<i class=\"fa fa-calendar glyphicon glyphicon-calendar\"></i>' +\n                      '<div class=\"calendar-time\">' +\n                        '<div></div>' +\n                        '<i class=\"fa fa-clock-o glyphicon glyphicon-time\"></i>' +\n                      '</div>' +\n                    '</div>' +\n                    '<div class=\"calendar-table\"></div>' +\n                '</div>' +\n                '<div class=\"calendar right\">' +\n                    '<div class=\"daterangepicker_input\">' +\n                      '<input class=\"input-mini\" type=\"text\" name=\"daterangepicker_end\" value=\"\" />' +\n                      '<i class=\"fa fa-calendar glyphicon glyphicon-calendar\"></i>' +\n                      '<div class=\"calendar-time\">' +\n                        '<div></div>' +\n                        '<i class=\"fa fa-clock-o glyphicon glyphicon-time\"></i>' +\n                      '</div>' +\n                    '</div>' +\n                    '<div class=\"calendar-table\"></div>' +\n                '</div>' +\n                '<div class=\"ranges\">' +\n                    '<div class=\"range_inputs\">' +\n                        '<button class=\"applyBtn\" disabled=\"disabled\" type=\"button\"></button> ' +\n                        '<button class=\"cancelBtn\" type=\"button\"></button>' +\n                    '</div>' +\n                '</div>' +\n            '</div>';\n\n        this.parentEl = (options.parentEl && $(options.parentEl).length) ? $(options.parentEl) : $(this.parentEl);\n        this.container = $(options.template).appendTo(this.parentEl);\n\n        //\n        // handle all the possible options overriding defaults\n        //\n\n        if (typeof options.locale === 'object') {\n\n            if (typeof options.locale.format === 'string')\n                this.locale.format = options.locale.format;\n\n            if (typeof options.locale.separator === 'string')\n                this.locale.separator = options.locale.separator;\n\n            if (typeof options.locale.daysOfWeek === 'object')\n                this.locale.daysOfWeek = options.locale.daysOfWeek.slice();\n\n            if (typeof options.locale.monthNames === 'object')\n              this.locale.monthNames = options.locale.monthNames.slice();\n\n            if (typeof options.locale.firstDay === 'number')\n              this.locale.firstDay = options.locale.firstDay;\n\n            if (typeof options.locale.applyLabel === 'string')\n              this.locale.applyLabel = options.locale.applyLabel;\n\n            if (typeof options.locale.cancelLabel === 'string')\n              this.locale.cancelLabel = options.locale.cancelLabel;\n\n            if (typeof options.locale.weekLabel === 'string')\n              this.locale.weekLabel = options.locale.weekLabel;\n\n            if (typeof options.locale.customRangeLabel === 'string')\n              this.locale.customRangeLabel = options.locale.customRangeLabel;\n\n        }\n\n        if (typeof options.startDate === 'string')\n            this.startDate = moment(options.startDate, this.locale.format);\n\n        if (typeof options.endDate === 'string')\n            this.endDate = moment(options.endDate, this.locale.format);\n\n        if (typeof options.minDate === 'string')\n            this.minDate = moment(options.minDate, this.locale.format);\n\n        if (typeof options.maxDate === 'string')\n            this.maxDate = moment(options.maxDate, this.locale.format);\n\n        if (typeof options.startDate === 'object')\n            this.startDate = moment(options.startDate);\n\n        if (typeof options.endDate === 'object')\n            this.endDate = moment(options.endDate);\n\n        if (typeof options.minDate === 'object')\n            this.minDate = moment(options.minDate);\n\n        if (typeof options.maxDate === 'object')\n            this.maxDate = moment(options.maxDate);\n\n        // sanity check for bad options\n        if (this.minDate && this.startDate.isBefore(this.minDate))\n            this.startDate = this.minDate.clone();\n\n        // sanity check for bad options\n        if (this.maxDate && this.endDate.isAfter(this.maxDate))\n            this.endDate = this.maxDate.clone();\n\n        if (typeof options.applyClass === 'string')\n            this.applyClass = options.applyClass;\n\n        if (typeof options.cancelClass === 'string')\n            this.cancelClass = options.cancelClass;\n\n        if (typeof options.dateLimit === 'object')\n            this.dateLimit = options.dateLimit;\n\n        if (typeof options.opens === 'string')\n            this.opens = options.opens;\n\n        if (typeof options.drops === 'string')\n            this.drops = options.drops;\n\n        if (typeof options.showWeekNumbers === 'boolean')\n            this.showWeekNumbers = options.showWeekNumbers;\n\n        if (typeof options.showISOWeekNumbers === 'boolean')\n            this.showISOWeekNumbers = options.showISOWeekNumbers;\n\n        if (typeof options.buttonClasses === 'string')\n            this.buttonClasses = options.buttonClasses;\n\n        if (typeof options.buttonClasses === 'object')\n            this.buttonClasses = options.buttonClasses.join(' ');\n\n        if (typeof options.showDropdowns === 'boolean')\n            this.showDropdowns = options.showDropdowns;\n\n        if (typeof options.singleDatePicker === 'boolean') {\n            this.singleDatePicker = options.singleDatePicker;\n            if (this.singleDatePicker)\n                this.endDate = this.startDate.clone();\n        }\n\n        if (typeof options.timePicker === 'boolean')\n            this.timePicker = options.timePicker;\n\n        if (typeof options.timePickerSeconds === 'boolean')\n            this.timePickerSeconds = options.timePickerSeconds;\n\n        if (typeof options.timePickerIncrement === 'number')\n            this.timePickerIncrement = options.timePickerIncrement;\n\n        if (typeof options.timePicker24Hour === 'boolean')\n            this.timePicker24Hour = options.timePicker24Hour;\n\n        if (typeof options.autoApply === 'boolean')\n            this.autoApply = options.autoApply;\n\n        if (typeof options.autoUpdateInput === 'boolean')\n            this.autoUpdateInput = options.autoUpdateInput;\n\n        if (typeof options.linkedCalendars === 'boolean')\n            this.linkedCalendars = options.linkedCalendars;\n\n        if (typeof options.isInvalidDate === 'function')\n            this.isInvalidDate = options.isInvalidDate;\n\n        if (typeof options.alwaysShowCalendars === 'boolean')\n            this.alwaysShowCalendars = options.alwaysShowCalendars;\n\n        // update day names order to firstDay\n        if (this.locale.firstDay != 0) {\n            var iterator = this.locale.firstDay;\n            while (iterator > 0) {\n                this.locale.daysOfWeek.push(this.locale.daysOfWeek.shift());\n                iterator--;\n            }\n        }\n\n        var start, end, range;\n\n        //if no start/end dates set, check if an input element contains initial values\n        if (typeof options.startDate === 'undefined' && typeof options.endDate === 'undefined') {\n            if ($(this.element).is('input[type=text]')) {\n                var val = $(this.element).val(),\n                    split = val.split(this.locale.separator);\n\n                start = end = null;\n\n                if (split.length == 2) {\n                    start = moment(split[0], this.locale.format);\n                    end = moment(split[1], this.locale.format);\n                } else if (this.singleDatePicker && val !== \"\") {\n                    start = moment(val, this.locale.format);\n                    end = moment(val, this.locale.format);\n                }\n                if (start !== null && end !== null) {\n                    this.setStartDate(start);\n                    this.setEndDate(end);\n                }\n            }\n        }\n\n        if (typeof options.ranges === 'object') {\n            for (range in options.ranges) {\n\n                if (typeof options.ranges[range][0] === 'string')\n                    start = moment(options.ranges[range][0], this.locale.format);\n                else\n                    start = moment(options.ranges[range][0]);\n\n                if (typeof options.ranges[range][1] === 'string')\n                    end = moment(options.ranges[range][1], this.locale.format);\n                else\n                    end = moment(options.ranges[range][1]);\n\n                // If the start or end date exceed those allowed by the minDate or dateLimit\n                // options, shorten the range to the allowable period.\n                if (this.minDate && start.isBefore(this.minDate))\n                    start = this.minDate.clone();\n\n                var maxDate = this.maxDate;\n                if (this.dateLimit && start.clone().add(this.dateLimit).isAfter(maxDate))\n                    maxDate = start.clone().add(this.dateLimit);\n                if (maxDate && end.isAfter(maxDate))\n                    end = maxDate.clone();\n\n                // If the end of the range is before the minimum or the start of the range is\n                // after the maximum, don't display this range option at all.\n                if ((this.minDate && end.isBefore(this.minDate)) || (maxDate && start.isAfter(maxDate)))\n                    continue;\n                \n                //Support unicode chars in the range names.\n                var elem = document.createElement('textarea');\n                elem.innerHTML = range;\n                var rangeHtml = elem.value;\n\n                this.ranges[rangeHtml] = [start, end];\n            }\n\n            var list = '<ul>';\n            for (range in this.ranges) {\n                list += '<li>' + range + '</li>';\n            }\n            list += '<li>' + this.locale.customRangeLabel + '</li>';\n            list += '</ul>';\n            this.container.find('.ranges').prepend(list);\n        }\n\n        if (typeof cb === 'function') {\n            this.callback = cb;\n        }\n\n        if (!this.timePicker) {\n            this.startDate = this.startDate.startOf('day');\n            this.endDate = this.endDate.endOf('day');\n            this.container.find('.calendar-time').hide();\n        }\n\n        //can't be used together for now\n        if (this.timePicker && this.autoApply)\n            this.autoApply = false;\n\n        if (this.autoApply && typeof options.ranges !== 'object') {\n            this.container.find('.ranges').hide();\n        } else if (this.autoApply) {\n            this.container.find('.applyBtn, .cancelBtn').addClass('hide');\n        }\n\n        if (this.singleDatePicker) {\n            this.container.addClass('single');\n            this.container.find('.calendar.left').addClass('single');\n            this.container.find('.calendar.left').show();\n            this.container.find('.calendar.right').hide();\n            this.container.find('.daterangepicker_input input, .daterangepicker_input i').hide();\n            if (!this.timePicker) {\n                this.container.find('.ranges').hide();\n            }\n        }\n\n        if ((typeof options.ranges === 'undefined' && !this.singleDatePicker) || this.alwaysShowCalendars) {\n            this.container.addClass('show-calendar');\n        }\n\n        this.container.addClass('opens' + this.opens);\n\n        //swap the position of the predefined ranges if opens right\n        if (typeof options.ranges !== 'undefined' && this.opens == 'right') {\n            var ranges = this.container.find('.ranges');\n            var html = ranges.clone();\n            ranges.remove();\n            this.container.find('.calendar.left').parent().prepend(html);\n        }\n\n        //apply CSS classes and labels to buttons\n        this.container.find('.applyBtn, .cancelBtn').addClass(this.buttonClasses);\n        if (this.applyClass.length)\n            this.container.find('.applyBtn').addClass(this.applyClass);\n        if (this.cancelClass.length)\n            this.container.find('.cancelBtn').addClass(this.cancelClass);\n        this.container.find('.applyBtn').html(this.locale.applyLabel);\n        this.container.find('.cancelBtn').html(this.locale.cancelLabel);\n\n        //\n        // event listeners\n        //\n\n        this.container.find('.calendar')\n            .on('click.daterangepicker', '.prev', $.proxy(this.clickPrev, this))\n            .on('click.daterangepicker', '.next', $.proxy(this.clickNext, this))\n            .on('click.daterangepicker', 'td.available', $.proxy(this.clickDate, this))\n            .on('mouseenter.daterangepicker', 'td.available', $.proxy(this.hoverDate, this))\n            .on('mouseleave.daterangepicker', 'td.available', $.proxy(this.updateFormInputs, this))\n            .on('change.daterangepicker', 'select.yearselect', $.proxy(this.monthOrYearChanged, this))\n            .on('change.daterangepicker', 'select.monthselect', $.proxy(this.monthOrYearChanged, this))\n            .on('change.daterangepicker', 'select.hourselect,select.minuteselect,select.secondselect,select.ampmselect', $.proxy(this.timeChanged, this))\n            .on('click.daterangepicker', '.daterangepicker_input input', $.proxy(this.showCalendars, this))\n            //.on('keyup.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsChanged, this))\n            .on('change.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsChanged, this));\n\n        this.container.find('.ranges')\n            .on('click.daterangepicker', 'button.applyBtn', $.proxy(this.clickApply, this))\n            .on('click.daterangepicker', 'button.cancelBtn', $.proxy(this.clickCancel, this))\n            .on('click.daterangepicker', 'li', $.proxy(this.clickRange, this))\n            .on('mouseenter.daterangepicker', 'li', $.proxy(this.hoverRange, this))\n            .on('mouseleave.daterangepicker', 'li', $.proxy(this.updateFormInputs, this));\n\n        if (this.element.is('input')) {\n            this.element.on({\n                'click.daterangepicker': $.proxy(this.show, this),\n                'focus.daterangepicker': $.proxy(this.show, this),\n                'keyup.daterangepicker': $.proxy(this.elementChanged, this),\n                'keydown.daterangepicker': $.proxy(this.keydown, this)\n            });\n        } else {\n            this.element.on('click.daterangepicker', $.proxy(this.toggle, this));\n        }\n\n        //\n        // if attached to a text input, set the initial value\n        //\n\n        if (this.element.is('input') && !this.singleDatePicker && this.autoUpdateInput) {\n            this.element.val(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));\n            this.element.trigger('change');\n        } else if (this.element.is('input') && this.autoUpdateInput) {\n            this.element.val(this.startDate.format(this.locale.format));\n            this.element.trigger('change');\n        }\n\n    };\n\n    DateRangePicker.prototype = {\n\n        constructor: DateRangePicker,\n\n        setStartDate: function(startDate) {\n            if (typeof startDate === 'string')\n                this.startDate = moment(startDate, this.locale.format);\n\n            if (typeof startDate === 'object')\n                this.startDate = moment(startDate);\n\n            if (!this.timePicker)\n                this.startDate = this.startDate.startOf('day');\n\n            if (this.timePicker && this.timePickerIncrement)\n                this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);\n\n            if (this.minDate && this.startDate.isBefore(this.minDate))\n                this.startDate = this.minDate;\n\n            if (this.maxDate && this.startDate.isAfter(this.maxDate))\n                this.startDate = this.maxDate;\n\n            if (!this.isShowing)\n                this.updateElement();\n\n            this.updateMonthsInView();\n        },\n\n        setEndDate: function(endDate) {\n            if (typeof endDate === 'string')\n                this.endDate = moment(endDate, this.locale.format);\n\n            if (typeof endDate === 'object')\n                this.endDate = moment(endDate);\n\n            if (!this.timePicker)\n                this.endDate = this.endDate.endOf('day');\n\n            if (this.timePicker && this.timePickerIncrement)\n                this.endDate.minute(Math.round(this.endDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);\n\n            if (this.endDate.isBefore(this.startDate))\n                this.endDate = this.startDate.clone();\n\n            if (this.maxDate && this.endDate.isAfter(this.maxDate))\n                this.endDate = this.maxDate;\n\n            if (this.dateLimit && this.startDate.clone().add(this.dateLimit).isBefore(this.endDate))\n                this.endDate = this.startDate.clone().add(this.dateLimit);\n\n            this.previousRightTime = this.endDate.clone();\n\n            if (!this.isShowing)\n                this.updateElement();\n\n            this.updateMonthsInView();\n        },\n\n        isInvalidDate: function() {\n            return false;\n        },\n\n        updateView: function() {\n            if (this.timePicker) {\n                this.renderTimePicker('left');\n                this.renderTimePicker('right');\n                if (!this.endDate) {\n                    this.container.find('.right .calendar-time select').attr('disabled', 'disabled').addClass('disabled');\n                } else {\n                    this.container.find('.right .calendar-time select').removeAttr('disabled').removeClass('disabled');\n                }\n            }\n            if (this.endDate) {\n                this.container.find('input[name=\"daterangepicker_end\"]').removeClass('active');\n                this.container.find('input[name=\"daterangepicker_start\"]').addClass('active');\n            } else {\n                this.container.find('input[name=\"daterangepicker_end\"]').addClass('active');\n                this.container.find('input[name=\"daterangepicker_start\"]').removeClass('active');\n            }\n            this.updateMonthsInView();\n            this.updateCalendars();\n            this.updateFormInputs();\n        },\n\n        updateMonthsInView: function() {\n            if (this.endDate) {\n\n                //if both dates are visible already, do nothing\n                if (!this.singleDatePicker && this.leftCalendar.month && this.rightCalendar.month &&\n                    (this.startDate.format('YYYY-MM') == this.leftCalendar.month.format('YYYY-MM') || this.startDate.format('YYYY-MM') == this.rightCalendar.month.format('YYYY-MM'))\n                    &&\n                    (this.endDate.format('YYYY-MM') == this.leftCalendar.month.format('YYYY-MM') || this.endDate.format('YYYY-MM') == this.rightCalendar.month.format('YYYY-MM'))\n                    ) {\n                    return;\n                }\n\n                this.leftCalendar.month = this.startDate.clone().date(2);\n                if (!this.linkedCalendars && (this.endDate.month() != this.startDate.month() || this.endDate.year() != this.startDate.year())) {\n                    this.rightCalendar.month = this.endDate.clone().date(2);\n                } else {\n                    this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');\n                }\n                \n            } else {\n                if (this.leftCalendar.month.format('YYYY-MM') != this.startDate.format('YYYY-MM') && this.rightCalendar.month.format('YYYY-MM') != this.startDate.format('YYYY-MM')) {\n                    this.leftCalendar.month = this.startDate.clone().date(2);\n                    this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');\n                }\n            }\n        },\n\n        updateCalendars: function() {\n\n            if (this.timePicker) {\n                var hour, minute, second;\n                if (this.endDate) {\n                    hour = parseInt(this.container.find('.left .hourselect').val(), 10);\n                    minute = parseInt(this.container.find('.left .minuteselect').val(), 10);\n                    second = this.timePickerSeconds ? parseInt(this.container.find('.left .secondselect').val(), 10) : 0;\n                    if (!this.timePicker24Hour) {\n                        var ampm = this.container.find('.left .ampmselect').val();\n                        if (ampm === 'PM' && hour < 12)\n                            hour += 12;\n                        if (ampm === 'AM' && hour === 12)\n                            hour = 0;\n                    }\n                } else {\n                    hour = parseInt(this.container.find('.right .hourselect').val(), 10);\n                    minute = parseInt(this.container.find('.right .minuteselect').val(), 10);\n                    second = this.timePickerSeconds ? parseInt(this.container.find('.right .secondselect').val(), 10) : 0;\n                    if (!this.timePicker24Hour) {\n                        var ampm = this.container.find('.right .ampmselect').val();\n                        if (ampm === 'PM' && hour < 12)\n                            hour += 12;\n                        if (ampm === 'AM' && hour === 12)\n                            hour = 0;\n                    }\n                }\n                this.leftCalendar.month.hour(hour).minute(minute).second(second);\n                this.rightCalendar.month.hour(hour).minute(minute).second(second);\n            }\n\n            this.renderCalendar('left');\n            this.renderCalendar('right');\n\n            //highlight any predefined range matching the current start and end dates\n            this.container.find('.ranges li').removeClass('active');\n            if (this.endDate == null) return;\n\n            this.calculateChosenLabel();\n        },\n\n        renderCalendar: function(side) {\n\n            //\n            // Build the matrix of dates that will populate the calendar\n            //\n\n            var calendar = side == 'left' ? this.leftCalendar : this.rightCalendar;\n            var month = calendar.month.month();\n            var year = calendar.month.year();\n            var hour = calendar.month.hour();\n            var minute = calendar.month.minute();\n            var second = calendar.month.second();\n            var daysInMonth = moment([year, month]).daysInMonth();\n            var firstDay = moment([year, month, 1]);\n            var lastDay = moment([year, month, daysInMonth]);\n            var lastMonth = moment(firstDay).subtract(1, 'month').month();\n            var lastYear = moment(firstDay).subtract(1, 'month').year();\n            var daysInLastMonth = moment([lastYear, lastMonth]).daysInMonth();\n            var dayOfWeek = firstDay.day();\n\n            //initialize a 6 rows x 7 columns array for the calendar\n            var calendar = [];\n            calendar.firstDay = firstDay;\n            calendar.lastDay = lastDay;\n\n            for (var i = 0; i < 6; i++) {\n                calendar[i] = [];\n            }\n\n            //populate the calendar with date objects\n            var startDay = daysInLastMonth - dayOfWeek + this.locale.firstDay + 1;\n            if (startDay > daysInLastMonth)\n                startDay -= 7;\n\n            if (dayOfWeek == this.locale.firstDay)\n                startDay = daysInLastMonth - 6;\n\n            var curDate = moment([lastYear, lastMonth, startDay, 12, minute, second]);\n\n            var col, row;\n            for (var i = 0, col = 0, row = 0; i < 42; i++, col++, curDate = moment(curDate).add(24, 'hour')) {\n                if (i > 0 && col % 7 === 0) {\n                    col = 0;\n                    row++;\n                }\n                calendar[row][col] = curDate.clone().hour(hour).minute(minute).second(second);\n                curDate.hour(12);\n\n                if (this.minDate && calendar[row][col].format('YYYY-MM-DD') == this.minDate.format('YYYY-MM-DD') && calendar[row][col].isBefore(this.minDate) && side == 'left') {\n                    calendar[row][col] = this.minDate.clone();\n                }\n\n                if (this.maxDate && calendar[row][col].format('YYYY-MM-DD') == this.maxDate.format('YYYY-MM-DD') && calendar[row][col].isAfter(this.maxDate) && side == 'right') {\n                    calendar[row][col] = this.maxDate.clone();\n                }\n\n            }\n\n            //make the calendar object available to hoverDate/clickDate\n            if (side == 'left') {\n                this.leftCalendar.calendar = calendar;\n            } else {\n                this.rightCalendar.calendar = calendar;\n            }\n\n            //\n            // Display the calendar\n            //\n\n            var minDate = side == 'left' ? this.minDate : this.startDate;\n            var maxDate = this.maxDate;\n            var selected = side == 'left' ? this.startDate : this.endDate;\n\n            var html = '<table class=\"table-condensed\">';\n            html += '<thead>';\n            html += '<tr>';\n\n            // add empty cell for week number\n            if (this.showWeekNumbers || this.showISOWeekNumbers)\n                html += '<th></th>';\n\n            if ((!minDate || minDate.isBefore(calendar.firstDay)) && (!this.linkedCalendars || side == 'left')) {\n                html += '<th class=\"prev available\"><i class=\"fa fa-chevron-left glyphicon glyphicon-chevron-left\"></i></th>';\n            } else {\n                html += '<th></th>';\n            }\n\n            var dateHtml = this.locale.monthNames[calendar[1][1].month()] + calendar[1][1].format(\" YYYY\");\n\n            if (this.showDropdowns) {\n                var currentMonth = calendar[1][1].month();\n                var currentYear = calendar[1][1].year();\n                var maxYear = (maxDate && maxDate.year()) || (currentYear + 5);\n                var minYear = (minDate && minDate.year()) || (currentYear - 50);\n                var inMinYear = currentYear == minYear;\n                var inMaxYear = currentYear == maxYear;\n\n                var monthHtml = '<select class=\"monthselect\">';\n                for (var m = 0; m < 12; m++) {\n                    if ((!inMinYear || m >= minDate.month()) && (!inMaxYear || m <= maxDate.month())) {\n                        monthHtml += \"<option value='\" + m + \"'\" +\n                            (m === currentMonth ? \" selected='selected'\" : \"\") +\n                            \">\" + this.locale.monthNames[m] + \"</option>\";\n                    } else {\n                        monthHtml += \"<option value='\" + m + \"'\" +\n                            (m === currentMonth ? \" selected='selected'\" : \"\") +\n                            \" disabled='disabled'>\" + this.locale.monthNames[m] + \"</option>\";\n                    }\n                }\n                monthHtml += \"</select>\";\n\n                var yearHtml = '<select class=\"yearselect\">';\n                for (var y = minYear; y <= maxYear; y++) {\n                    yearHtml += '<option value=\"' + y + '\"' +\n                        (y === currentYear ? ' selected=\"selected\"' : '') +\n                        '>' + y + '</option>';\n                }\n                yearHtml += '</select>';\n\n                dateHtml = monthHtml + yearHtml;\n            }\n\n            html += '<th colspan=\"5\" class=\"month\">' + dateHtml + '</th>';\n            if ((!maxDate || maxDate.isAfter(calendar.lastDay)) && (!this.linkedCalendars || side == 'right' || this.singleDatePicker)) {\n                html += '<th class=\"next available\"><i class=\"fa fa-chevron-right glyphicon glyphicon-chevron-right\"></i></th>';\n            } else {\n                html += '<th></th>';\n            }\n\n            html += '</tr>';\n            html += '<tr>';\n\n            // add week number label\n            if (this.showWeekNumbers || this.showISOWeekNumbers)\n                html += '<th class=\"week\">' + this.locale.weekLabel + '</th>';\n\n            $.each(this.locale.daysOfWeek, function(index, dayOfWeek) {\n                html += '<th>' + dayOfWeek + '</th>';\n            });\n\n            html += '</tr>';\n            html += '</thead>';\n            html += '<tbody>';\n\n            //adjust maxDate to reflect the dateLimit setting in order to\n            //grey out end dates beyond the dateLimit\n            if (this.endDate == null && this.dateLimit) {\n                var maxLimit = this.startDate.clone().add(this.dateLimit).endOf('day');\n                if (!maxDate || maxLimit.isBefore(maxDate)) {\n                    maxDate = maxLimit;\n                }\n            }\n\n            for (var row = 0; row < 6; row++) {\n                html += '<tr>';\n\n                // add week number\n                if (this.showWeekNumbers)\n                    html += '<td class=\"week\">' + calendar[row][0].week() + '</td>';\n                else if (this.showISOWeekNumbers)\n                    html += '<td class=\"week\">' + calendar[row][0].isoWeek() + '</td>';\n\n                for (var col = 0; col < 7; col++) {\n\n                    var classes = [];\n\n                    //highlight today's date\n                    if (calendar[row][col].isSame(new Date(), \"day\"))\n                        classes.push('today');\n\n                    //highlight weekends\n                    if (calendar[row][col].isoWeekday() > 5)\n                        classes.push('weekend');\n\n                    //grey out the dates in other months displayed at beginning and end of this calendar\n                    if (calendar[row][col].month() != calendar[1][1].month())\n                        classes.push('off');\n\n                    //don't allow selection of dates before the minimum date\n                    if (this.minDate && calendar[row][col].isBefore(this.minDate, 'day'))\n                        classes.push('off', 'disabled');\n\n                    //don't allow selection of dates after the maximum date\n                    if (maxDate && calendar[row][col].isAfter(maxDate, 'day'))\n                        classes.push('off', 'disabled');\n\n                    //don't allow selection of date if a custom function decides it's invalid\n                    if (this.isInvalidDate(calendar[row][col]))\n                        classes.push('off', 'disabled');\n\n                    //highlight the currently selected start date\n                    if (calendar[row][col].format('YYYY-MM-DD') == this.startDate.format('YYYY-MM-DD'))\n                        classes.push('active', 'start-date');\n\n                    //highlight the currently selected end date\n                    if (this.endDate != null && calendar[row][col].format('YYYY-MM-DD') == this.endDate.format('YYYY-MM-DD'))\n                        classes.push('active', 'end-date');\n\n                    //highlight dates in-between the selected dates\n                    if (this.endDate != null && calendar[row][col] > this.startDate && calendar[row][col] < this.endDate)\n                        classes.push('in-range');\n\n                    var cname = '', disabled = false;\n                    for (var i = 0; i < classes.length; i++) {\n                        cname += classes[i] + ' ';\n                        if (classes[i] == 'disabled')\n                            disabled = true;\n                    }\n                    if (!disabled)\n                        cname += 'available';\n\n                    html += '<td class=\"' + cname.replace(/^\\s+|\\s+$/g, '') + '\" data-title=\"' + 'r' + row + 'c' + col + '\">' + calendar[row][col].date() + '</td>';\n\n                }\n                html += '</tr>';\n            }\n\n            html += '</tbody>';\n            html += '</table>';\n\n            this.container.find('.calendar.' + side + ' .calendar-table').html(html);\n\n        },\n\n        renderTimePicker: function(side) {\n\n            var html, selected, minDate, maxDate = this.maxDate;\n\n            if (this.dateLimit && (!this.maxDate || this.startDate.clone().add(this.dateLimit).isAfter(this.maxDate)))\n                maxDate = this.startDate.clone().add(this.dateLimit);\n\n            if (side == 'left') {\n                selected = this.startDate.clone();\n                minDate = this.minDate;\n            } else if (side == 'right') {\n                selected = this.endDate ? this.endDate.clone() : this.previousRightTime.clone();\n                minDate = this.startDate;\n\n                //Preserve the time already selected\n                var timeSelector = this.container.find('.calendar.right .calendar-time div');\n                if (timeSelector.html() != '') {\n\n                    selected.hour(timeSelector.find('.hourselect option:selected').val() || selected.hour());\n                    selected.minute(timeSelector.find('.minuteselect option:selected').val() || selected.minute());\n                    selected.second(timeSelector.find('.secondselect option:selected').val() || selected.second());\n\n                    if (!this.timePicker24Hour) {\n                        var ampm = timeSelector.find('.ampmselect option:selected').val();\n                        if (ampm === 'PM' && selected.hour() < 12)\n                            selected.hour(selected.hour() + 12);\n                        if (ampm === 'AM' && selected.hour() === 12)\n                            selected.hour(0);\n                    }\n\n                    if (selected.isBefore(this.startDate))\n                        selected = this.startDate.clone();\n\n                    if (selected.isAfter(maxDate))\n                        selected = maxDate.clone();\n\n                }\n            }\n\n            //\n            // hours\n            //\n\n            html = '<select class=\"hourselect\">';\n\n            var start = this.timePicker24Hour ? 0 : 1;\n            var end = this.timePicker24Hour ? 23 : 12;\n\n            for (var i = start; i <= end; i++) {\n                var i_in_24 = i;\n                if (!this.timePicker24Hour)\n                    i_in_24 = selected.hour() >= 12 ? (i == 12 ? 12 : i + 12) : (i == 12 ? 0 : i);\n\n                var time = selected.clone().hour(i_in_24);\n                var disabled = false;\n                if (minDate && time.minute(59).isBefore(minDate))\n                    disabled = true;\n                if (maxDate && time.minute(0).isAfter(maxDate))\n                    disabled = true;\n\n                if (i_in_24 == selected.hour() && !disabled) {\n                    html += '<option value=\"' + i + '\" selected=\"selected\">' + i + '</option>';\n                } else if (disabled) {\n                    html += '<option value=\"' + i + '\" disabled=\"disabled\" class=\"disabled\">' + i + '</option>';\n                } else {\n                    html += '<option value=\"' + i + '\">' + i + '</option>';\n                }\n            }\n\n            html += '</select> ';\n\n            //\n            // minutes\n            //\n\n            html += ': <select class=\"minuteselect\">';\n\n            for (var i = 0; i < 60; i += this.timePickerIncrement) {\n                var padded = i < 10 ? '0' + i : i;\n                var time = selected.clone().minute(i);\n\n                var disabled = false;\n                if (minDate && time.second(59).isBefore(minDate))\n                    disabled = true;\n                if (maxDate && time.second(0).isAfter(maxDate))\n                    disabled = true;\n\n                if (selected.minute() == i && !disabled) {\n                    html += '<option value=\"' + i + '\" selected=\"selected\">' + padded + '</option>';\n                } else if (disabled) {\n                    html += '<option value=\"' + i + '\" disabled=\"disabled\" class=\"disabled\">' + padded + '</option>';\n                } else {\n                    html += '<option value=\"' + i + '\">' + padded + '</option>';\n                }\n            }\n\n            html += '</select> ';\n\n            //\n            // seconds\n            //\n\n            if (this.timePickerSeconds) {\n                html += ': <select class=\"secondselect\">';\n\n                for (var i = 0; i < 60; i++) {\n                    var padded = i < 10 ? '0' + i : i;\n                    var time = selected.clone().second(i);\n\n                    var disabled = false;\n                    if (minDate && time.isBefore(minDate))\n                        disabled = true;\n                    if (maxDate && time.isAfter(maxDate))\n                        disabled = true;\n\n                    if (selected.second() == i && !disabled) {\n                        html += '<option value=\"' + i + '\" selected=\"selected\">' + padded + '</option>';\n                    } else if (disabled) {\n                        html += '<option value=\"' + i + '\" disabled=\"disabled\" class=\"disabled\">' + padded + '</option>';\n                    } else {\n                        html += '<option value=\"' + i + '\">' + padded + '</option>';\n                    }\n                }\n\n                html += '</select> ';\n            }\n\n            //\n            // AM/PM\n            //\n\n            if (!this.timePicker24Hour) {\n                html += '<select class=\"ampmselect\">';\n\n                var am_html = '';\n                var pm_html = '';\n\n                if (minDate && selected.clone().hour(12).minute(0).second(0).isBefore(minDate))\n                    am_html = ' disabled=\"disabled\" class=\"disabled\"';\n\n                if (maxDate && selected.clone().hour(0).minute(0).second(0).isAfter(maxDate))\n                    pm_html = ' disabled=\"disabled\" class=\"disabled\"';\n\n                if (selected.hour() >= 12) {\n                    html += '<option value=\"AM\"' + am_html + '>AM</option><option value=\"PM\" selected=\"selected\"' + pm_html + '>PM</option>';\n                } else {\n                    html += '<option value=\"AM\" selected=\"selected\"' + am_html + '>AM</option><option value=\"PM\"' + pm_html + '>PM</option>';\n                }\n\n                html += '</select>';\n            }\n\n            this.container.find('.calendar.' + side + ' .calendar-time div').html(html);\n\n        },\n\n        updateFormInputs: function() {\n\n            //ignore mouse movements while an above-calendar text input has focus\n            if (this.container.find('input[name=daterangepicker_start]').is(\":focus\") || this.container.find('input[name=daterangepicker_end]').is(\":focus\"))\n                return;\n\n            this.container.find('input[name=daterangepicker_start]').val(this.startDate.format(this.locale.format));\n            if (this.endDate)\n                this.container.find('input[name=daterangepicker_end]').val(this.endDate.format(this.locale.format));\n\n            if (this.singleDatePicker || (this.endDate && (this.startDate.isBefore(this.endDate) || this.startDate.isSame(this.endDate)))) {\n                this.container.find('button.applyBtn').removeAttr('disabled');\n            } else {\n                this.container.find('button.applyBtn').attr('disabled', 'disabled');\n            }\n\n        },\n\n        move: function() {\n            var parentOffset = { top: 0, left: 0 },\n                containerTop;\n            var parentRightEdge = $(window).width();\n            if (!this.parentEl.is('body')) {\n                parentOffset = {\n                    top: this.parentEl.offset().top - this.parentEl.scrollTop(),\n                    left: this.parentEl.offset().left - this.parentEl.scrollLeft()\n                };\n                parentRightEdge = this.parentEl[0].clientWidth + this.parentEl.offset().left;\n            }\n\n            if (this.drops == 'up')\n                containerTop = this.element.offset().top - this.container.outerHeight() - parentOffset.top;\n            else\n                containerTop = this.element.offset().top + this.element.outerHeight() - parentOffset.top;\n            this.container[this.drops == 'up' ? 'addClass' : 'removeClass']('dropup');\n\n            if (this.opens == 'left') {\n                this.container.css({\n                    top: containerTop,\n                    right: parentRightEdge - this.element.offset().left - this.element.outerWidth(),\n                    left: 'auto'\n                });\n                if (this.container.offset().left < 0) {\n                    this.container.css({\n                        right: 'auto',\n                        left: 9\n                    });\n                }\n            } else if (this.opens == 'center') {\n                this.container.css({\n                    top: containerTop,\n                    left: this.element.offset().left - parentOffset.left + this.element.outerWidth() / 2\n                            - this.container.outerWidth() / 2,\n                    right: 'auto'\n                });\n                if (this.container.offset().left < 0) {\n                    this.container.css({\n                        right: 'auto',\n                        left: 9\n                    });\n                }\n            } else {\n                this.container.css({\n                    top: containerTop,\n                    left: this.element.offset().left - parentOffset.left,\n                    right: 'auto'\n                });\n                if (this.container.offset().left + this.container.outerWidth() > $(window).width()) {\n                    this.container.css({\n                        left: 'auto',\n                        right: 0\n                    });\n                }\n            }\n        },\n\n        show: function(e) {\n            if (this.isShowing) return;\n\n            // Create a click proxy that is private to this instance of datepicker, for unbinding\n            this._outsideClickProxy = $.proxy(function(e) { this.outsideClick(e); }, this);\n\n            // Bind global datepicker mousedown for hiding and\n            $(document)\n              .on('mousedown.daterangepicker', this._outsideClickProxy)\n              // also support mobile devices\n              .on('touchend.daterangepicker', this._outsideClickProxy)\n              // also explicitly play nice with Bootstrap dropdowns, which stopPropagation when clicking them\n              .on('click.daterangepicker', '[data-toggle=dropdown]', this._outsideClickProxy)\n              // and also close when focus changes to outside the picker (eg. tabbing between controls)\n              .on('focusin.daterangepicker', this._outsideClickProxy);\n\n            // Reposition the picker if the window is resized while it's open\n            $(window).on('resize.daterangepicker', $.proxy(function(e) { this.move(e); }, this));\n\n            this.oldStartDate = this.startDate.clone();\n            this.oldEndDate = this.endDate.clone();\n            this.previousRightTime = this.endDate.clone();\n\n            this.updateView();\n            this.container.show();\n            this.move();\n            this.element.trigger('show.daterangepicker', this);\n            this.isShowing = true;\n        },\n\n        hide: function(e) {\n            if (!this.isShowing) return;\n\n            //incomplete date selection, revert to last values\n            if (!this.endDate) {\n                this.startDate = this.oldStartDate.clone();\n                this.endDate = this.oldEndDate.clone();\n            }\n\n            //if a new date range was selected, invoke the user callback function\n            if (!this.startDate.isSame(this.oldStartDate) || !this.endDate.isSame(this.oldEndDate))\n                this.callback(this.startDate, this.endDate, this.chosenLabel);\n\n            //if picker is attached to a text input, update it\n            this.updateElement();\n\n            $(document).off('.daterangepicker');\n            $(window).off('.daterangepicker');\n            this.container.hide();\n            this.element.trigger('hide.daterangepicker', this);\n            this.isShowing = false;\n        },\n\n        toggle: function(e) {\n            if (this.isShowing) {\n                this.hide();\n            } else {\n                this.show();\n            }\n        },\n\n        outsideClick: function(e) {\n            var target = $(e.target);\n            // if the page is clicked anywhere except within the daterangerpicker/button\n            // itself then call this.hide()\n            if (\n                // ie modal dialog fix\n                e.type == \"focusin\" ||\n                target.closest(this.element).length ||\n                target.closest(this.container).length ||\n                target.closest('.calendar-table').length\n                ) return;\n            this.hide();\n        },\n\n        showCalendars: function() {\n            this.container.addClass('show-calendar');\n            this.move();\n            this.element.trigger('showCalendar.daterangepicker', this);\n        },\n\n        hideCalendars: function() {\n            this.container.removeClass('show-calendar');\n            this.element.trigger('hideCalendar.daterangepicker', this);\n        },\n\n        hoverRange: function(e) {\n\n            //ignore mouse movements while an above-calendar text input has focus\n            if (this.container.find('input[name=daterangepicker_start]').is(\":focus\") || this.container.find('input[name=daterangepicker_end]').is(\":focus\"))\n                return;\n\n            var label = e.target.innerHTML;\n            if (label == this.locale.customRangeLabel) {\n                this.updateView();\n            } else {\n                var dates = this.ranges[label];\n                this.container.find('input[name=daterangepicker_start]').val(dates[0].format(this.locale.format));\n                this.container.find('input[name=daterangepicker_end]').val(dates[1].format(this.locale.format));\n            }\n            \n        },\n\n        clickRange: function(e) {\n            var label = e.target.innerHTML;\n            this.chosenLabel = label;\n            if (label == this.locale.customRangeLabel) {\n                this.showCalendars();\n            } else {\n                var dates = this.ranges[label];\n                this.startDate = dates[0];\n                this.endDate = dates[1];\n\n                if (!this.timePicker) {\n                    this.startDate.startOf('day');\n                    this.endDate.endOf('day');\n                }\n\n                if (!this.alwaysShowCalendars)\n                    this.hideCalendars();\n                this.clickApply();\n            }\n        },\n\n        clickPrev: function(e) {\n            var cal = $(e.target).parents('.calendar');\n            if (cal.hasClass('left')) {\n                this.leftCalendar.month.subtract(1, 'month');\n                if (this.linkedCalendars)\n                    this.rightCalendar.month.subtract(1, 'month');\n            } else {\n                this.rightCalendar.month.subtract(1, 'month');\n            }\n            this.updateCalendars();\n        },\n\n        clickNext: function(e) {\n            var cal = $(e.target).parents('.calendar');\n            if (cal.hasClass('left')) {\n                this.leftCalendar.month.add(1, 'month');\n            } else {\n                this.rightCalendar.month.add(1, 'month');\n                if (this.linkedCalendars)\n                    this.leftCalendar.month.add(1, 'month');\n            }\n            this.updateCalendars();\n        },\n\n        hoverDate: function(e) {\n\n            //ignore mouse movements while an above-calendar text input has focus\n            if (this.container.find('input[name=daterangepicker_start]').is(\":focus\") || this.container.find('input[name=daterangepicker_end]').is(\":focus\"))\n                return;\n\n            //ignore dates that can't be selected\n            if (!$(e.target).hasClass('available')) return;\n\n            //have the text inputs above calendars reflect the date being hovered over\n            var title = $(e.target).attr('data-title');\n            var row = title.substr(1, 1);\n            var col = title.substr(3, 1);\n            var cal = $(e.target).parents('.calendar');\n            var date = cal.hasClass('left') ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];\n\n            if (this.endDate) {\n                this.container.find('input[name=daterangepicker_start]').val(date.format(this.locale.format));\n            } else {\n                this.container.find('input[name=daterangepicker_end]').val(date.format(this.locale.format));\n            }\n\n            //highlight the dates between the start date and the date being hovered as a potential end date\n            var leftCalendar = this.leftCalendar;\n            var rightCalendar = this.rightCalendar;\n            var startDate = this.startDate;\n            if (!this.endDate) {\n                this.container.find('.calendar td').each(function(index, el) {\n\n                    //skip week numbers, only look at dates\n                    if ($(el).hasClass('week')) return;\n\n                    var title = $(el).attr('data-title');\n                    var row = title.substr(1, 1);\n                    var col = title.substr(3, 1);\n                    var cal = $(el).parents('.calendar');\n                    var dt = cal.hasClass('left') ? leftCalendar.calendar[row][col] : rightCalendar.calendar[row][col];\n\n                    if (dt.isAfter(startDate) && dt.isBefore(date)) {\n                        $(el).addClass('in-range');\n                    } else {\n                        $(el).removeClass('in-range');\n                    }\n\n                });\n            }\n\n        },\n\n        clickDate: function(e) {\n\n            if (!$(e.target).hasClass('available')) return;\n\n            var title = $(e.target).attr('data-title');\n            var row = title.substr(1, 1);\n            var col = title.substr(3, 1);\n            var cal = $(e.target).parents('.calendar');\n            var date = cal.hasClass('left') ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];\n\n            //\n            // this function needs to do a few things:\n            // * alternate between selecting a start and end date for the range,\n            // * if the time picker is enabled, apply the hour/minute/second from the select boxes to the clicked date\n            // * if autoapply is enabled, and an end date was chosen, apply the selection\n            // * if single date picker mode, and time picker isn't enabled, apply the selection immediately\n            //\n\n            if (this.endDate || date.isBefore(this.startDate, 'day')) {\n                if (this.timePicker) {\n                    var hour = parseInt(this.container.find('.left .hourselect').val(), 10);\n                    if (!this.timePicker24Hour) {\n                        var ampm = this.container.find('.left .ampmselect').val();\n                        if (ampm === 'PM' && hour < 12)\n                            hour += 12;\n                        if (ampm === 'AM' && hour === 12)\n                            hour = 0;\n                    }\n                    var minute = parseInt(this.container.find('.left .minuteselect').val(), 10);\n                    var second = this.timePickerSeconds ? parseInt(this.container.find('.left .secondselect').val(), 10) : 0;\n                    date = date.clone().hour(hour).minute(minute).second(second);\n                }\n                this.endDate = null;\n                this.setStartDate(date.clone());\n            } else if (!this.endDate && date.isBefore(this.startDate)) {\n                //special case: clicking the same date for start/end, \n                //but the time of the end date is before the start date\n                this.setEndDate(this.startDate.clone());\n            } else {\n                if (this.timePicker) {\n                    var hour = parseInt(this.container.find('.right .hourselect').val(), 10);\n                    if (!this.timePicker24Hour) {\n                        var ampm = this.container.find('.right .ampmselect').val();\n                        if (ampm === 'PM' && hour < 12)\n                            hour += 12;\n                        if (ampm === 'AM' && hour === 12)\n                            hour = 0;\n                    }\n                    var minute = parseInt(this.container.find('.right .minuteselect').val(), 10);\n                    var second = this.timePickerSeconds ? parseInt(this.container.find('.right .secondselect').val(), 10) : 0;\n                    date = date.clone().hour(hour).minute(minute).second(second);\n                }\n                this.setEndDate(date.clone());\n                if (this.autoApply) {\n                  this.calculateChosenLabel();\n                  this.clickApply();\n                }\n            }\n\n            if (this.singleDatePicker) {\n                this.setEndDate(this.startDate);\n                if (!this.timePicker)\n                    this.clickApply();\n            }\n\n            this.updateView();\n\n        },\n\n        calculateChosenLabel: function() {\n          var customRange = true;\n          var i = 0;\n          for (var range in this.ranges) {\n              if (this.timePicker) {\n                  if (this.startDate.isSame(this.ranges[range][0]) && this.endDate.isSame(this.ranges[range][1])) {\n                      customRange = false;\n                      this.chosenLabel = this.container.find('.ranges li:eq(' + i + ')').addClass('active').html();\n                      break;\n                  }\n              } else {\n                  //ignore times when comparing dates if time picker is not enabled\n                  if (this.startDate.format('YYYY-MM-DD') == this.ranges[range][0].format('YYYY-MM-DD') && this.endDate.format('YYYY-MM-DD') == this.ranges[range][1].format('YYYY-MM-DD')) {\n                      customRange = false;\n                      this.chosenLabel = this.container.find('.ranges li:eq(' + i + ')').addClass('active').html();\n                      break;\n                  }\n              }\n              i++;\n          }\n          if (customRange) {\n              this.chosenLabel = this.container.find('.ranges li:last').addClass('active').html();\n              this.showCalendars();\n          }\n        },\n\n        clickApply: function(e) {\n            this.hide();\n            this.element.trigger('apply.daterangepicker', this);\n        },\n\n        clickCancel: function(e) {\n            this.startDate = this.oldStartDate;\n            this.endDate = this.oldEndDate;\n            this.hide();\n            this.element.trigger('cancel.daterangepicker', this);\n        },\n\n        monthOrYearChanged: function(e) {\n            var isLeft = $(e.target).closest('.calendar').hasClass('left'),\n                leftOrRight = isLeft ? 'left' : 'right',\n                cal = this.container.find('.calendar.'+leftOrRight);\n\n            // Month must be Number for new moment versions\n            var month = parseInt(cal.find('.monthselect').val(), 10);\n            var year = cal.find('.yearselect').val();\n\n            if (!isLeft) {\n                if (year < this.startDate.year() || (year == this.startDate.year() && month < this.startDate.month())) {\n                    month = this.startDate.month();\n                    year = this.startDate.year();\n                }\n            }\n\n            if (this.minDate) {\n                if (year < this.minDate.year() || (year == this.minDate.year() && month < this.minDate.month())) {\n                    month = this.minDate.month();\n                    year = this.minDate.year();\n                }\n            }\n\n            if (this.maxDate) {\n                if (year > this.maxDate.year() || (year == this.maxDate.year() && month > this.maxDate.month())) {\n                    month = this.maxDate.month();\n                    year = this.maxDate.year();\n                }\n            }\n\n            if (isLeft) {\n                this.leftCalendar.month.month(month).year(year);\n                if (this.linkedCalendars)\n                    this.rightCalendar.month = this.leftCalendar.month.clone().add(1, 'month');\n            } else {\n                this.rightCalendar.month.month(month).year(year);\n                if (this.linkedCalendars)\n                    this.leftCalendar.month = this.rightCalendar.month.clone().subtract(1, 'month');\n            }\n            this.updateCalendars();\n        },\n\n        timeChanged: function(e) {\n\n            var cal = $(e.target).closest('.calendar'),\n                isLeft = cal.hasClass('left');\n\n            var hour = parseInt(cal.find('.hourselect').val(), 10);\n            var minute = parseInt(cal.find('.minuteselect').val(), 10);\n            var second = this.timePickerSeconds ? parseInt(cal.find('.secondselect').val(), 10) : 0;\n\n            if (!this.timePicker24Hour) {\n                var ampm = cal.find('.ampmselect').val();\n                if (ampm === 'PM' && hour < 12)\n                    hour += 12;\n                if (ampm === 'AM' && hour === 12)\n                    hour = 0;\n            }\n\n            if (isLeft) {\n                var start = this.startDate.clone();\n                start.hour(hour);\n                start.minute(minute);\n                start.second(second);\n                this.setStartDate(start);\n                if (this.singleDatePicker) {\n                    this.endDate = this.startDate.clone();\n                } else if (this.endDate && this.endDate.format('YYYY-MM-DD') == start.format('YYYY-MM-DD') && this.endDate.isBefore(start)) {\n                    this.setEndDate(start.clone());\n                }\n            } else if (this.endDate) {\n                var end = this.endDate.clone();\n                end.hour(hour);\n                end.minute(minute);\n                end.second(second);\n                this.setEndDate(end);\n            }\n\n            //update the calendars so all clickable dates reflect the new time component\n            this.updateCalendars();\n\n            //update the form inputs above the calendars with the new time\n            this.updateFormInputs();\n\n            //re-render the time pickers because changing one selection can affect what's enabled in another\n            this.renderTimePicker('left');\n            this.renderTimePicker('right');\n\n        },\n\n        formInputsChanged: function(e) {\n            var isRight = $(e.target).closest('.calendar').hasClass('right');\n            var start = moment(this.container.find('input[name=\"daterangepicker_start\"]').val(), this.locale.format);\n            var end = moment(this.container.find('input[name=\"daterangepicker_end\"]').val(), this.locale.format);\n\n            if (start.isValid() && end.isValid()) {\n\n                if (isRight && end.isBefore(start))\n                    start = end.clone();\n\n                this.setStartDate(start);\n                this.setEndDate(end);\n\n                if (isRight) {\n                    this.container.find('input[name=\"daterangepicker_start\"]').val(this.startDate.format(this.locale.format));\n                } else {\n                    this.container.find('input[name=\"daterangepicker_end\"]').val(this.endDate.format(this.locale.format));\n                }\n\n            }\n\n            this.updateCalendars();\n            if (this.timePicker) {\n                this.renderTimePicker('left');\n                this.renderTimePicker('right');\n            }\n        },\n\n        elementChanged: function() {\n            if (!this.element.is('input')) return;\n            if (!this.element.val().length) return;\n            if (this.element.val().length < this.locale.format.length) return;\n\n            var dateString = this.element.val().split(this.locale.separator),\n                start = null,\n                end = null;\n\n            if (dateString.length === 2) {\n                start = moment(dateString[0], this.locale.format);\n                end = moment(dateString[1], this.locale.format);\n            }\n\n            if (this.singleDatePicker || start === null || end === null) {\n                start = moment(this.element.val(), this.locale.format);\n                end = start;\n            }\n\n            if (!start.isValid() || !end.isValid()) return;\n\n            this.setStartDate(start);\n            this.setEndDate(end);\n            this.updateView();\n        },\n\n        keydown: function(e) {\n            //hide on tab or enter\n            if ((e.keyCode === 9) || (e.keyCode === 13)) {\n                this.hide();\n            }\n        },\n\n        updateElement: function() {\n            if (this.element.is('input') && !this.singleDatePicker && this.autoUpdateInput) {\n                this.element.val(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));\n                this.element.trigger('change');\n            } else if (this.element.is('input') && this.autoUpdateInput) {\n                this.element.val(this.startDate.format(this.locale.format));\n                this.element.trigger('change');\n            }\n        },\n\n        remove: function() {\n            this.container.remove();\n            this.element.off('.daterangepicker');\n            this.element.removeData();\n        }\n\n    };\n\n    $.fn.daterangepicker = function(options, callback) {\n        this.each(function() {\n            var el = $(this);\n            if (el.data('daterangepicker'))\n                el.data('daterangepicker').remove();\n            el.data('daterangepicker', new DateRangePicker(el, options, callback));\n        });\n        return this;\n    };\n    \n    return DateRangePicker;\n\n}));\n","// ==ClosureCompiler==\n// @compilation_level SIMPLE_OPTIMIZATIONS\n\n/**\n * @license Highcharts JS v4.2.3 (2016-02-08)\n *\n * (c) 2009-2016 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n(function (root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = root.document ?\n            factory(root) : \n            factory;\n    } else {\n        root.Highcharts = factory(root);\n    }\n}(typeof window !== 'undefined' ? window : this, function (win) { // eslint-disable-line no-undef\n// encapsulated variables\n    var UNDEFINED,\n        doc = win.document,\n        math = Math,\n        mathRound = math.round,\n        mathFloor = math.floor,\n        mathCeil = math.ceil,\n        mathMax = math.max,\n        mathMin = math.min,\n        mathAbs = math.abs,\n        mathCos = math.cos,\n        mathSin = math.sin,\n        mathPI = math.PI,\n        deg2rad = mathPI * 2 / 360,\n\n\n        // some variables\n        userAgent = (win.navigator && win.navigator.userAgent) || '',\n        isOpera = win.opera,\n        isMS = /(msie|trident|edge)/i.test(userAgent) && !isOpera,\n        docMode8 = doc && doc.documentMode === 8,\n        isWebKit = !isMS && /AppleWebKit/.test(userAgent),\n        isFirefox = /Firefox/.test(userAgent),\n        isTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent),\n        SVG_NS = 'http://www.w3.org/2000/svg',\n        hasSVG = doc && doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,\n        hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38\n        useCanVG = doc && !hasSVG && !isMS && !!doc.createElement('canvas').getContext,\n        Renderer,\n        hasTouch,\n        symbolSizes = {},\n        idCounter = 0,\n        garbageBin,\n        defaultOptions,\n        dateFormat, // function\n        pathAnim,\n        timeUnits,\n        noop = function () {},\n        charts = [],\n        chartCount = 0,\n        PRODUCT = 'Highcharts',\n        VERSION = '4.2.3',\n\n        // some constants for frequently used strings\n        DIV = 'div',\n        ABSOLUTE = 'absolute',\n        RELATIVE = 'relative',\n        HIDDEN = 'hidden',\n        PREFIX = 'highcharts-',\n        VISIBLE = 'visible',\n        PX = 'px',\n        NONE = 'none',\n        M = 'M',\n        L = 'L',\n        numRegex = /^[0-9]+$/,\n        NORMAL_STATE = '',\n        HOVER_STATE = 'hover',\n        SELECT_STATE = 'select',\n        marginNames = ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],\n\n        // Object for extending Axis\n        AxisPlotLineOrBandExtension,\n\n        // constants for attributes\n        STROKE_WIDTH = 'stroke-width',\n\n        // time methods, changed based on whether or not UTC is used\n        Date,  // Allow using a different Date class\n        makeTime,\n        timezoneOffset,\n        getTimezoneOffset,\n        getMinutes,\n        getHours,\n        getDay,\n        getDate,\n        getMonth,\n        getFullYear,\n        setMilliseconds,\n        setSeconds,\n        setMinutes,\n        setHours,\n        setDate,\n        setMonth,\n        setFullYear,\n\n\n        // lookup over the types and the associated classes\n        seriesTypes = {},\n        Highcharts;\n\n    /**\n     * Provide error messages for debugging, with links to online explanation\n     */\n    function error(code, stop) {\n        var msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;\n        if (stop) {\n            throw new Error(msg);\n        }\n        // else ...\n        if (win.console) {\n            console.log(msg); // eslint-disable-line no-console\n        }\n    }\n\n    // The Highcharts namespace\n    Highcharts = win.Highcharts ? error(16, true) : { win: win };\n\n    Highcharts.seriesTypes = seriesTypes;\n    var timers = [],\n        getStyle,\n\n        // Previous adapter functions\n        inArray,\n        each,\n        grep,\n        offset,\n        map,\n        addEvent,\n        removeEvent,\n        fireEvent,\n        animate,\n        stop;\n\n    /**\n     * An animator object. One instance applies to one property (attribute or style prop) \n     * on one element.\n     * \n     * @param {object} elem    The element to animate. May be a DOM element or a Highcharts SVGElement wrapper.\n     * @param {object} options Animation options, including duration, easing, step and complete.\n     * @param {object} prop    The property to animate.\n     */\n    function Fx(elem, options, prop) {\n        this.options = options;\n        this.elem = elem;\n        this.prop = prop;\n    }\n    Fx.prototype = {\n    \n        /**\n         * Animating a path definition on SVGElement\n         * @returns {undefined} \n         */\n        dSetter: function () {\n            var start = this.paths[0],\n                end = this.paths[1],\n                ret = [],\n                now = this.now,\n                i = start.length,\n                startVal;\n\n            if (now === 1) { // land on the final path without adjustment points appended in the ends\n                ret = this.toD;\n\n            } else if (i === end.length && now < 1) {\n                while (i--) {\n                    startVal = parseFloat(start[i]);\n                    ret[i] =\n                        isNaN(startVal) ? // a letter instruction like M or L\n                                start[i] :\n                                now * (parseFloat(end[i] - startVal)) + startVal;\n\n                }\n            } else { // if animation is finished or length not matching, land on right value\n                ret = end;\n            }\n            this.elem.attr('d', ret);\n        },\n\n        /**\n         * Update the element with the current animation step\n         * @returns {undefined}\n         */\n        update: function () {\n            var elem = this.elem,\n                prop = this.prop, // if destroyed, it is null\n                now = this.now,\n                step = this.options.step;\n\n            // Animation setter defined from outside\n            if (this[prop + 'Setter']) {\n                this[prop + 'Setter']();\n\n            // Other animations on SVGElement\n            } else if (elem.attr) {\n                if (elem.element) {\n                    elem.attr(prop, now);\n                }\n\n            // HTML styles, raw HTML content like container size\n            } else {\n                elem.style[prop] = now + this.unit;\n            }\n        \n            if (step) {\n                step.call(elem, now, this);\n            }\n\n        },\n\n        /**\n         * Run an animation\n         */\n        run: function (from, to, unit) {\n            var self = this,\n                timer = function (gotoEnd) {\n                    return timer.stopped ? false : self.step(gotoEnd);\n                },\n                i;\n\n            this.startTime = +new Date();\n            this.start = from;\n            this.end = to;\n            this.unit = unit;\n            this.now = this.start;\n            this.pos = 0;\n\n            timer.elem = this.elem;\n\n            if (timer() && timers.push(timer) === 1) {\n                timer.timerId = setInterval(function () {\n                \n                    for (i = 0; i < timers.length; i++) {\n                        if (!timers[i]()) {\n                            timers.splice(i--, 1);\n                        }\n                    }\n\n                    if (!timers.length) {\n                        clearInterval(timer.timerId);\n                    }\n                }, 13);\n            }\n        },\n    \n        /**\n         * Run a single step in the animation\n         * @param   {Boolean} gotoEnd Whether to go to then endpoint of the animation after abort\n         * @returns {Boolean} True if animation continues\n         */\n        step: function (gotoEnd) {\n            var t = +new Date(),\n                ret,\n                done,\n                options = this.options,\n                elem = this.elem,\n                complete = options.complete,\n                duration = options.duration,\n                curAnim = options.curAnim,\n                i;\n        \n            if (elem.attr && !elem.element) { // #2616, element including flag is destroyed\n                ret = false;\n\n            } else if (gotoEnd || t >= duration + this.startTime) {\n                this.now = this.end;\n                this.pos = 1;\n                this.update();\n\n                curAnim[this.prop] = true;\n\n                done = true;\n                for (i in curAnim) {\n                    if (curAnim[i] !== true) {\n                        done = false;\n                    }\n                }\n\n                if (done && complete) {\n                    complete.call(elem);\n                }\n                ret = false;\n\n            } else {\n                this.pos = options.easing((t - this.startTime) / duration);\n                this.now = this.start + ((this.end - this.start) * this.pos);\n                this.update();\n                ret = true;\n            }\n            return ret;\n        },\n\n        /**\n         * Prepare start and end values so that the path can be animated one to one\n         */\n        initPath: function (elem, fromD, toD) {\n            fromD = fromD || '';\n            var shift = elem.shift,\n                bezier = fromD.indexOf('C') > -1,\n                numParams = bezier ? 7 : 3,\n                endLength,\n                slice,\n                i,\n                start = fromD.split(' '),\n                end = [].concat(toD), // copy\n                isArea = elem.isArea,\n                positionFactor = isArea ? 2 : 1,\n                sixify = function (arr) { // in splines make move points have six parameters like bezier curves\n                    i = arr.length;\n                    while (i--) {\n                        if (arr[i] === M || arr[i] === L) {\n                            arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);\n                        }\n                    }\n                };\n\n            if (bezier) {\n                sixify(start);\n                sixify(end);\n            }\n\n            // If shifting points, prepend a dummy point to the end path. For areas,\n            // prepend both at the beginning and end of the path.\n            if (shift <= end.length / numParams && start.length === end.length) {\n                while (shift--) {\n                    end = end.slice(0, numParams).concat(end);\n                    if (isArea) {\n                        end = end.concat(end.slice(end.length - numParams));\n                    }\n                }\n            }\n            elem.shift = 0; // reset for following animations\n\n        \n            // Copy and append last point until the length matches the end length\n            if (start.length) {\n                endLength = end.length;\n                while (start.length < endLength) {\n\n                    // Pull out the slice that is going to be appended or inserted. In a line graph,\n                    // the positionFactor is 1, and the last point is sliced out. In an area graph,\n                    // the positionFactor is 2, causing the middle two points to be sliced out, since\n                    // an area path starts at left, follows the upper path then turns and follows the\n                    // bottom back. \n                    slice = start.slice().splice(\n                        (start.length / positionFactor) - numParams, \n                        numParams * positionFactor\n                    );\n                \n                    // Disable first control point\n                    if (bezier) {\n                        slice[numParams - 6] = slice[numParams - 2];\n                        slice[numParams - 5] = slice[numParams - 1];\n                    }\n                \n                    // Now insert the slice, either in the middle (for areas) or at the end (for lines)\n                    [].splice.apply(\n                        start, \n                        [(start.length / positionFactor), 0].concat(slice)\n                    );\n\n                }\n            }\n\n            return [start, end];\n        }\n    }; // End of Fx prototype\n\n\n    /**\n     * Extend an object with the members of another\n     * @param {Object} a The object to be extended\n     * @param {Object} b The object to add to the first one\n     */\n    var extend = Highcharts.extend = function (a, b) {\n        var n;\n        if (!a) {\n            a = {};\n        }\n        for (n in b) {\n            a[n] = b[n];\n        }\n        return a;\n    };\n\n    /**\n     * Deep merge two or more objects and return a third object. If the first argument is\n     * true, the contents of the second object is copied into the first object.\n     * Previously this function redirected to jQuery.extend(true), but this had two limitations.\n     * First, it deep merged arrays, which lead to workarounds in Highcharts. Second,\n     * it copied properties from extended prototypes.\n     */\n    function merge() {\n        var i,\n            args = arguments,\n            len,\n            ret = {},\n            doCopy = function (copy, original) {\n                var value, key;\n\n                // An object is replacing a primitive\n                if (typeof copy !== 'object') {\n                    copy = {};\n                }\n\n                for (key in original) {\n                    if (original.hasOwnProperty(key)) {\n                        value = original[key];\n\n                        // Copy the contents of objects, but not arrays or DOM nodes\n                        if (value && typeof value === 'object' && Object.prototype.toString.call(value) !== '[object Array]' &&\n                                key !== 'renderTo' && typeof value.nodeType !== 'number') {\n                            copy[key] = doCopy(copy[key] || {}, value);\n\n                        // Primitives and arrays are copied over directly\n                        } else {\n                            copy[key] = original[key];\n                        }\n                    }\n                }\n                return copy;\n            };\n\n        // If first argument is true, copy into the existing object. Used in setOptions.\n        if (args[0] === true) {\n            ret = args[1];\n            args = Array.prototype.slice.call(args, 2);\n        }\n\n        // For each argument, extend the return\n        len = args.length;\n        for (i = 0; i < len; i++) {\n            ret = doCopy(ret, args[i]);\n        }\n\n        return ret;\n    }\n\n    /**\n     * Shortcut for parseInt\n     * @param {Object} s\n     * @param {Number} mag Magnitude\n     */\n    function pInt(s, mag) {\n        return parseInt(s, mag || 10);\n    }\n\n    /**\n     * Check for string\n     * @param {Object} s\n     */\n    function isString(s) {\n        return typeof s === 'string';\n    }\n\n    /**\n     * Check for object\n     * @param {Object} obj\n     */\n    function isObject(obj) {\n        return obj && typeof obj === 'object';\n    }\n\n    /**\n     * Check for array\n     * @param {Object} obj\n     */\n    function isArray(obj) {\n        return Object.prototype.toString.call(obj) === '[object Array]';\n    }\n\n    /**\n     * Check for number\n     * @param {Object} n\n     */\n    function isNumber(n) {\n        return typeof n === 'number';\n    }\n\n    function log2lin(num) {\n        return math.log(num) / math.LN10;\n    }\n    function lin2log(num) {\n        return math.pow(10, num);\n    }\n\n    /**\n     * Remove last occurence of an item from an array\n     * @param {Array} arr\n     * @param {Mixed} item\n     */\n    function erase(arr, item) {\n        var i = arr.length;\n        while (i--) {\n            if (arr[i] === item) {\n                arr.splice(i, 1);\n                break;\n            }\n        }\n        //return arr;\n    }\n\n    /**\n     * Returns true if the object is not null or undefined.\n     * @param {Object} obj\n     */\n    function defined(obj) {\n        return obj !== UNDEFINED && obj !== null;\n    }\n\n    /**\n     * Set or get an attribute or an object of attributes. Can't use jQuery attr because\n     * it attempts to set expando properties on the SVG element, which is not allowed.\n     *\n     * @param {Object} elem The DOM element to receive the attribute(s)\n     * @param {String|Object} prop The property or an abject of key-value pairs\n     * @param {String} value The value if a single property is set\n     */\n    function attr(elem, prop, value) {\n        var key,\n            ret;\n\n        // if the prop is a string\n        if (isString(prop)) {\n            // set the value\n            if (defined(value)) {\n                elem.setAttribute(prop, value);\n\n            // get the value\n            } else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...\n                ret = elem.getAttribute(prop);\n            }\n\n        // else if prop is defined, it is a hash of key/value pairs\n        } else if (defined(prop) && isObject(prop)) {\n            for (key in prop) {\n                elem.setAttribute(key, prop[key]);\n            }\n        }\n        return ret;\n    }\n    /**\n     * Check if an element is an array, and if not, make it into an array.\n     */\n    function splat(obj) {\n        return isArray(obj) ? obj : [obj];\n    }\n\n    /**\n     * Set a timeout if the delay is given, otherwise perform the function synchronously\n     * @param   {Function} fn      The function to perform\n     * @param   {Number}   delay   Delay in milliseconds\n     * @param   {Ojbect}   context The context\n     * @returns {Nubmer}           An identifier for the timeout\n     */\n    function syncTimeout(fn, delay, context) {\n        if (delay) {\n            return setTimeout(fn, delay, context);\n        }\n        fn.call(0, context);\n    }\n\n\n    /**\n     * Return the first value that is defined.\n     */\n    var pick = Highcharts.pick = function () {\n        var args = arguments,\n            i,\n            arg,\n            length = args.length;\n        for (i = 0; i < length; i++) {\n            arg = args[i];\n            if (arg !== UNDEFINED && arg !== null) {\n                return arg;\n            }\n        }\n    };\n\n    /**\n     * Set CSS on a given element\n     * @param {Object} el\n     * @param {Object} styles Style object with camel case property names\n     */\n    function css(el, styles) {\n        if (isMS && !hasSVG) { // #2686\n            if (styles && styles.opacity !== UNDEFINED) {\n                styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';\n            }\n        }\n        extend(el.style, styles);\n    }\n\n    /**\n     * Utility function to create element with attributes and styles\n     * @param {Object} tag\n     * @param {Object} attribs\n     * @param {Object} styles\n     * @param {Object} parent\n     * @param {Object} nopad\n     */\n    function createElement(tag, attribs, styles, parent, nopad) {\n        var el = doc.createElement(tag);\n        if (attribs) {\n            extend(el, attribs);\n        }\n        if (nopad) {\n            css(el, { padding: 0, border: 'none', margin: 0 });\n        }\n        if (styles) {\n            css(el, styles);\n        }\n        if (parent) {\n            parent.appendChild(el);\n        }\n        return el;\n    }\n\n    /**\n     * Extend a prototyped class by new members\n     * @param {Object} parent\n     * @param {Object} members\n     */\n    function extendClass(Parent, members) {\n        var object = function () {\n        };\n        object.prototype = new Parent();\n        extend(object.prototype, members);\n        return object;\n    }\n\n    /**\n     * Pad a string to a given length by adding 0 to the beginning\n     * @param {Number} number\n     * @param {Number} length\n     */\n    function pad(number, length) {\n        return new Array((length || 2) + 1 - String(number).length).join(0) + number;\n    }\n\n    /**\n     * Return a length based on either the integer value, or a percentage of a base.\n     */\n    function relativeLength(value, base) {\n        return (/%$/).test(value) ? base * parseFloat(value) / 100 : parseFloat(value);\n    }\n\n    /**\n     * Wrap a method with extended functionality, preserving the original function\n     * @param {Object} obj The context object that the method belongs to\n     * @param {String} method The name of the method to extend\n     * @param {Function} func A wrapper function callback. This function is called with the same arguments\n     * as the original function, except that the original function is unshifted and passed as the first\n     * argument.\n     */\n    var wrap = Highcharts.wrap = function (obj, method, func) {\n        var proceed = obj[method];\n        obj[method] = function () {\n            var args = Array.prototype.slice.call(arguments);\n            args.unshift(proceed);\n            return func.apply(this, args);\n        };\n    };\n\n\n    function getTZOffset(timestamp) {\n        return ((getTimezoneOffset && getTimezoneOffset(timestamp)) || timezoneOffset || 0) * 60000;\n    }\n\n    /**\n     * Based on http://www.php.net/manual/en/function.strftime.php\n     * @param {String} format\n     * @param {Number} timestamp\n     * @param {Boolean} capitalize\n     */\n    dateFormat = function (format, timestamp, capitalize) {\n        if (!defined(timestamp) || isNaN(timestamp)) {\n            return defaultOptions.lang.invalidDate || '';\n        }\n        format = pick(format, '%Y-%m-%d %H:%M:%S');\n\n        var date = new Date(timestamp - getTZOffset(timestamp)),\n            key, // used in for constuct below\n            // get the basic time values\n            hours = date[getHours](),\n            day = date[getDay](),\n            dayOfMonth = date[getDate](),\n            month = date[getMonth](),\n            fullYear = date[getFullYear](),\n            lang = defaultOptions.lang,\n            langWeekdays = lang.weekdays,\n\n            // List all format keys. Custom formats can be added from the outside.\n            replacements = extend({\n\n                // Day\n                'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'\n                'A': langWeekdays[day], // Long weekday, like 'Monday'\n                'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31\n                'e': dayOfMonth, // Day of the month, 1 through 31\n                'w': day,\n\n                // Week (none implemented)\n                //'W': weekNumber(),\n\n                // Month\n                'b': lang.shortMonths[month], // Short month, like 'Jan'\n                'B': lang.months[month], // Long month, like 'January'\n                'm': pad(month + 1), // Two digit month number, 01 through 12\n\n                // Year\n                'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009\n                'Y': fullYear, // Four digits year, like 2009\n\n                // Time\n                'H': pad(hours), // Two digits hours in 24h format, 00 through 23\n                'k': hours, // Hours in 24h format, 0 through 23\n                'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11\n                'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12\n                'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59\n                'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM\n                'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM\n                'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59\n                'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)\n            }, Highcharts.dateFormats);\n\n\n        // do the replaces\n        for (key in replacements) {\n            while (format.indexOf('%' + key) !== -1) { // regex would do it in one line, but this is faster\n                format = format.replace('%' + key, typeof replacements[key] === 'function' ? replacements[key](timestamp) : replacements[key]);\n            }\n        }\n\n        // Optionally capitalize the string and return\n        return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;\n    };\n\n    /**\n     * Format a single variable. Similar to sprintf, without the % prefix.\n     */\n    function formatSingle(format, val) {\n        var floatRegex = /f$/,\n            decRegex = /\\.([0-9])/,\n            lang = defaultOptions.lang,\n            decimals;\n\n        if (floatRegex.test(format)) { // float\n            decimals = format.match(decRegex);\n            decimals = decimals ? decimals[1] : -1;\n            if (val !== null) {\n                val = Highcharts.numberFormat(\n                    val,\n                    decimals,\n                    lang.decimalPoint,\n                    format.indexOf(',') > -1 ? lang.thousandsSep : ''\n                );\n            }\n        } else {\n            val = dateFormat(format, val);\n        }\n        return val;\n    }\n\n    /**\n     * Format a string according to a subset of the rules of Python's String.format method.\n     */\n    function format(str, ctx) {\n        var splitter = '{',\n            isInside = false,\n            segment,\n            valueAndFormat,\n            path,\n            i,\n            len,\n            ret = [],\n            val,\n            index;\n\n        while ((index = str.indexOf(splitter)) !== -1) {\n\n            segment = str.slice(0, index);\n            if (isInside) { // we're on the closing bracket looking back\n\n                valueAndFormat = segment.split(':');\n                path = valueAndFormat.shift().split('.'); // get first and leave format\n                len = path.length;\n                val = ctx;\n\n                // Assign deeper paths\n                for (i = 0; i < len; i++) {\n                    val = val[path[i]];\n                }\n\n                // Format the replacement\n                if (valueAndFormat.length) {\n                    val = formatSingle(valueAndFormat.join(':'), val);\n                }\n\n                // Push the result and advance the cursor\n                ret.push(val);\n\n            } else {\n                ret.push(segment);\n\n            }\n            str = str.slice(index + 1); // the rest\n            isInside = !isInside; // toggle\n            splitter = isInside ? '}' : '{'; // now look for next matching bracket\n        }\n        ret.push(str);\n        return ret.join('');\n    }\n\n    /**\n     * Get the magnitude of a number\n     */\n    function getMagnitude(num) {\n        return math.pow(10, mathFloor(math.log(num) / math.LN10));\n    }\n\n    /**\n     * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5\n     * @param {Number} interval\n     * @param {Array} multiples\n     * @param {Number} magnitude\n     * @param {Object} options\n     */\n    function normalizeTickInterval(interval, multiples, magnitude, allowDecimals, preventExceed) {\n        var normalized,\n            i,\n            retInterval = interval;\n\n        // round to a tenfold of 1, 2, 2.5 or 5\n        magnitude = pick(magnitude, 1);\n        normalized = interval / magnitude;\n\n        // multiples for a linear scale\n        if (!multiples) {\n            multiples = [1, 2, 2.5, 5, 10];\n\n            // the allowDecimals option\n            if (allowDecimals === false) {\n                if (magnitude === 1) {\n                    multiples = [1, 2, 5, 10];\n                } else if (magnitude <= 0.1) {\n                    multiples = [1 / magnitude];\n                }\n            }\n        }\n\n        // normalize the interval to the nearest multiple\n        for (i = 0; i < multiples.length; i++) {\n            retInterval = multiples[i];\n            if ((preventExceed && retInterval * magnitude >= interval) || // only allow tick amounts smaller than natural\n                    (!preventExceed && (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2))) {\n                break;\n            }\n        }\n\n        // multiply back to the correct magnitude\n        retInterval *= magnitude;\n\n        return retInterval;\n    }\n\n\n    /**\n     * Utility method that sorts an object array and keeping the order of equal items.\n     * ECMA script standard does not specify the behaviour when items are equal.\n     */\n    function stableSort(arr, sortFunction) {\n        var length = arr.length,\n            sortValue,\n            i;\n\n        // Add index to each item\n        for (i = 0; i < length; i++) {\n            arr[i].safeI = i; // stable sort index\n        }\n\n        arr.sort(function (a, b) {\n            sortValue = sortFunction(a, b);\n            return sortValue === 0 ? a.safeI - b.safeI : sortValue;\n        });\n\n        // Remove index from items\n        for (i = 0; i < length; i++) {\n            delete arr[i].safeI; // stable sort index\n        }\n    }\n\n    /**\n     * Non-recursive method to find the lowest member of an array. Math.min raises a maximum\n     * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This\n     * method is slightly slower, but safe.\n     */\n    function arrayMin(data) {\n        var i = data.length,\n            min = data[0];\n\n        while (i--) {\n            if (data[i] < min) {\n                min = data[i];\n            }\n        }\n        return min;\n    }\n\n    /**\n     * Non-recursive method to find the lowest member of an array. Math.min raises a maximum\n     * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This\n     * method is slightly slower, but safe.\n     */\n    function arrayMax(data) {\n        var i = data.length,\n            max = data[0];\n\n        while (i--) {\n            if (data[i] > max) {\n                max = data[i];\n            }\n        }\n        return max;\n    }\n\n    /**\n     * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.\n     * It loops all properties and invokes destroy if there is a destroy method. The property is\n     * then delete'ed.\n     * @param {Object} The object to destroy properties on\n     * @param {Object} Exception, do not destroy this property, only delete it.\n     */\n    function destroyObjectProperties(obj, except) {\n        var n;\n        for (n in obj) {\n            // If the object is non-null and destroy is defined\n            if (obj[n] && obj[n] !== except && obj[n].destroy) {\n                // Invoke the destroy\n                obj[n].destroy();\n            }\n\n            // Delete the property from the object.\n            delete obj[n];\n        }\n    }\n\n\n    /**\n     * Discard an element by moving it to the bin and delete\n     * @param {Object} The HTML node to discard\n     */\n    function discardElement(element) {\n        // create a garbage bin element, not part of the DOM\n        if (!garbageBin) {\n            garbageBin = createElement(DIV);\n        }\n\n        // move the node and empty bin\n        if (element) {\n            garbageBin.appendChild(element);\n        }\n        garbageBin.innerHTML = '';\n    }\n\n    /**\n     * Fix JS round off float errors\n     * @param {Number} num\n     */\n    function correctFloat(num, prec) {\n        return parseFloat(\n            num.toPrecision(prec || 14)\n        );\n    }\n\n    /**\n     * Set the global animation to either a given value, or fall back to the\n     * given chart's animation option\n     * @param {Object} animation\n     * @param {Object} chart\n     */\n    function setAnimation(animation, chart) {\n        chart.renderer.globalAnimation = pick(animation, chart.animation);\n    }\n\n    /**\n     * The time unit lookup\n     */\n    timeUnits = {\n        millisecond: 1,\n        second: 1000,\n        minute: 60000,\n        hour: 3600000,\n        day: 24 * 3600000,\n        week: 7 * 24 * 3600000,\n        month: 28 * 24 * 3600000,\n        year: 364 * 24 * 3600000\n    };\n\n\n    /**\n     * Format a number and return a string based on input settings\n     * @param {Number} number The input number to format\n     * @param {Number} decimals The amount of decimals\n     * @param {String} decimalPoint The decimal point, defaults to the one given in the lang options\n     * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options\n     */\n    Highcharts.numberFormat = function (number, decimals, decimalPoint, thousandsSep) {\n\n        number = +number || 0;\n\n        var lang = defaultOptions.lang,\n            origDec = (number.toString().split('.')[1] || '').length,\n            decimalComponent,\n            strinteger,\n            thousands,\n            absNumber = Math.abs(number),\n            ret;\n\n        if (decimals === -1) {\n            decimals = Math.min(origDec, 20); // Preserve decimals. Not huge numbers (#3793).\n        } else if (isNaN(decimals)) {\n            decimals = 2;\n        }\n\n        // A string containing the positive integer component of the number\n        strinteger = String(pInt(absNumber.toFixed(decimals)));\n\n        // Leftover after grouping into thousands. Can be 0, 1 or 3.\n        thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;\n\n        // Language\n        decimalPoint = pick(decimalPoint, lang.decimalPoint);\n        thousandsSep = pick(thousandsSep, lang.thousandsSep);\n\n        // Start building the return\n        ret = number < 0 ? '-' : '';\n\n        // Add the leftover after grouping into thousands. For example, in the number 42 000 000,\n        // this line adds 42.\n        ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';\n\n        // Add the remaining thousands groups, joined by the thousands separator\n        ret += strinteger.substr(thousands).replace(/(\\d{3})(?=\\d)/g, '$1' + thousandsSep);\n\n        // Add the decimal point and the decimal component\n        if (+decimals) {\n            // Get the decimal component, and add power to avoid rounding errors with float numbers (#4573)\n            decimalComponent = Math.abs(absNumber - strinteger + Math.pow(10, -Math.max(decimals, origDec) - 1));\n            ret += decimalPoint + decimalComponent.toFixed(decimals).slice(2);\n        }\n\n        return ret;\n    };\n\n    /**\n     * Easing definition\n     * @param   {Number} pos Current position, ranging from 0 to 1\n     */\n    Math.easeInOutSine = function (pos) {\n        return -0.5 * (Math.cos(Math.PI * pos) - 1);\n    };\n\n    /**\n     * Internal method to return CSS value for given element and property\n     */\n    getStyle = function (el, prop) {\n\n        var style;\n\n        // For width and height, return the actual inner pixel size (#4913)\n        if (prop === 'width') {\n            return Math.min(el.offsetWidth, el.scrollWidth) - getStyle(el, 'padding-left') - getStyle(el, 'padding-right');\n        } else if (prop === 'height') {\n            return Math.min(el.offsetHeight, el.scrollHeight) - getStyle(el, 'padding-top') - getStyle(el, 'padding-bottom');\n        }\n\n        // Otherwise, get the computed style\n        style = win.getComputedStyle(el, undefined);\n        return style && pInt(style.getPropertyValue(prop));\n    };\n\n    /**\n     * Return the index of an item in an array, or -1 if not found\n     */\n    inArray = function (item, arr) {\n        return arr.indexOf ? arr.indexOf(item) : [].indexOf.call(arr, item);\n    };\n\n    /**\n     * Filter an array\n     */\n    grep = function (elements, callback) {\n        return [].filter.call(elements, callback);\n    };\n\n    /**\n     * Map an array\n     */\n    map = function (arr, fn) {\n        var results = [], i = 0, len = arr.length;\n\n        for (; i < len; i++) {\n            results[i] = fn.call(arr[i], arr[i], i, arr);\n        }\n\n        return results;\n    };\n\n    /**\n     * Get the element's offset position, corrected by overflow:auto.\n     */\n    offset = function (el) {\n        var docElem = doc.documentElement,\n            box = el.getBoundingClientRect();\n\n        return {\n            top: box.top  + (win.pageYOffset || docElem.scrollTop)  - (docElem.clientTop  || 0),\n            left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\n        };\n    };\n\n    /**\n     * Stop running animation.\n     * A possible extension to this would be to stop a single property, when\n     * we want to continue animating others. Then assign the prop to the timer\n     * in the Fx.run method, and check for the prop here. This would be an improvement\n     * in all cases where we stop the animation from .attr. Instead of stopping\n     * everything, we can just stop the actual attributes we're setting.\n     */\n    stop = function (el) {\n\n        var i = timers.length;\n\n        // Remove timers related to this element (#4519)\n        while (i--) {\n            if (timers[i].elem === el) {\n                timers[i].stopped = true; // #4667\n            }\n        }\n    };\n\n    /**\n     * Utility for iterating over an array.\n     * @param {Array} arr\n     * @param {Function} fn\n     */\n    each = function (arr, fn) { // modern browsers\n        return Array.prototype.forEach.call(arr, fn);\n    };\n\n    /**\n     * Add an event listener\n     */\n    addEvent = function (el, type, fn) {\n    \n        var events = el.hcEvents = el.hcEvents || {};\n\n        function wrappedFn(e) {\n            e.target = e.srcElement || win; // #2820\n            fn.call(el, e);\n        }\n\n        // Handle DOM events in modern browsers\n        if (el.addEventListener) {\n            el.addEventListener(type, fn, false);\n\n        // Handle old IE implementation\n        } else if (el.attachEvent) {\n\n            if (!el.hcEventsIE) {\n                el.hcEventsIE = {};\n            }\n\n            // Link wrapped fn with original fn, so we can get this in removeEvent\n            el.hcEventsIE[fn.toString()] = wrappedFn;\n\n            el.attachEvent('on' + type, wrappedFn);\n        }\n\n        if (!events[type]) {\n            events[type] = [];\n        }\n\n        events[type].push(fn);\n    };\n\n    /**\n     * Remove event added with addEvent\n     */\n    removeEvent = function (el, type, fn) {\n    \n        var events,\n            hcEvents = el.hcEvents,\n            index;\n\n        function removeOneEvent(type, fn) {\n            if (el.removeEventListener) {\n                el.removeEventListener(type, fn, false);\n            } else if (el.attachEvent) {\n                fn = el.hcEventsIE[fn.toString()];\n                el.detachEvent('on' + type, fn);\n            }\n        }\n\n        function removeAllEvents() {\n            var types,\n                len,\n                n;\n\n            if (!el.nodeName) {\n                return; // break on non-DOM events\n            }\n\n            if (type) {\n                types = {};\n                types[type] = true;\n            } else {\n                types = hcEvents;\n            }\n\n            for (n in types) {\n                if (hcEvents[n]) {\n                    len = hcEvents[n].length;\n                    while (len--) {\n                        removeOneEvent(n, hcEvents[n][len]);\n                    }\n                }\n            }\n        }\n\n        if (hcEvents) {\n            if (type) {\n                events = hcEvents[type] || [];\n                if (fn) {\n                    index = inArray(fn, events);\n                    if (index > -1) {\n                        events.splice(index, 1);\n                        hcEvents[type] = events;\n                    }\n                    removeOneEvent(type, fn);\n\n                } else {\n                    removeAllEvents();\n                    hcEvents[type] = [];\n                }\n            } else {\n                removeAllEvents();\n                el.hcEvents = {};\n            }\n        }\n    };\n\n    /**\n     * Fire an event on a custom object\n     */\n    fireEvent = function (el, type, eventArguments, defaultFunction) {\n        var e,\n            hcEvents = el.hcEvents,\n            events,\n            len,\n            i,\n            preventDefault,\n            fn;\n\n        eventArguments = eventArguments || {};\n\n        if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {\n            e = doc.createEvent('Events');\n            e.initEvent(type, true, true);\n            e.target = el;\n\n            extend(e, eventArguments);\n\n            if (el.dispatchEvent) {\n                el.dispatchEvent(e);\n            } else {\n                el.fireEvent(type, e);\n            }\n\n        } else if (hcEvents) {\n        \n            events = hcEvents[type] || [];\n            len = events.length;\n\n            // Attach a simple preventDefault function to skip default handler if called\n            preventDefault = function () {\n                eventArguments.defaultPrevented = true;\n            };\n        \n            for (i = 0; i < len; i++) {\n                fn = events[i];\n\n                // eventArguments is never null here\n                if (eventArguments.stopped) {\n                    return;\n                }\n\n                eventArguments.preventDefault = preventDefault;\n                eventArguments.target = el;\n\n                // If the type is not set, we're running a custom event (#2297). If it is set,\n                // we're running a browser event, and setting it will cause en error in\n                // IE8 (#2465).\n                if (!eventArguments.type) {\n                    eventArguments.type = type;\n                }\n            \n                // If the event handler return false, prevent the default handler from executing\n                if (fn.call(el, eventArguments) === false) {\n                    eventArguments.preventDefault();\n                }\n            }\n        }\n\n        // Run the default if not prevented\n        if (defaultFunction && !eventArguments.defaultPrevented) {\n            defaultFunction(eventArguments);\n        }\n    };\n\n    /**\n     * The global animate method, which uses Fx to create individual animators.\n     */\n    animate = function (el, params, opt) {\n        var start,\n            unit = '',\n            end,\n            fx,\n            args,\n            prop;\n\n        if (!isObject(opt)) { // Number or undefined/null\n            args = arguments;\n            opt = {\n                duration: args[2],\n                easing: args[3],\n                complete: args[4]\n            };\n        }\n        if (!isNumber(opt.duration)) {\n            opt.duration = 400;\n        }\n        opt.easing = Math[opt.easing] || Math.easeInOutSine;\n        opt.curAnim = merge(params);\n\n        for (prop in params) {\n            fx = new Fx(el, opt, prop);\n            end = null;\n\n            if (prop === 'd') {\n                fx.paths = fx.initPath(\n                    el,\n                    el.d,\n                    params.d\n                );\n                fx.toD = params.d;\n                start = 0;\n                end = 1;\n            } else if (el.attr) {\n                start = el.attr(prop);\n            } else {\n                start = parseFloat(getStyle(el, prop)) || 0;\n                if (prop !== 'opacity') {\n                    unit = 'px';\n                }\n            }\n\n            if (!end) {\n                end = params[prop];\n            }\n            if (end.match && end.match('px')) {\n                end = end.replace(/px/g, ''); // #4351\n            }\n            fx.run(start, end, unit);\n        }\n    };\n\n    /**\n     * Register Highcharts as a plugin in jQuery\n     */\n    if (win.jQuery) {\n        win.jQuery.fn.highcharts = function () {\n            var args = [].slice.call(arguments);\n\n            if (this[0]) { // this[0] is the renderTo div\n\n                // Create the chart\n                if (args[0]) {\n                    new Highcharts[ // eslint-disable-line no-new\n                        isString(args[0]) ? args.shift() : 'Chart' // Constructor defaults to Chart\n                    ](this[0], args[0], args[1]);\n                    return this;\n                }\n\n                // When called without parameters or with the return argument, return an existing chart\n                return charts[attr(this[0], 'data-highcharts-chart')];\n            }\n        };\n    }\n\n\n    /**\n     * Compatibility section to add support for legacy IE. This can be removed if old IE \n     * support is not needed.\n     */\n    if (doc && !doc.defaultView) {\n        getStyle = function (el, prop) {\n            var val,\n                alias = { width: 'clientWidth', height: 'clientHeight' }[prop];\n            \n            if (el.style[prop]) {\n                return pInt(el.style[prop]);\n            }\n            if (prop === 'opacity') {\n                prop = 'filter';\n            }\n\n            // Getting the rendered width and height\n            if (alias) {\n                el.style.zoom = 1;\n                return el[alias] - 2 * getStyle(el, 'padding');\n            }\n        \n            val = el.currentStyle[prop.replace(/\\-(\\w)/g, function (a, b) {\n                return b.toUpperCase();\n            })];\n            if (prop === 'filter') {\n                val = val.replace(\n                    /alpha\\(opacity=([0-9]+)\\)/, \n                    function (a, b) { \n                        return b / 100; \n                    }\n                );\n            }\n        \n            return val === '' ? 1 : pInt(val);\n        };\n    }\n\n    if (!Array.prototype.forEach) {\n        each = function (arr, fn) { // legacy\n            var i = 0, \n                len = arr.length;\n            for (; i < len; i++) {\n                if (fn.call(arr[i], arr[i], i, arr) === false) {\n                    return i;\n                }\n            }\n        };\n    }\n\n    if (!Array.prototype.indexOf) {\n        inArray = function (item, arr) {\n            var len, \n                i = 0;\n\n            if (arr) {\n                len = arr.length;\n            \n                for (; i < len; i++) {\n                    if (arr[i] === item) {\n                        return i;\n                    }\n                }\n            }\n\n            return -1;\n        };\n    }\n\n    if (!Array.prototype.filter) {\n        grep = function (elements, fn) {\n            var ret = [],\n                i = 0,\n                length = elements.length;\n\n            for (; i < length; i++) {\n                if (fn(elements[i], i)) {\n                    ret.push(elements[i]);\n                }\n            }\n\n            return ret;\n        };\n    }\n\n    //--- End compatibility section ---\n\n    // Expose utilities\n    Highcharts.Fx = Fx;\n    Highcharts.inArray = inArray;\n    Highcharts.each = each;\n    Highcharts.grep = grep;\n    Highcharts.offset = offset;\n    Highcharts.map = map;\n    Highcharts.addEvent = addEvent;\n    Highcharts.removeEvent = removeEvent;\n    Highcharts.fireEvent = fireEvent;\n    Highcharts.animate = animate;\n    Highcharts.stop = stop;\n\n    /* ****************************************************************************\n     * Handle the options                                                         *\n     *****************************************************************************/\n    defaultOptions = {\n        colors: ['#7cb5ec', '#434348', '#90ed7d', '#f7a35c',\n                '#8085e9', '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],\n        symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],\n        lang: {\n            loading: 'Loading...',\n            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',\n                    'August', 'September', 'October', 'November', 'December'],\n            shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n            weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n            // invalidDate: '',\n            decimalPoint: '.',\n            numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels\n            resetZoom: 'Reset zoom',\n            resetZoomTitle: 'Reset zoom level 1:1',\n            thousandsSep: ' '\n        },\n        global: {\n            useUTC: true,\n            //timezoneOffset: 0,\n            canvasToolsURL: 'http://code.highcharts.com/modules/canvas-tools.js',\n            VMLRadialGradientURL: 'http://code.highcharts.com/4.2.3/gfx/vml-radial-gradient.png'\n        },\n        chart: {\n            //animation: true,\n            //alignTicks: false,\n            //reflow: true,\n            //className: null,\n            //events: { load, selection },\n            //margin: [null],\n            //marginTop: null,\n            //marginRight: null,\n            //marginBottom: null,\n            //marginLeft: null,\n            borderColor: '#4572A7',\n            //borderWidth: 0,\n            borderRadius: 0,\n            defaultSeriesType: 'line',\n            ignoreHiddenSeries: true,\n            //inverted: false,\n            //shadow: false,\n            spacing: [10, 10, 15, 10],\n            //spacingTop: 10,\n            //spacingRight: 10,\n            //spacingBottom: 15,\n            //spacingLeft: 10,\n            //style: {\n            //    fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif', // default font\n            //    fontSize: '12px'\n            //},\n            backgroundColor: '#FFFFFF',\n            //plotBackgroundColor: null,\n            plotBorderColor: '#C0C0C0',\n            //plotBorderWidth: 0,\n            //plotShadow: false,\n            //zoomType: ''\n            resetZoomButton: {\n                theme: {\n                    zIndex: 20\n                },\n                position: {\n                    align: 'right',\n                    x: -10,\n                    //verticalAlign: 'top',\n                    y: 10\n                }\n                // relativeTo: 'plot'\n            }\n        },\n        title: {\n            text: 'Chart title',\n            align: 'center',\n            // floating: false,\n            margin: 15,\n            // x: 0,\n            // verticalAlign: 'top',\n            // y: null,\n            style: {\n                color: '#333333',\n                fontSize: '18px'\n            }\n\n        },\n        subtitle: {\n            text: '',\n            align: 'center',\n            // floating: false\n            // x: 0,\n            // verticalAlign: 'top',\n            // y: null,\n            style: {\n                color: '#555555'\n            }\n        },\n\n        plotOptions: {\n            line: { // base series options\n                allowPointSelect: false,\n                showCheckbox: false,\n                animation: {\n                    duration: 1000\n                },\n                //connectNulls: false,\n                //cursor: 'default',\n                //clip: true,\n                //dashStyle: null,\n                //enableMouseTracking: true,\n                events: {},\n                //legendIndex: 0,\n                //linecap: 'round',\n                lineWidth: 2,\n                //shadow: false,\n                // stacking: null,\n                marker: {\n                    //enabled: true,\n                    //symbol: null,\n                    lineWidth: 0,\n                    radius: 4,\n                    lineColor: '#FFFFFF',\n                    //fillColor: null,\n                    states: { // states for a single point\n                        hover: {\n                            enabled: true,\n                            lineWidthPlus: 1,\n                            radiusPlus: 2\n                        },\n                        select: {\n                            fillColor: '#FFFFFF',\n                            lineColor: '#000000',\n                            lineWidth: 2\n                        }\n                    }\n                },\n                point: {\n                    events: {}\n                },\n                dataLabels: {\n                    align: 'center',\n                    // defer: true,\n                    // enabled: false,\n                    formatter: function () {\n                        return this.y === null ? '' : Highcharts.numberFormat(this.y, -1);\n                    },\n                    style: {\n                        color: 'contrast',\n                        fontSize: '11px',\n                        fontWeight: 'bold',\n                        textShadow: '0 0 6px contrast, 0 0 3px contrast'\n                    },\n                    verticalAlign: 'bottom', // above singular point\n                    x: 0,\n                    y: 0,\n                    // backgroundColor: undefined,\n                    // borderColor: undefined,\n                    // borderRadius: undefined,\n                    // borderWidth: undefined,\n                    padding: 5\n                    // shadow: false\n                },\n                cropThreshold: 300, // draw points outside the plot area when the number of points is less than this\n                pointRange: 0,\n                //pointStart: 0,\n                //pointInterval: 1,\n                //showInLegend: null, // auto: true for standalone series, false for linked series\n                softThreshold: true,\n                states: { // states for the entire series\n                    hover: {\n                        //enabled: false,\n                        lineWidthPlus: 1,\n                        marker: {\n                            // lineWidth: base + 1,\n                            // radius: base + 1\n                        },\n                        halo: {\n                            size: 10,\n                            opacity: 0.25\n                        }\n                    },\n                    select: {\n                        marker: {}\n                    }\n                },\n                stickyTracking: true,\n                //tooltip: {\n                    //pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.y}</b>'\n                    //valueDecimals: null,\n                    //xDateFormat: '%A, %b %e, %Y',\n                    //valuePrefix: '',\n                    //ySuffix: ''\n                //}\n                turboThreshold: 1000\n                // zIndex: null\n            }\n        },\n        labels: {\n            //items: [],\n            style: {\n                //font: defaultFont,\n                position: ABSOLUTE,\n                color: '#3E576F'\n            }\n        },\n        legend: {\n            enabled: true,\n            align: 'center',\n            //floating: false,\n            layout: 'horizontal',\n            labelFormatter: function () {\n                return this.name;\n            },\n            //borderWidth: 0,\n            borderColor: '#909090',\n            borderRadius: 0,\n            navigation: {\n                // animation: true,\n                activeColor: '#274b6d',\n                // arrowSize: 12\n                inactiveColor: '#CCC'\n                // style: {} // text styles\n            },\n            // margin: 20,\n            // reversed: false,\n            shadow: false,\n            // backgroundColor: null,\n            /*style: {\n                padding: '5px'\n            },*/\n            itemStyle: {\n                color: '#333333',\n                fontSize: '12px',\n                fontWeight: 'bold'\n            },\n            itemHoverStyle: {\n                //cursor: 'pointer', removed as of #601\n                color: '#000'\n            },\n            itemHiddenStyle: {\n                color: '#CCC'\n            },\n            itemCheckboxStyle: {\n                position: ABSOLUTE,\n                width: '13px', // for IE precision\n                height: '13px'\n            },\n            // itemWidth: undefined,\n            // symbolRadius: 0,\n            // symbolWidth: 16,\n            symbolPadding: 5,\n            verticalAlign: 'bottom',\n            // width: undefined,\n            x: 0,\n            y: 0,\n            title: {\n                //text: null,\n                style: {\n                    fontWeight: 'bold'\n                }\n            }\n        },\n\n        loading: {\n            // hideDuration: 100,\n            labelStyle: {\n                fontWeight: 'bold',\n                position: RELATIVE,\n                top: '45%'\n            },\n            // showDuration: 0,\n            style: {\n                position: ABSOLUTE,\n                backgroundColor: 'white',\n                opacity: 0.5,\n                textAlign: 'center'\n            }\n        },\n\n        tooltip: {\n            enabled: true,\n            animation: hasSVG,\n            //crosshairs: null,\n            backgroundColor: 'rgba(249, 249, 249, .85)',\n            borderWidth: 1,\n            borderRadius: 3,\n            dateTimeLabelFormats: {\n                millisecond: '%A, %b %e, %H:%M:%S.%L',\n                second: '%A, %b %e, %H:%M:%S',\n                minute: '%A, %b %e, %H:%M',\n                hour: '%A, %b %e, %H:%M',\n                day: '%A, %b %e, %Y',\n                week: 'Week from %A, %b %e, %Y',\n                month: '%B %Y',\n                year: '%Y'\n            },\n            footerFormat: '',\n            //formatter: defaultFormatter,\n            headerFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n            pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.y}</b><br/>',\n            shadow: true,\n            //shape: 'callout',\n            //shared: false,\n            snap: isTouchDevice ? 25 : 10,\n            style: {\n                color: '#333333',\n                cursor: 'default',\n                fontSize: '12px',\n                padding: '8px',\n                pointerEvents: 'none', // #1686 http://caniuse.com/#feat=pointer-events\n                whiteSpace: 'nowrap'\n            }\n            //xDateFormat: '%A, %b %e, %Y',\n            //valueDecimals: null,\n            //valuePrefix: '',\n            //valueSuffix: ''\n        },\n\n        credits: {\n            enabled: true,\n            text: 'Highcharts.com',\n            href: 'http://www.highcharts.com',\n            position: {\n                align: 'right',\n                x: -10,\n                verticalAlign: 'bottom',\n                y: -5\n            },\n            style: {\n                cursor: 'pointer',\n                color: '#909090',\n                fontSize: '9px'\n            }\n        }\n    };\n\n\n\n    /**\n     * Set the time methods globally based on the useUTC option. Time method can be either\n     * local time or UTC (default).\n     */\n    function setTimeMethods() {\n        var globalOptions = defaultOptions.global,\n            useUTC = globalOptions.useUTC,\n            GET = useUTC ? 'getUTC' : 'get',\n            SET = useUTC ? 'setUTC' : 'set';\n\n\n        Date = globalOptions.Date || win.Date;\n        timezoneOffset = useUTC && globalOptions.timezoneOffset;\n        getTimezoneOffset = useUTC && globalOptions.getTimezoneOffset;\n        makeTime = function (year, month, date, hours, minutes, seconds) {\n            var d;\n            if (useUTC) {\n                d = Date.UTC.apply(0, arguments);\n                d += getTZOffset(d);\n            } else {\n                d = new Date(\n                    year,\n                    month,\n                    pick(date, 1),\n                    pick(hours, 0),\n                    pick(minutes, 0),\n                    pick(seconds, 0)\n                ).getTime();\n            }\n            return d;\n        };\n        getMinutes =      GET + 'Minutes';\n        getHours =        GET + 'Hours';\n        getDay =          GET + 'Day';\n        getDate =         GET + 'Date';\n        getMonth =        GET + 'Month';\n        getFullYear =     GET + 'FullYear';\n        setMilliseconds = SET + 'Milliseconds';\n        setSeconds =      SET + 'Seconds';\n        setMinutes =      SET + 'Minutes';\n        setHours =        SET + 'Hours';\n        setDate =         SET + 'Date';\n        setMonth =        SET + 'Month';\n        setFullYear =     SET + 'FullYear';\n\n    }\n\n    /**\n     * Merge the default options with custom options and return the new options structure\n     * @param {Object} options The new custom options\n     */\n    function setOptions(options) {\n\n        // Copy in the default options\n        defaultOptions = merge(true, defaultOptions, options);\n\n        // Apply UTC\n        setTimeMethods();\n\n        return defaultOptions;\n    }\n\n    /**\n     * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules\n     * wasn't enough because the setOptions method created a new object.\n     */\n    function getOptions() {\n        return defaultOptions;\n    }\n\n\n\n\n\n\n    // Series defaults\n    var defaultPlotOptions = defaultOptions.plotOptions,\n        defaultSeriesOptions = defaultPlotOptions.line;\n\n    // set the default time methods\n    setTimeMethods();\n\n\n    /**\n     * Handle color operations. The object methods are chainable.\n     * @param {String} input The input color in either rbga or hex format\n     */\n    function Color(input) {\n        // Backwards compatibility, allow instanciation without new\n        if (!(this instanceof Color)) {\n            return new Color(input);\n        }\n        // Initialize\n        this.init(input);\n    }\n    Color.prototype = {\n\n        // Collection of parsers. This can be extended from the outside by pushing parsers\n        // to Highcharts.Colors.prototype.parsers.\n        parsers: [{\n            // RGBA color\n            regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n            parse: function (result) {\n                return [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];\n            }\n        }, {\n            // HEX color\n            regex: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,\n            parse: function (result) {\n                return [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];\n            }\n        }, {\n            // RGB color\n            regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n            parse: function (result) {\n                return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];\n            }\n        }],\n\n        /**\n         * Parse the input color to rgba array\n         * @param {String} input\n         */\n        init: function (input) {\n            var result,\n                rgba,\n                i,\n                parser;\n\n            this.input = input;\n\n            // Gradients\n            if (input && input.stops) {\n                this.stops = map(input.stops, function (stop) {\n                    return new Color(stop[1]);\n                });\n\n            // Solid colors\n            } else {\n                i = this.parsers.length;\n                while (i-- && !rgba) {\n                    parser = this.parsers[i];\n                    result = parser.regex.exec(input);\n                    if (result) {\n                        rgba = parser.parse(result);\n                    }\n                }\n            }\n            this.rgba = rgba || [];\n        },\n\n        /**\n         * Return the color a specified format\n         * @param {String} format\n         */\n        get: function (format) {\n            var input = this.input,\n                rgba = this.rgba,\n                ret;\n\n            if (this.stops) {\n                ret = merge(input);\n                ret.stops = [].concat(ret.stops);\n                each(this.stops, function (stop, i) {\n                    ret.stops[i] = [ret.stops[i][0], stop.get(format)];\n                });\n\n            // it's NaN if gradient colors on a column chart\n            } else if (rgba && !isNaN(rgba[0])) {\n                if (format === 'rgb' || (!format && rgba[3] === 1)) {\n                    ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';\n                } else if (format === 'a') {\n                    ret = rgba[3];\n                } else {\n                    ret = 'rgba(' + rgba.join(',') + ')';\n                }\n            } else {\n                ret = input;\n            }\n            return ret;\n        },\n\n        /**\n         * Brighten the color\n         * @param {Number} alpha\n         */\n        brighten: function (alpha) {\n            var i, \n                rgba = this.rgba;\n\n            if (this.stops) {\n                each(this.stops, function (stop) {\n                    stop.brighten(alpha);\n                });\n\n            } else if (isNumber(alpha) && alpha !== 0) {\n                for (i = 0; i < 3; i++) {\n                    rgba[i] += pInt(alpha * 255);\n\n                    if (rgba[i] < 0) {\n                        rgba[i] = 0;\n                    }\n                    if (rgba[i] > 255) {\n                        rgba[i] = 255;\n                    }\n                }\n            }\n            return this;\n        },\n\n        /**\n         * Set the color's opacity to a given alpha value\n         * @param {Number} alpha\n         */\n        setOpacity: function (alpha) {\n            this.rgba[3] = alpha;\n            return this;\n        }\n    };\n\n\n    /**\n     * A wrapper object for SVG elements\n     */\n    function SVGElement() {}\n\n    SVGElement.prototype = {\n\n        // Default base for animation\n        opacity: 1,\n        // For labels, these CSS properties are applied to the <text> node directly\n        textProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily', 'fontStyle', 'color',\n            'lineHeight', 'width', 'textDecoration', 'textOverflow', 'textShadow'],\n\n        /**\n         * Initialize the SVG renderer\n         * @param {Object} renderer\n         * @param {String} nodeName\n         */\n        init: function (renderer, nodeName) {\n            var wrapper = this;\n            wrapper.element = nodeName === 'span' ?\n                    createElement(nodeName) :\n                    doc.createElementNS(SVG_NS, nodeName);\n            wrapper.renderer = renderer;\n        },\n\n        /**\n         * Animate a given attribute\n         * @param {Object} params\n         * @param {Number} options Options include duration, easing, step and complete\n         * @param {Function} complete Function to perform at the end of animation\n         */\n        animate: function (params, options, complete) {\n            var animOptions = pick(options, this.renderer.globalAnimation, true);\n            stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)\n            if (animOptions) {\n                animOptions = merge(animOptions, {}); //#2625\n                if (complete) { // allows using a callback with the global animation without overwriting it\n                    animOptions.complete = complete;\n                }\n                animate(this, params, animOptions);\n            } else {\n                this.attr(params, null, complete);\n            }\n            return this;\n        },\n\n        /**\n         * Build an SVG gradient out of a common JavaScript configuration object\n         */\n        colorGradient: function (color, prop, elem) {\n            var renderer = this.renderer,\n                colorObject,\n                gradName,\n                gradAttr,\n                radAttr,\n                gradients,\n                gradientObject,\n                stops,\n                stopColor,\n                stopOpacity,\n                radialReference,\n                n,\n                id,\n                key = [],\n                value;\n\n            // Apply linear or radial gradients\n            if (color.linearGradient) {\n                gradName = 'linearGradient';\n            } else if (color.radialGradient) {\n                gradName = 'radialGradient';\n            }\n\n            if (gradName) {\n                gradAttr = color[gradName];\n                gradients = renderer.gradients;\n                stops = color.stops;\n                radialReference = elem.radialReference;\n\n                // Keep < 2.2 kompatibility\n                if (isArray(gradAttr)) {\n                    color[gradName] = gradAttr = {\n                        x1: gradAttr[0],\n                        y1: gradAttr[1],\n                        x2: gradAttr[2],\n                        y2: gradAttr[3],\n                        gradientUnits: 'userSpaceOnUse'\n                    };\n                }\n\n                // Correct the radial gradient for the radial reference system\n                if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {\n                    radAttr = gradAttr; // Save the radial attributes for updating\n                    gradAttr = merge(gradAttr,\n                        renderer.getRadialAttr(radialReference, radAttr),\n                        { gradientUnits: 'userSpaceOnUse' }\n                        );\n                }\n\n                // Build the unique key to detect whether we need to create a new element (#1282)\n                for (n in gradAttr) {\n                    if (n !== 'id') {\n                        key.push(n, gradAttr[n]);\n                    }\n                }\n                for (n in stops) {\n                    key.push(stops[n]);\n                }\n                key = key.join(',');\n\n                // Check if a gradient object with the same config object is created within this renderer\n                if (gradients[key]) {\n                    id = gradients[key].attr('id');\n\n                } else {\n\n                    // Set the id and create the element\n                    gradAttr.id = id = PREFIX + idCounter++;\n                    gradients[key] = gradientObject = renderer.createElement(gradName)\n                        .attr(gradAttr)\n                        .add(renderer.defs);\n\n                    gradientObject.radAttr = radAttr;\n\n                    // The gradient needs to keep a list of stops to be able to destroy them\n                    gradientObject.stops = [];\n                    each(stops, function (stop) {\n                        var stopObject;\n                        if (stop[1].indexOf('rgba') === 0) {\n                            colorObject = Color(stop[1]);\n                            stopColor = colorObject.get('rgb');\n                            stopOpacity = colorObject.get('a');\n                        } else {\n                            stopColor = stop[1];\n                            stopOpacity = 1;\n                        }\n                        stopObject = renderer.createElement('stop').attr({\n                            offset: stop[0],\n                            'stop-color': stopColor,\n                            'stop-opacity': stopOpacity\n                        }).add(gradientObject);\n\n                        // Add the stop element to the gradient\n                        gradientObject.stops.push(stopObject);\n                    });\n                }\n\n                // Set the reference to the gradient object\n                value = 'url(' + renderer.url + '#' + id + ')';\n                elem.setAttribute(prop, value);\n                elem.gradient = key;\n\n                // Allow the color to be concatenated into tooltips formatters etc. (#2995)\n                color.toString = function () {\n                    return value;\n                };\n            }\n        },\n\n        /**\n         * Apply a polyfill to the text-stroke CSS property, by copying the text element\n         * and apply strokes to the copy.\n         *\n         * Contrast checks at http://jsfiddle.net/highcharts/43soe9m1/2/\n         */\n        applyTextShadow: function (textShadow) {\n            var elem = this.element,\n                tspans,\n                hasContrast = textShadow.indexOf('contrast') !== -1,\n                styles = {},\n                forExport = this.renderer.forExport,\n                // IE10 and IE11 report textShadow in elem.style even though it doesn't work. Check\n                // this again with new IE release. In exports, the rendering is passed to PhantomJS.\n                supports = forExport || (elem.style.textShadow !== UNDEFINED && !isMS);\n\n            // When the text shadow is set to contrast, use dark stroke for light text and vice versa\n            if (hasContrast) {\n                styles.textShadow = textShadow = textShadow.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));\n            }\n\n            // Safari with retina displays as well as PhantomJS bug (#3974). Firefox does not tolerate this,\n            // it removes the text shadows.\n            if (isWebKit || forExport) {\n                styles.textRendering = 'geometricPrecision';\n            }\n\n            /* Selective side-by-side testing in supported browser (http://jsfiddle.net/highcharts/73L1ptrh/)\n            if (elem.textContent.indexOf('2.') === 0) {\n                elem.style['text-shadow'] = 'none';\n                supports = false;\n            }\n            // */\n\n            // No reason to polyfill, we've got native support\n            if (supports) {\n                this.css(styles); // Apply altered textShadow or textRendering workaround\n            } else {\n\n                this.fakeTS = true; // Fake text shadow\n\n                // In order to get the right y position of the clones,\n                // copy over the y setter\n                this.ySetter = this.xSetter;\n\n                tspans = [].slice.call(elem.getElementsByTagName('tspan'));\n                each(textShadow.split(/\\s?,\\s?/g), function (textShadow) {\n                    var firstChild = elem.firstChild,\n                        color,\n                        strokeWidth;\n\n                    textShadow = textShadow.split(' ');\n                    color = textShadow[textShadow.length - 1];\n\n                    // Approximately tune the settings to the text-shadow behaviour\n                    strokeWidth = textShadow[textShadow.length - 2];\n\n                    if (strokeWidth) {\n                        each(tspans, function (tspan, y) {\n                            var clone;\n\n                            // Let the first line start at the correct X position\n                            if (y === 0) {\n                                tspan.setAttribute('x', elem.getAttribute('x'));\n                                y = elem.getAttribute('y');\n                                tspan.setAttribute('y', y || 0);\n                                if (y === null) {\n                                    elem.setAttribute('y', 0);\n                                }\n                            }\n\n                            // Create the clone and apply shadow properties\n                            clone = tspan.cloneNode(1);\n                            attr(clone, {\n                                'class': PREFIX + 'text-shadow',\n                                'fill': color,\n                                'stroke': color,\n                                'stroke-opacity': 1 / mathMax(pInt(strokeWidth), 3),\n                                'stroke-width': strokeWidth,\n                                'stroke-linejoin': 'round'\n                            });\n                            elem.insertBefore(clone, firstChild);\n                        });\n                    }\n                });\n            }\n        },\n\n        /**\n         * Set or get a given attribute\n         * @param {Object|String} hash\n         * @param {Mixed|Undefined} val\n         */\n        attr: function (hash, val, complete) {\n            var key,\n                value,\n                element = this.element,\n                hasSetSymbolSize,\n                ret = this,\n                skipAttr,\n                setter;\n\n            // single key-value pair\n            if (typeof hash === 'string' && val !== UNDEFINED) {\n                key = hash;\n                hash = {};\n                hash[key] = val;\n            }\n\n            // used as a getter: first argument is a string, second is undefined\n            if (typeof hash === 'string') {\n                ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);\n\n            // setter\n            } else {\n\n                for (key in hash) {\n                    value = hash[key];\n                    skipAttr = false;\n\n\n\n                    if (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {\n                        if (!hasSetSymbolSize) {\n                            this.symbolAttr(hash);\n                            hasSetSymbolSize = true;\n                        }\n                        skipAttr = true;\n                    }\n\n                    if (this.rotation && (key === 'x' || key === 'y')) {\n                        this.doTransform = true;\n                    }\n\n                    if (!skipAttr) {\n                        setter = this[key + 'Setter'] || this._defaultSetter;\n                        setter.call(this, value, key, element);\n\n                        // Let the shadow follow the main element\n                        if (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {\n                            this.updateShadows(key, value, setter);\n                        }\n                    }\n                }\n\n                // Update transform. Do this outside the loop to prevent redundant updating for batch setting\n                // of attributes.\n                if (this.doTransform) {\n                    this.updateTransform();\n                    this.doTransform = false;\n                }\n\n            }\n\n            // In accordance with animate, run a complete callback\n            if (complete) {\n                complete();\n            }\n\n            return ret;\n        },\n\n        /**\n         * Update the shadow elements with new attributes\n         * @param   {String}        key    The attribute name\n         * @param   {String|Number} value  The value of the attribute\n         * @param   {Function}      setter The setter function, inherited from the parent wrapper\n         * @returns {undefined}\n         */\n        updateShadows: function (key, value, setter) {\n            var shadows = this.shadows,\n                i = shadows.length;\n\n            while (i--) {\n                setter.call(\n                    null, \n                    key === 'height' ?\n                        Math.max(value - (shadows[i].cutHeight || 0), 0) :\n                        key === 'd' ? this.d : value, \n                    key, \n                    shadows[i]\n                );\n            }\n        },\n\n        /**\n         * Add a class name to an element\n         */\n        addClass: function (className) {\n            var element = this.element,\n                currentClassName = attr(element, 'class') || '';\n\n            if (currentClassName.indexOf(className) === -1) {\n                attr(element, 'class', currentClassName + ' ' + className);\n            }\n            return this;\n        },\n        /* hasClass and removeClass are not (yet) needed\n        hasClass: function (className) {\n            return attr(this.element, 'class').indexOf(className) !== -1;\n        },\n        removeClass: function (className) {\n            attr(this.element, 'class', attr(this.element, 'class').replace(className, ''));\n            return this;\n        },\n        */\n\n        /**\n         * If one of the symbol size affecting parameters are changed,\n         * check all the others only once for each call to an element's\n         * .attr() method\n         * @param {Object} hash\n         */\n        symbolAttr: function (hash) {\n            var wrapper = this;\n\n            each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {\n                wrapper[key] = pick(hash[key], wrapper[key]);\n            });\n\n            wrapper.attr({\n                d: wrapper.renderer.symbols[wrapper.symbolName](\n                    wrapper.x,\n                    wrapper.y,\n                    wrapper.width,\n                    wrapper.height,\n                    wrapper\n                )\n            });\n        },\n\n        /**\n         * Apply a clipping path to this object\n         * @param {String} id\n         */\n        clip: function (clipRect) {\n            return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : NONE);\n        },\n\n        /**\n         * Calculate the coordinates needed for drawing a rectangle crisply and return the\n         * calculated attributes\n         * @param {Number} strokeWidth\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Number} width\n         * @param {Number} height\n         */\n        crisp: function (rect) {\n\n            var wrapper = this,\n                key,\n                attribs = {},\n                normalizer,\n                strokeWidth = wrapper.strokeWidth || 0;\n\n            normalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors\n\n            // normalize for crisp edges\n            rect.x = mathFloor(rect.x || wrapper.x || 0) + normalizer;\n            rect.y = mathFloor(rect.y || wrapper.y || 0) + normalizer;\n            rect.width = mathFloor((rect.width || wrapper.width || 0) - 2 * normalizer);\n            rect.height = mathFloor((rect.height || wrapper.height || 0) - 2 * normalizer);\n            rect.strokeWidth = strokeWidth;\n\n            for (key in rect) {\n                if (wrapper[key] !== rect[key]) { // only set attribute if changed\n                    wrapper[key] = attribs[key] = rect[key];\n                }\n            }\n\n            return attribs;\n        },\n\n        /**\n         * Set styles for the element\n         * @param {Object} styles\n         */\n        css: function (styles) {\n            var elemWrapper = this,\n                oldStyles = elemWrapper.styles,\n                newStyles = {},\n                elem = elemWrapper.element,\n                textWidth,\n                n,\n                serializedCss = '',\n                hyphenate,\n                hasNew = !oldStyles;\n\n            // convert legacy\n            if (styles && styles.color) {\n                styles.fill = styles.color;\n            }\n\n            // Filter out existing styles to increase performance (#2640)\n            if (oldStyles) {\n                for (n in styles) {\n                    if (styles[n] !== oldStyles[n]) {\n                        newStyles[n] = styles[n];\n                        hasNew = true;\n                    }\n                }\n            }\n            if (hasNew) {\n                textWidth = elemWrapper.textWidth =\n                    (styles && styles.width && elem.nodeName.toLowerCase() === 'text' && pInt(styles.width)) ||\n                    elemWrapper.textWidth; // #3501\n\n                // Merge the new styles with the old ones\n                if (oldStyles) {\n                    styles = extend(\n                        oldStyles,\n                        newStyles\n                    );\n                }\n\n                // store object\n                elemWrapper.styles = styles;\n\n                if (textWidth && (useCanVG || (!hasSVG && elemWrapper.renderer.forExport))) {\n                    delete styles.width;\n                }\n\n                // serialize and set style attribute\n                if (isMS && !hasSVG) {\n                    css(elemWrapper.element, styles);\n                } else {\n                    hyphenate = function (a, b) {\n                        return '-' + b.toLowerCase();\n                    };\n                    for (n in styles) {\n                        serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';\n                    }\n                    attr(elem, 'style', serializedCss); // #1881\n                }\n\n\n                // re-build text\n                if (textWidth && elemWrapper.added) {\n                    elemWrapper.renderer.buildText(elemWrapper);\n                }\n            }\n\n            return elemWrapper;\n        },\n\n        /**\n         * Add an event listener\n         * @param {String} eventType\n         * @param {Function} handler\n         */\n        on: function (eventType, handler) {\n            var svgElement = this,\n                element = svgElement.element;\n\n            // touch\n            if (hasTouch && eventType === 'click') {\n                element.ontouchstart = function (e) {\n                    svgElement.touchEventFired = Date.now();\n                    e.preventDefault();\n                    handler.call(element, e);\n                };\n                element.onclick = function (e) {\n                    if (userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) { // #2269\n                        handler.call(element, e);\n                    }\n                };\n            } else {\n                // simplest possible event model for internal use\n                element['on' + eventType] = handler;\n            }\n            return this;\n        },\n\n        /**\n         * Set the coordinates needed to draw a consistent radial gradient across\n         * pie slices regardless of positioning inside the chart. The format is\n         * [centerX, centerY, diameter] in pixels.\n         */\n        setRadialReference: function (coordinates) {\n            var existingGradient = this.renderer.gradients[this.element.gradient];\n\n            this.element.radialReference = coordinates;\n\n            // On redrawing objects with an existing gradient, the gradient needs\n            // to be repositioned (#3801)\n            if (existingGradient && existingGradient.radAttr) {\n                existingGradient.animate(\n                    this.renderer.getRadialAttr(\n                        coordinates,\n                        existingGradient.radAttr\n                    )\n                );\n            }\n\n            return this;\n        },\n\n        /**\n         * Move an object and its children by x and y values\n         * @param {Number} x\n         * @param {Number} y\n         */\n        translate: function (x, y) {\n            return this.attr({\n                translateX: x,\n                translateY: y\n            });\n        },\n\n        /**\n         * Invert a group, rotate and flip\n         */\n        invert: function () {\n            var wrapper = this;\n            wrapper.inverted = true;\n            wrapper.updateTransform();\n            return wrapper;\n        },\n\n        /**\n         * Private method to update the transform attribute based on internal\n         * properties\n         */\n        updateTransform: function () {\n            var wrapper = this,\n                translateX = wrapper.translateX || 0,\n                translateY = wrapper.translateY || 0,\n                scaleX = wrapper.scaleX,\n                scaleY = wrapper.scaleY,\n                inverted = wrapper.inverted,\n                rotation = wrapper.rotation,\n                element = wrapper.element,\n                transform;\n\n            // flipping affects translate as adjustment for flipping around the group's axis\n            if (inverted) {\n                translateX += wrapper.attr('width');\n                translateY += wrapper.attr('height');\n            }\n\n            // Apply translate. Nearly all transformed elements have translation, so instead\n            // of checking for translate = 0, do it always (#1767, #1846).\n            transform = ['translate(' + translateX + ',' + translateY + ')'];\n\n            // apply rotation\n            if (inverted) {\n                transform.push('rotate(90) scale(-1,1)');\n            } else if (rotation) { // text rotation\n                transform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');\n\n                // Delete bBox memo when the rotation changes\n                //delete wrapper.bBox;\n            }\n\n            // apply scale\n            if (defined(scaleX) || defined(scaleY)) {\n                transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');\n            }\n\n            if (transform.length) {\n                element.setAttribute('transform', transform.join(' '));\n            }\n        },\n        /**\n         * Bring the element to the front\n         */\n        toFront: function () {\n            var element = this.element;\n            element.parentNode.appendChild(element);\n            return this;\n        },\n\n\n        /**\n         * Break down alignment options like align, verticalAlign, x and y\n         * to x and y relative to the chart.\n         *\n         * @param {Object} alignOptions\n         * @param {Boolean} alignByTranslate\n         * @param {String[Object} box The box to align to, needs a width and height. When the\n         *        box is a string, it refers to an object in the Renderer. For example, when\n         *        box is 'spacingBox', it refers to Renderer.spacingBox which holds width, height\n         *        x and y properties.\n         *\n         */\n        align: function (alignOptions, alignByTranslate, box) {\n            var align,\n                vAlign,\n                x,\n                y,\n                attribs = {},\n                alignTo,\n                renderer = this.renderer,\n                alignedObjects = renderer.alignedObjects;\n\n            // First call on instanciate\n            if (alignOptions) {\n                this.alignOptions = alignOptions;\n                this.alignByTranslate = alignByTranslate;\n                if (!box || isString(box)) { // boxes other than renderer handle this internally\n                    this.alignTo = alignTo = box || 'renderer';\n                    erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize\n                    alignedObjects.push(this);\n                    box = null; // reassign it below\n                }\n\n            // When called on resize, no arguments are supplied\n            } else {\n                alignOptions = this.alignOptions;\n                alignByTranslate = this.alignByTranslate;\n                alignTo = this.alignTo;\n            }\n\n            box = pick(box, renderer[alignTo], renderer);\n\n            // Assign variables\n            align = alignOptions.align;\n            vAlign = alignOptions.verticalAlign;\n            x = (box.x || 0) + (alignOptions.x || 0); // default: left align\n            y = (box.y || 0) + (alignOptions.y || 0); // default: top align\n\n            // Align\n            if (align === 'right' || align === 'center') {\n                x += (box.width - (alignOptions.width || 0)) /\n                        { right: 1, center: 2 }[align];\n            }\n            attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);\n\n\n            // Vertical align\n            if (vAlign === 'bottom' || vAlign === 'middle') {\n                y += (box.height - (alignOptions.height || 0)) /\n                        ({ bottom: 1, middle: 2 }[vAlign] || 1);\n\n            }\n            attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);\n\n            // Animate only if already placed\n            this[this.placed ? 'animate' : 'attr'](attribs);\n            this.placed = true;\n            this.alignAttr = attribs;\n\n            return this;\n        },\n\n        /**\n         * Get the bounding box (width, height, x and y) for the element\n         */\n        getBBox: function (reload, rot) {\n            var wrapper = this,\n                bBox, // = wrapper.bBox,\n                renderer = wrapper.renderer,\n                width,\n                height,\n                rotation,\n                rad,\n                element = wrapper.element,\n                styles = wrapper.styles,\n                textStr = wrapper.textStr,\n                textShadow,\n                elemStyle = element.style,\n                toggleTextShadowShim,\n                cache = renderer.cache,\n                cacheKeys = renderer.cacheKeys,\n                cacheKey;\n\n            rotation = pick(rot, wrapper.rotation);\n            rad = rotation * deg2rad;\n\n            if (textStr !== UNDEFINED) {\n\n                // Properties that affect bounding box\n                cacheKey = ['', rotation || 0, styles && styles.fontSize, element.style.width].join(',');\n\n                // Since numbers are monospaced, and numerical labels appear a lot in a chart,\n                // we assume that a label of n characters has the same bounding box as others\n                // of the same length.\n                if (textStr === '' || numRegex.test(textStr)) {\n                    cacheKey = 'num:' + textStr.toString().length + cacheKey;\n\n                // Caching all strings reduces rendering time by 4-5%.\n                } else {\n                    cacheKey = textStr + cacheKey;\n                }\n            }\n\n            if (cacheKey && !reload) {\n                bBox = cache[cacheKey];\n            }\n\n            // No cache found\n            if (!bBox) {\n\n                // SVG elements\n                if (element.namespaceURI === SVG_NS || renderer.forExport) {\n                    try { // Fails in Firefox if the container has display: none.\n\n                        // When the text shadow shim is used, we need to hide the fake shadows\n                        // to get the correct bounding box (#3872)\n                        toggleTextShadowShim = this.fakeTS && function (display) {\n                            each(element.querySelectorAll('.' + PREFIX + 'text-shadow'), function (tspan) {\n                                tspan.style.display = display;\n                            });\n                        };\n\n                        // Workaround for #3842, Firefox reporting wrong bounding box for shadows\n                        if (isFirefox && elemStyle.textShadow) {\n                            textShadow = elemStyle.textShadow;\n                            elemStyle.textShadow = '';\n                        } else if (toggleTextShadowShim) {\n                            toggleTextShadowShim(NONE);\n                        }\n\n                        bBox = element.getBBox ?\n                            // SVG: use extend because IE9 is not allowed to change width and height in case\n                            // of rotation (below)\n                            extend({}, element.getBBox()) :\n                            // Canvas renderer and legacy IE in export mode\n                            {\n                                width: element.offsetWidth,\n                                height: element.offsetHeight\n                            };\n\n                        // #3842\n                        if (textShadow) {\n                            elemStyle.textShadow = textShadow;\n                        } else if (toggleTextShadowShim) {\n                            toggleTextShadowShim('');\n                        }\n                    } catch (e) {}\n\n                    // If the bBox is not set, the try-catch block above failed. The other condition\n                    // is for Opera that returns a width of -Infinity on hidden elements.\n                    if (!bBox || bBox.width < 0) {\n                        bBox = { width: 0, height: 0 };\n                    }\n\n\n                // VML Renderer or useHTML within SVG\n                } else {\n\n                    bBox = wrapper.htmlGetBBox();\n\n                }\n\n                // True SVG elements as well as HTML elements in modern browsers using the .useHTML option\n                // need to compensated for rotation\n                if (renderer.isSVG) {\n                    width = bBox.width;\n                    height = bBox.height;\n\n                    // Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669, #2568)\n                    if (isMS && styles && styles.fontSize === '11px' && height.toPrecision(3) === '16.9') {\n                        bBox.height = height = 14;\n                    }\n\n                    // Adjust for rotated text\n                    if (rotation) {\n                        bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));\n                        bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));\n                    }\n                }\n\n                // Cache it\n                if (cacheKey) {\n\n                    // Rotate (#4681)\n                    while (cacheKeys.length > 250) {\n                        delete cache[cacheKeys.shift()];\n                    }\n\n                    if (!cache[cacheKey]) {\n                        cacheKeys.push(cacheKey);\n                    }\n                    cache[cacheKey] = bBox;\n                }\n            }\n            return bBox;\n        },\n\n        /**\n         * Show the element\n         */\n        show: function (inherit) {\n            return this.attr({ visibility: inherit ? 'inherit' : VISIBLE });\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            return this.attr({ visibility: HIDDEN });\n        },\n\n        fadeOut: function (duration) {\n            var elemWrapper = this;\n            elemWrapper.animate({\n                opacity: 0\n            }, {\n                duration: duration || 150,\n                complete: function () {\n                    elemWrapper.attr({ y: -9999 }); // #3088, assuming we're only using this for tooltips\n                }\n            });\n        },\n\n        /**\n         * Add the element\n         * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined\n         *    to append the element to the renderer.box.\n         */\n        add: function (parent) {\n\n            var renderer = this.renderer,\n                element = this.element,\n                inserted;\n\n            if (parent) {\n                this.parentGroup = parent;\n            }\n\n            // mark as inverted\n            this.parentInverted = parent && parent.inverted;\n\n            // build formatted text\n            if (this.textStr !== undefined) {\n                renderer.buildText(this);\n            }\n\n            // Mark as added\n            this.added = true;\n\n            // If we're adding to renderer root, or other elements in the group\n            // have a z index, we need to handle it\n            if (!parent || parent.handleZ || this.zIndex) {\n                inserted = this.zIndexSetter();\n            }\n\n            // If zIndex is not handled, append at the end\n            if (!inserted) {\n                (parent ? parent.element : renderer.box).appendChild(element);\n            }\n\n            // fire an event for internal hooks\n            if (this.onAdd) {\n                this.onAdd();\n            }\n\n            return this;\n        },\n\n        /**\n         * Removes a child either by removeChild or move to garbageBin.\n         * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n         */\n        safeRemoveChild: function (element) {\n            var parentNode = element.parentNode;\n            if (parentNode) {\n                parentNode.removeChild(element);\n            }\n        },\n\n        /**\n         * Destroy the element and element wrapper\n         */\n        destroy: function () {\n            var wrapper = this,\n                element = wrapper.element || {},\n                shadows = wrapper.shadows,\n                parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,\n                grandParent,\n                key,\n                i;\n\n            // remove events\n            element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;\n            stop(wrapper); // stop running animations\n\n            if (wrapper.clipPath) {\n                wrapper.clipPath = wrapper.clipPath.destroy();\n            }\n\n            // Destroy stops in case this is a gradient object\n            if (wrapper.stops) {\n                for (i = 0; i < wrapper.stops.length; i++) {\n                    wrapper.stops[i] = wrapper.stops[i].destroy();\n                }\n                wrapper.stops = null;\n            }\n\n            // remove element\n            wrapper.safeRemoveChild(element);\n\n            // destroy shadows\n            if (shadows) {\n                each(shadows, function (shadow) {\n                    wrapper.safeRemoveChild(shadow);\n                });\n            }\n\n            // In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).\n            while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {\n                grandParent = parentToClean.parentGroup;\n                wrapper.safeRemoveChild(parentToClean.div);\n                delete parentToClean.div;\n                parentToClean = grandParent;\n            }\n\n            // remove from alignObjects\n            if (wrapper.alignTo) {\n                erase(wrapper.renderer.alignedObjects, wrapper);\n            }\n\n            for (key in wrapper) {\n                delete wrapper[key];\n            }\n\n            return null;\n        },\n\n        /**\n         * Add a shadow to the element. Must be done after the element is added to the DOM\n         * @param {Boolean|Object} shadowOptions\n         */\n        shadow: function (shadowOptions, group, cutOff) {\n            var shadows = [],\n                i,\n                shadow,\n                element = this.element,\n                strokeWidth,\n                shadowWidth,\n                shadowElementOpacity,\n\n                // compensate for inverted plot area\n                transform;\n\n\n            if (shadowOptions) {\n                shadowWidth = pick(shadowOptions.width, 3);\n                shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n                transform = this.parentInverted ?\n                        '(-1,-1)' :\n                        '(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';\n                for (i = 1; i <= shadowWidth; i++) {\n                    shadow = element.cloneNode(0);\n                    strokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n                    attr(shadow, {\n                        'isShadow': 'true',\n                        'stroke': shadowOptions.color || 'black',\n                        'stroke-opacity': shadowElementOpacity * i,\n                        'stroke-width': strokeWidth,\n                        'transform': 'translate' + transform,\n                        'fill': NONE\n                    });\n                    if (cutOff) {\n                        attr(shadow, 'height', mathMax(attr(shadow, 'height') - strokeWidth, 0));\n                        shadow.cutHeight = strokeWidth;\n                    }\n\n                    if (group) {\n                        group.element.appendChild(shadow);\n                    } else {\n                        element.parentNode.insertBefore(shadow, element);\n                    }\n\n                    shadows.push(shadow);\n                }\n\n                this.shadows = shadows;\n            }\n            return this;\n\n        },\n\n        xGetter: function (key) {\n            if (this.element.nodeName === 'circle') {\n                key = { x: 'cx', y: 'cy' }[key] || key;\n            }\n            return this._defaultGetter(key);\n        },\n\n        /**\n         * Get the current value of an attribute or pseudo attribute, used mainly\n         * for animation.\n         */\n        _defaultGetter: function (key) {\n            var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);\n\n            if (/^[\\-0-9\\.]+$/.test(ret)) { // is numerical\n                ret = parseFloat(ret);\n            }\n            return ret;\n        },\n\n\n        dSetter: function (value, key, element) {\n            if (value && value.join) { // join path\n                value = value.join(' ');\n            }\n            if (/(NaN| {2}|^$)/.test(value)) {\n                value = 'M 0 0';\n            }\n            element.setAttribute(key, value);\n\n            this[key] = value;\n        },\n        dashstyleSetter: function (value) {\n            var i;\n            value = value && value.toLowerCase();\n            if (value) {\n                value = value\n                    .replace('shortdashdotdot', '3,1,1,1,1,1,')\n                    .replace('shortdashdot', '3,1,1,1')\n                    .replace('shortdot', '1,1,')\n                    .replace('shortdash', '3,1,')\n                    .replace('longdash', '8,3,')\n                    .replace(/dot/g, '1,3,')\n                    .replace('dash', '4,3,')\n                    .replace(/,$/, '')\n                    .split(','); // ending comma\n\n                i = value.length;\n                while (i--) {\n                    value[i] = pInt(value[i]) * this['stroke-width'];\n                }\n                value = value.join(',')\n                    .replace('NaN', 'none'); // #3226\n                this.element.setAttribute('stroke-dasharray', value);\n            }\n        },\n        alignSetter: function (value) {\n            this.element.setAttribute('text-anchor', { left: 'start', center: 'middle', right: 'end' }[value]);\n        },\n        opacitySetter: function (value, key, element) {\n            this[key] = value;\n            element.setAttribute(key, value);\n        },\n        titleSetter: function (value) {\n            var titleNode = this.element.getElementsByTagName('title')[0];\n            if (!titleNode) {\n                titleNode = doc.createElementNS(SVG_NS, 'title');\n                this.element.appendChild(titleNode);\n            }\n            titleNode.appendChild(\n                doc.createTextNode(\n                    (String(pick(value), '')).replace(/<[^>]*>/g, '') // #3276, #3895\n                )\n            );\n        },\n        textSetter: function (value) {\n            if (value !== this.textStr) {\n                // Delete bBox memo when the text changes\n                delete this.bBox;\n\n                this.textStr = value;\n                if (this.added) {\n                    this.renderer.buildText(this);\n                }\n            }\n        },\n        fillSetter: function (value, key, element) {\n            if (typeof value === 'string') {\n                element.setAttribute(key, value);\n            } else if (value) {\n                this.colorGradient(value, key, element);\n            }\n        },\n        visibilitySetter: function (value, key, element) {\n            // IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881, #3909)\n            if (value === 'inherit') {\n                element.removeAttribute(key);\n            } else {\n                element.setAttribute(key, value);\n            }\n        },\n        zIndexSetter: function (value, key) {\n            var renderer = this.renderer,\n                parentGroup = this.parentGroup,\n                parentWrapper = parentGroup || renderer,\n                parentNode = parentWrapper.element || renderer.box,\n                childNodes,\n                otherElement,\n                otherZIndex,\n                element = this.element,\n                inserted,\n                run = this.added,\n                i;\n\n            if (defined(value)) {\n                element.setAttribute(key, value); // So we can read it for other elements in the group\n                value = +value;\n                if (this[key] === value) { // Only update when needed (#3865)\n                    run = false;\n                }\n                this[key] = value;\n            }\n\n            // Insert according to this and other elements' zIndex. Before .add() is called,\n            // nothing is done. Then on add, or by later calls to zIndexSetter, the node\n            // is placed on the right place in the DOM.\n            if (run) {\n                value = this.zIndex;\n\n                if (value && parentGroup) {\n                    parentGroup.handleZ = true;\n                }\n\n                childNodes = parentNode.childNodes;\n                for (i = 0; i < childNodes.length && !inserted; i++) {\n                    otherElement = childNodes[i];\n                    otherZIndex = attr(otherElement, 'zIndex');\n                    if (otherElement !== element && (\n                            // Insert before the first element with a higher zIndex\n                            pInt(otherZIndex) > value ||\n                            // If no zIndex given, insert before the first element with a zIndex\n                            (!defined(value) && defined(otherZIndex))\n\n                        )) {\n                        parentNode.insertBefore(element, otherElement);\n                        inserted = true;\n                    }\n                }\n                if (!inserted) {\n                    parentNode.appendChild(element);\n                }\n            }\n            return inserted;\n        },\n        _defaultSetter: function (value, key, element) {\n            element.setAttribute(key, value);\n        }\n    };\n\n    // Some shared setters and getters\n    SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;\n    SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter =\n            SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter =\n            SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function (value, key) {\n                this[key] = value;\n                this.doTransform = true;\n            };\n\n    // WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the\n    // stroke attribute altogether. #1270, #1369, #3065, #3072.\n    SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function (value, key, element) {\n        this[key] = value;\n        // Only apply the stroke attribute if the stroke width is defined and larger than 0\n        if (this.stroke && this['stroke-width']) {\n            this.strokeWidth = this['stroke-width'];\n            SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden\n            element.setAttribute('stroke-width', this['stroke-width']);\n            this.hasStroke = true;\n        } else if (key === 'stroke-width' && value === 0 && this.hasStroke) {\n            element.removeAttribute('stroke');\n            this.hasStroke = false;\n        }\n    };\n\n\n    /**\n     * The default SVG renderer\n     */\n    var SVGRenderer = function () {\n        this.init.apply(this, arguments);\n    };\n    SVGRenderer.prototype = {\n        Element: SVGElement,\n\n        /**\n         * Initialize the SVGRenderer\n         * @param {Object} container\n         * @param {Number} width\n         * @param {Number} height\n         * @param {Boolean} forExport\n         */\n        init: function (container, width, height, style, forExport, allowHTML) {\n            var renderer = this,\n                boxWrapper,\n                element,\n                desc;\n\n            boxWrapper = renderer.createElement('svg')\n                .attr({\n                    version: '1.1'\n                })\n                .css(this.getStyle(style));\n            element = boxWrapper.element;\n            container.appendChild(element);\n\n            // For browsers other than IE, add the namespace attribute (#1978)\n            if (container.innerHTML.indexOf('xmlns') === -1) {\n                attr(element, 'xmlns', SVG_NS);\n            }\n\n            // object properties\n            renderer.isSVG = true;\n            renderer.box = element;\n            renderer.boxWrapper = boxWrapper;\n            renderer.alignedObjects = [];\n\n            // Page url used for internal references. #24, #672, #1070\n            renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?\n                    win.location.href\n                        .replace(/#.*?$/, '') // remove the hash\n                        .replace(/([\\('\\)])/g, '\\\\$1') // escape parantheses and quotes\n                        .replace(/ /g, '%20') : // replace spaces (needed for Safari only)\n                    '';\n\n            // Add description\n            desc = this.createElement('desc').add();\n            desc.element.appendChild(doc.createTextNode('Created with ' + PRODUCT + ' ' + VERSION));\n\n\n            renderer.defs = this.createElement('defs').add();\n            renderer.allowHTML = allowHTML;\n            renderer.forExport = forExport;\n            renderer.gradients = {}; // Object where gradient SvgElements are stored\n            renderer.cache = {}; // Cache for numerical bounding boxes\n            renderer.cacheKeys = [];\n            renderer.imgCount = 0;\n\n            renderer.setSize(width, height, false);\n\n\n\n            // Issue 110 workaround:\n            // In Firefox, if a div is positioned by percentage, its pixel position may land\n            // between pixels. The container itself doesn't display this, but an SVG element\n            // inside this container will be drawn at subpixel precision. In order to draw\n            // sharp lines, this must be compensated for. This doesn't seem to work inside\n            // iframes though (like in jsFiddle).\n            var subPixelFix, rect;\n            if (isFirefox && container.getBoundingClientRect) {\n                renderer.subPixelFix = subPixelFix = function () {\n                    css(container, { left: 0, top: 0 });\n                    rect = container.getBoundingClientRect();\n                    css(container, {\n                        left: (mathCeil(rect.left) - rect.left) + PX,\n                        top: (mathCeil(rect.top) - rect.top) + PX\n                    });\n                };\n\n                // run the fix now\n                subPixelFix();\n\n                // run it on resize\n                addEvent(win, 'resize', subPixelFix);\n            }\n        },\n\n        getStyle: function (style) {\n            this.style = extend({\n                fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif', // default font\n                fontSize: '12px'\n            }, style);\n            return this.style;\n        },\n\n        /**\n         * Detect whether the renderer is hidden. This happens when one of the parent elements\n         * has display: none. #608.\n         */\n        isHidden: function () {\n            return !this.boxWrapper.getBBox().width;\n        },\n\n        /**\n         * Destroys the renderer and its allocated members.\n         */\n        destroy: function () {\n            var renderer = this,\n                rendererDefs = renderer.defs;\n            renderer.box = null;\n            renderer.boxWrapper = renderer.boxWrapper.destroy();\n\n            // Call destroy on all gradient elements\n            destroyObjectProperties(renderer.gradients || {});\n            renderer.gradients = null;\n\n            // Defs are null in VMLRenderer\n            // Otherwise, destroy them here.\n            if (rendererDefs) {\n                renderer.defs = rendererDefs.destroy();\n            }\n\n            // Remove sub pixel fix handler\n            // We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed\n            // See issue #982\n            if (renderer.subPixelFix) {\n                removeEvent(win, 'resize', renderer.subPixelFix);\n            }\n\n            renderer.alignedObjects = null;\n\n            return null;\n        },\n\n        /**\n         * Create a wrapper for an SVG element\n         * @param {Object} nodeName\n         */\n        createElement: function (nodeName) {\n            var wrapper = new this.Element();\n            wrapper.init(this, nodeName);\n            return wrapper;\n        },\n\n        /**\n         * Dummy function for use in canvas renderer\n         */\n        draw: function () {},\n\n        /**\n         * Get converted radial gradient attributes\n         */\n        getRadialAttr: function (radialReference, gradAttr) {\n            return {\n                cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],\n                cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],\n                r: gradAttr.r * radialReference[2]\n            };\n        },\n\n        /**\n         * Parse a simple HTML string into SVG tspans\n         *\n         * @param {Object} textNode The parent text SVG node\n         */\n        buildText: function (wrapper) {\n            var textNode = wrapper.element,\n                renderer = this,\n                forExport = renderer.forExport,\n                textStr = pick(wrapper.textStr, '').toString(),\n                hasMarkup = textStr.indexOf('<') !== -1,\n                lines,\n                childNodes = textNode.childNodes,\n                styleRegex,\n                hrefRegex,\n                parentX = attr(textNode, 'x'),\n                textStyles = wrapper.styles,\n                width = wrapper.textWidth,\n                textLineHeight = textStyles && textStyles.lineHeight,\n                textShadow = textStyles && textStyles.textShadow,\n                ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',\n                i = childNodes.length,\n                tempParent = width && !wrapper.added && this.box,\n                getLineHeight = function (tspan) {\n                    return textLineHeight ?\n                            pInt(textLineHeight) :\n                            renderer.fontMetrics(\n                                /(px|em)$/.test(tspan && tspan.style.fontSize) ?\n                                        tspan.style.fontSize :\n                                        ((textStyles && textStyles.fontSize) || renderer.style.fontSize || 12),\n                                tspan\n                            ).h;\n                },\n                unescapeAngleBrackets = function (inputStr) {\n                    return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');\n                };\n\n            /// remove old text\n            while (i--) {\n                textNode.removeChild(childNodes[i]);\n            }\n\n            // Skip tspans, add text directly to text node. The forceTSpan is a hook\n            // used in text outline hack.\n            if (!hasMarkup && !textShadow && !ellipsis && textStr.indexOf(' ') === -1) {\n                textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));\n\n            // Complex strings, add more logic\n            } else {\n\n                styleRegex = /<.*style=\"([^\"]+)\".*>/;\n                hrefRegex = /<.*href=\"(http[^\"]+)\".*>/;\n\n                if (tempParent) {\n                    tempParent.appendChild(textNode); // attach it to the DOM to read offset width\n                }\n\n                if (hasMarkup) {\n                    lines = textStr\n                        .replace(/<(b|strong)>/g, '<span style=\"font-weight:bold\">')\n                        .replace(/<(i|em)>/g, '<span style=\"font-style:italic\">')\n                        .replace(/<a/g, '<span')\n                        .replace(/<\\/(b|strong|i|em|a)>/g, '</span>')\n                        .split(/<br.*?>/g);\n\n                } else {\n                    lines = [textStr];\n                }\n\n\n                // remove empty line at end\n                if (lines[lines.length - 1] === '') {\n                    lines.pop();\n                }\n\n\n                // build the lines\n                each(lines, function (line, lineNo) {\n                    var spans, spanNo = 0;\n\n                    line = line.replace(/<span/g, '|||<span').replace(/<\\/span>/g, '</span>|||');\n                    spans = line.split('|||');\n\n                    each(spans, function (span) {\n                        if (span !== '' || spans.length === 1) {\n                            var attributes = {},\n                                tspan = doc.createElementNS(SVG_NS, 'tspan'),\n                                spanStyle; // #390\n                            if (styleRegex.test(span)) {\n                                spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');\n                                attr(tspan, 'style', spanStyle);\n                            }\n                            if (hrefRegex.test(span) && !forExport) { // Not for export - #1529\n                                attr(tspan, 'onclick', 'location.href=\\\"' + span.match(hrefRegex)[1] + '\\\"');\n                                css(tspan, { cursor: 'pointer' });\n                            }\n\n                            span = unescapeAngleBrackets(span.replace(/<(.|\\n)*?>/g, '') || ' ');\n\n                            // Nested tags aren't supported, and cause crash in Safari (#1596)\n                            if (span !== ' ') {\n\n                                // add the text node\n                                tspan.appendChild(doc.createTextNode(span));\n\n                                if (!spanNo) { // first span in a line, align it to the left\n                                    if (lineNo && parentX !== null) {\n                                        attributes.x = parentX;\n                                    }\n                                } else {\n                                    attributes.dx = 0; // #16\n                                }\n\n                                // add attributes\n                                attr(tspan, attributes);\n\n                                // Append it\n                                textNode.appendChild(tspan);\n\n                                // first span on subsequent line, add the line height\n                                if (!spanNo && lineNo) {\n\n                                    // allow getting the right offset height in exporting in IE\n                                    if (!hasSVG && forExport) {\n                                        css(tspan, { display: 'block' });\n                                    }\n\n                                    // Set the line height based on the font size of either\n                                    // the text element or the tspan element\n                                    attr(\n                                        tspan,\n                                        'dy',\n                                        getLineHeight(tspan)\n                                    );\n                                }\n\n                                /*if (width) {\n                                    renderer.breakText(wrapper, width);\n                                }*/\n\n                                // Check width and apply soft breaks or ellipsis\n                                if (width) {\n                                    var words = span.replace(/([^\\^])-/g, '$1- ').split(' '), // #1273\n                                        hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && textStyles.whiteSpace !== 'nowrap'),\n                                        tooLong,\n                                        wasTooLong,\n                                        actualWidth,\n                                        rest = [],\n                                        dy = getLineHeight(tspan),\n                                        softLineNo = 1,\n                                        rotation = wrapper.rotation,\n                                        wordStr = span, // for ellipsis\n                                        cursor = wordStr.length, // binary search cursor\n                                        bBox;\n\n                                    while ((hasWhiteSpace || ellipsis) && (words.length || rest.length)) {\n                                        wrapper.rotation = 0; // discard rotation when computing box\n                                        bBox = wrapper.getBBox(true);\n                                        actualWidth = bBox.width;\n\n                                        // Old IE cannot measure the actualWidth for SVG elements (#2314)\n                                        if (!hasSVG && renderer.forExport) {\n                                            actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);\n                                        }\n\n                                        tooLong = actualWidth > width;\n\n                                        // For ellipsis, do a binary search for the correct string length\n                                        if (wasTooLong === undefined) {\n                                            wasTooLong = tooLong; // First time\n                                        }\n                                        if (ellipsis && wasTooLong) {\n                                            cursor /= 2;\n\n                                            if (wordStr === '' || (!tooLong && cursor < 0.5)) {\n                                                words = []; // All ok, break out\n                                            } else {\n                                                if (tooLong) {\n                                                    wasTooLong = true;\n                                                }\n                                                wordStr = span.substring(0, wordStr.length + (tooLong ? -1 : 1) * mathCeil(cursor));\n                                                words = [wordStr + (width > 3 ? '\\u2026' : '')];\n                                                tspan.removeChild(tspan.firstChild);\n                                            }\n\n                                        // Looping down, this is the first word sequence that is not too long,\n                                        // so we can move on to build the next line.\n                                        } else if (!tooLong || words.length === 1) {\n                                            words = rest;\n                                            rest = [];\n\n                                            if (words.length) {\n                                                softLineNo++;\n\n                                                tspan = doc.createElementNS(SVG_NS, 'tspan');\n                                                attr(tspan, {\n                                                    dy: dy,\n                                                    x: parentX\n                                                });\n                                                if (spanStyle) { // #390\n                                                    attr(tspan, 'style', spanStyle);\n                                                }\n                                                textNode.appendChild(tspan);\n                                            }\n                                            if (actualWidth > width) { // a single word is pressing it out\n                                                width = actualWidth;\n                                            }\n                                        } else { // append to existing line tspan\n                                            tspan.removeChild(tspan.firstChild);\n                                            rest.unshift(words.pop());\n                                        }\n                                        if (words.length) {\n                                            tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));\n                                        }\n                                    }\n                                    if (wasTooLong) {\n                                        wrapper.attr('title', wrapper.textStr);\n                                    }\n                                    wrapper.rotation = rotation;\n                                }\n\n                                spanNo++;\n                            }\n                        }\n                    });\n                });\n                if (tempParent) {\n                    tempParent.removeChild(textNode); // attach it to the DOM to read offset width\n                }\n\n                // Apply the text shadow\n                if (textShadow && wrapper.applyTextShadow) {\n                    wrapper.applyTextShadow(textShadow);\n                }\n            }\n        },\n\n\n\n        /*\n        breakText: function (wrapper, width) {\n            var bBox = wrapper.getBBox(),\n                node = wrapper.element,\n                textLength = node.textContent.length,\n                pos = mathRound(width * textLength / bBox.width), // try this position first, based on average character width\n                increment = 0,\n                finalPos;\n\n            if (bBox.width > width) {\n                while (finalPos === undefined) {\n                    textLength = node.getSubStringLength(0, pos);\n\n                    if (textLength <= width) {\n                        if (increment === -1) {\n                            finalPos = pos;\n                        } else {\n                            increment = 1;\n                        }\n                    } else {\n                        if (increment === 1) {\n                            finalPos = pos - 1;\n                        } else {\n                            increment = -1;\n                        }\n                    }\n                    pos += increment;\n                }\n            }\n            console.log(finalPos, node.getSubStringLength(0, finalPos))\n        },\n        */\n\n        /**\n         * Returns white for dark colors and black for bright colors\n         */\n        getContrast: function (color) {\n            color = Color(color).rgba;\n            return color[0] + color[1] + color[2] > 384 ? '#000000' : '#FFFFFF';\n        },\n\n        /**\n         * Create a button with preset states\n         * @param {String} text\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Function} callback\n         * @param {Object} normalState\n         * @param {Object} hoverState\n         * @param {Object} pressedState\n         */\n        button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {\n            var label = this.label(text, x, y, shape, null, null, null, null, 'button'),\n                curState = 0,\n                stateOptions,\n                stateStyle,\n                normalStyle,\n                hoverStyle,\n                pressedStyle,\n                disabledStyle,\n                verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };\n\n            // Normal state - prepare the attributes\n            normalState = merge({\n                'stroke-width': 1,\n                stroke: '#CCCCCC',\n                fill: {\n                    linearGradient: verticalGradient,\n                    stops: [\n                        [0, '#FEFEFE'],\n                        [1, '#F6F6F6']\n                    ]\n                },\n                r: 2,\n                padding: 5,\n                style: {\n                    color: 'black'\n                }\n            }, normalState);\n            normalStyle = normalState.style;\n            delete normalState.style;\n\n            // Hover state\n            hoverState = merge(normalState, {\n                stroke: '#68A',\n                fill: {\n                    linearGradient: verticalGradient,\n                    stops: [\n                        [0, '#FFF'],\n                        [1, '#ACF']\n                    ]\n                }\n            }, hoverState);\n            hoverStyle = hoverState.style;\n            delete hoverState.style;\n\n            // Pressed state\n            pressedState = merge(normalState, {\n                stroke: '#68A',\n                fill: {\n                    linearGradient: verticalGradient,\n                    stops: [\n                        [0, '#9BD'],\n                        [1, '#CDF']\n                    ]\n                }\n            }, pressedState);\n            pressedStyle = pressedState.style;\n            delete pressedState.style;\n\n            // Disabled state\n            disabledState = merge(normalState, {\n                style: {\n                    color: '#CCC'\n                }\n            }, disabledState);\n            disabledStyle = disabledState.style;\n            delete disabledState.style;\n\n            // Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).\n            addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function () {\n                if (curState !== 3) {\n                    label.attr(hoverState)\n                        .css(hoverStyle);\n                }\n            });\n            addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function () {\n                if (curState !== 3) {\n                    stateOptions = [normalState, hoverState, pressedState][curState];\n                    stateStyle = [normalStyle, hoverStyle, pressedStyle][curState];\n                    label.attr(stateOptions)\n                        .css(stateStyle);\n                }\n            });\n\n            label.setState = function (state) {\n                label.state = curState = state;\n                if (!state) {\n                    label.attr(normalState)\n                        .css(normalStyle);\n                } else if (state === 2) {\n                    label.attr(pressedState)\n                        .css(pressedStyle);\n                } else if (state === 3) {\n                    label.attr(disabledState)\n                        .css(disabledStyle);\n                }\n            };\n\n            return label\n                .on('click', function (e) {\n                    if (curState !== 3) {\n                        callback.call(label, e);\n                    }\n                })\n                .attr(normalState)\n                .css(extend({ cursor: 'default' }, normalStyle));\n        },\n\n        /**\n         * Make a straight line crisper by not spilling out to neighbour pixels\n         * @param {Array} points\n         * @param {Number} width\n         */\n        crispLine: function (points, width) {\n            // points format: [M, 0, 0, L, 100, 0]\n            // normalize to a crisp line\n            if (points[1] === points[4]) {\n                // Substract due to #1129. Now bottom and left axis gridlines behave the same.\n                points[1] = points[4] = mathRound(points[1]) - (width % 2 / 2);\n            }\n            if (points[2] === points[5]) {\n                points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);\n            }\n            return points;\n        },\n\n\n        /**\n         * Draw a path\n         * @param {Array} path An SVG path in array form\n         */\n        path: function (path) {\n            var attr = {\n                fill: NONE\n            };\n            if (isArray(path)) {\n                attr.d = path;\n            } else if (isObject(path)) { // attributes\n                extend(attr, path);\n            }\n            return this.createElement('path').attr(attr);\n        },\n\n        /**\n         * Draw and return an SVG circle\n         * @param {Number} x The x position\n         * @param {Number} y The y position\n         * @param {Number} r The radius\n         */\n        circle: function (x, y, r) {\n            var attr = isObject(x) ? x : { x: x, y: y, r: r },\n                wrapper = this.createElement('circle');\n\n            // Setting x or y translates to cx and cy\n            wrapper.xSetter = wrapper.ySetter = function (value, key, element) {\n                element.setAttribute('c' + key, value);\n            };\n\n            return wrapper.attr(attr);\n        },\n\n        /**\n         * Draw and return an arc\n         * @param {Number} x X position\n         * @param {Number} y Y position\n         * @param {Number} r Radius\n         * @param {Number} innerR Inner radius like used in donut charts\n         * @param {Number} start Starting angle\n         * @param {Number} end Ending angle\n         */\n        arc: function (x, y, r, innerR, start, end) {\n            var arc;\n\n            if (isObject(x)) {\n                y = x.y;\n                r = x.r;\n                innerR = x.innerR;\n                start = x.start;\n                end = x.end;\n                x = x.x;\n            }\n\n            // Arcs are defined as symbols for the ability to set\n            // attributes in attr and animate\n            arc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {\n                innerR: innerR || 0,\n                start: start || 0,\n                end: end || 0\n            });\n            arc.r = r; // #959\n            return arc;\n        },\n\n        /**\n         * Draw and return a rectangle\n         * @param {Number} x Left position\n         * @param {Number} y Top position\n         * @param {Number} width\n         * @param {Number} height\n         * @param {Number} r Border corner radius\n         * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing\n         */\n        rect: function (x, y, width, height, r, strokeWidth) {\n\n            r = isObject(x) ? x.r : r;\n\n            var wrapper = this.createElement('rect'),\n                attribs = isObject(x) ? x : x === UNDEFINED ? {} : {\n                    x: x,\n                    y: y,\n                    width: mathMax(width, 0),\n                    height: mathMax(height, 0)\n                };\n\n            if (strokeWidth !== UNDEFINED) {\n                wrapper.strokeWidth = strokeWidth;\n                attribs = wrapper.crisp(attribs);\n            }\n\n            if (r) {\n                attribs.r = r;\n            }\n\n            wrapper.rSetter = function (value, key, element) {\n                attr(element, {\n                    rx: value,\n                    ry: value\n                });\n            };\n\n            return wrapper.attr(attribs);\n        },\n\n        /**\n         * Resize the box and re-align all aligned elements\n         * @param {Object} width\n         * @param {Object} height\n         * @param {Boolean} animate\n         *\n         */\n        setSize: function (width, height, animate) {\n            var renderer = this,\n                alignedObjects = renderer.alignedObjects,\n                i = alignedObjects.length;\n\n            renderer.width = width;\n            renderer.height = height;\n\n            renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({\n                width: width,\n                height: height\n            });\n\n            while (i--) {\n                alignedObjects[i].align();\n            }\n        },\n\n        /**\n         * Create a group\n         * @param {String} name The group will be given a class name of 'highcharts-{name}'.\n         *     This can be used for styling and scripting.\n         */\n        g: function (name) {\n            var elem = this.createElement('g');\n            return defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;\n        },\n\n        /**\n         * Display an image\n         * @param {String} src\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Number} width\n         * @param {Number} height\n         */\n        image: function (src, x, y, width, height) {\n            var attribs = {\n                    preserveAspectRatio: NONE\n                },\n                elemWrapper;\n\n            // optional properties\n            if (arguments.length > 1) {\n                extend(attribs, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }\n\n            elemWrapper = this.createElement('image').attr(attribs);\n\n            // set the href in the xlink namespace\n            if (elemWrapper.element.setAttributeNS) {\n                elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',\n                    'href', src);\n            } else {\n                // could be exporting in IE\n                // using href throws \"not supported\" in ie7 and under, requries regex shim to fix later\n                elemWrapper.element.setAttribute('hc-svg-href', src);\n            }\n            return elemWrapper;\n        },\n\n        /**\n         * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.\n         *\n         * @param {Object} symbol\n         * @param {Object} x\n         * @param {Object} y\n         * @param {Object} radius\n         * @param {Object} options\n         */\n        symbol: function (symbol, x, y, width, height, options) {\n\n            var ren = this,\n                obj,\n\n                // get the symbol definition function\n                symbolFn = this.symbols[symbol],\n\n                // check if there's a path defined for this symbol\n                path = symbolFn && symbolFn(\n                    mathRound(x),\n                    mathRound(y),\n                    width,\n                    height,\n                    options\n                ),\n\n                imageRegex = /^url\\((.*?)\\)$/,\n                imageSrc,\n                imageSize,\n                centerImage;\n\n            if (path) {\n\n                obj = this.path(path);\n                // expando properties for use in animate and attr\n                extend(obj, {\n                    symbolName: symbol,\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n                if (options) {\n                    extend(obj, options);\n                }\n\n\n            // image symbols\n            } else if (imageRegex.test(symbol)) {\n\n                // On image load, set the size and position\n                centerImage = function (img, size) {\n                    if (img.element) { // it may be destroyed in the meantime (#1390)\n                        img.attr({\n                            width: size[0],\n                            height: size[1]\n                        });\n\n                        if (!img.alignByTranslate) { // #185\n                            img.translate(\n                                mathRound((width - size[0]) / 2), // #1378\n                                mathRound((height - size[1]) / 2)\n                            );\n                        }\n                    }\n                };\n\n                imageSrc = symbol.match(imageRegex)[1];\n                imageSize = symbolSizes[imageSrc] || (options && options.width && options.height && [options.width, options.height]);\n\n                // Ireate the image synchronously, add attribs async\n                obj = this.image(imageSrc)\n                    .attr({\n                        x: x,\n                        y: y\n                    });\n                obj.isImg = true;\n\n                if (imageSize) {\n                    centerImage(obj, imageSize);\n                } else {\n                    // Initialize image to be 0 size so export will still function if there's no cached sizes.\n                    obj.attr({ width: 0, height: 0 });\n\n                    // Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,\n                    // the created element must be assigned to a variable in order to load (#292).\n                    createElement('img', {\n                        onload: function () {\n\n                            // Special case for SVGs on IE11, the width is not accessible until the image is\n                            // part of the DOM (#2854).\n                            if (this.width === 0) {\n                                css(this, {\n                                    position: ABSOLUTE,\n                                    top: '-999em'\n                                });\n                                doc.body.appendChild(this);\n                            }\n\n                            // Center the image\n                            centerImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);\n\n                            // Clean up after #2854 workaround.\n                            if (this.parentNode) {\n                                this.parentNode.removeChild(this);\n                            }\n\n                            // Fire the load event when all external images are loaded\n                            ren.imgCount--;\n                            if (!ren.imgCount) {\n                                charts[ren.chartIndex].onload();\n                            }\n                        },\n                        src: imageSrc\n                    });\n                }\n                this.imgCount++;\n            }\n\n            return obj;\n        },\n\n        /**\n         * An extendable collection of functions for defining symbol paths.\n         */\n        symbols: {\n            'circle': function (x, y, w, h) {\n                var cpw = 0.166 * w;\n                return [\n                    M, x + w / 2, y,\n                    'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,\n                    'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,\n                    'Z'\n                ];\n            },\n\n            'square': function (x, y, w, h) {\n                return [\n                    M, x, y,\n                    L, x + w, y,\n                    x + w, y + h,\n                    x, y + h,\n                    'Z'\n                ];\n            },\n\n            'triangle': function (x, y, w, h) {\n                return [\n                    M, x + w / 2, y,\n                    L, x + w, y + h,\n                    x, y + h,\n                    'Z'\n                ];\n            },\n\n            'triangle-down': function (x, y, w, h) {\n                return [\n                    M, x, y,\n                    L, x + w, y,\n                    x + w / 2, y + h,\n                    'Z'\n                ];\n            },\n            'diamond': function (x, y, w, h) {\n                return [\n                    M, x + w / 2, y,\n                    L, x + w, y + h / 2,\n                    x + w / 2, y + h,\n                    x, y + h / 2,\n                    'Z'\n                ];\n            },\n            'arc': function (x, y, w, h, options) {\n                var start = options.start,\n                    radius = options.r || w || h,\n                    end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)\n                    innerRadius = options.innerR,\n                    open = options.open,\n                    cosStart = mathCos(start),\n                    sinStart = mathSin(start),\n                    cosEnd = mathCos(end),\n                    sinEnd = mathSin(end),\n                    longArc = options.end - start < mathPI ? 0 : 1;\n\n                return [\n                    M,\n                    x + radius * cosStart,\n                    y + radius * sinStart,\n                    'A', // arcTo\n                    radius, // x radius\n                    radius, // y radius\n                    0, // slanting\n                    longArc, // long or short arc\n                    1, // clockwise\n                    x + radius * cosEnd,\n                    y + radius * sinEnd,\n                    open ? M : L,\n                    x + innerRadius * cosEnd,\n                    y + innerRadius * sinEnd,\n                    'A', // arcTo\n                    innerRadius, // x radius\n                    innerRadius, // y radius\n                    0, // slanting\n                    longArc, // long or short arc\n                    0, // clockwise\n                    x + innerRadius * cosStart,\n                    y + innerRadius * sinStart,\n\n                    open ? '' : 'Z' // close\n                ];\n            },\n\n            /**\n             * Callout shape used for default tooltips, also used for rounded rectangles in VML\n             */\n            callout: function (x, y, w, h, options) {\n                var arrowLength = 6,\n                    halfDistance = 6,\n                    r = mathMin((options && options.r) || 0, w, h),\n                    safeDistance = r + halfDistance,\n                    anchorX = options && options.anchorX,\n                    anchorY = options && options.anchorY,\n                    path;\n\n                path = [\n                    'M', x + r, y,\n                    'L', x + w - r, y, // top side\n                    'C', x + w, y, x + w, y, x + w, y + r, // top-right corner\n                    'L', x + w, y + h - r, // right side\n                    'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner\n                    'L', x + r, y + h, // bottom side\n                    'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner\n                    'L', x, y + r, // left side\n                    'C', x, y, x, y, x + r, y // top-right corner\n                ];\n\n                if (anchorX && anchorX > w && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace right side\n                    path.splice(13, 3,\n                        'L', x + w, anchorY - halfDistance,\n                        x + w + arrowLength, anchorY,\n                        x + w, anchorY + halfDistance,\n                        x + w, y + h - r\n                        );\n                } else if (anchorX && anchorX < 0 && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace left side\n                    path.splice(33, 3,\n                        'L', x, anchorY + halfDistance,\n                        x - arrowLength, anchorY,\n                        x, anchorY - halfDistance,\n                        x, y + r\n                        );\n                } else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom\n                    path.splice(23, 3,\n                        'L', anchorX + halfDistance, y + h,\n                        anchorX, y + h + arrowLength,\n                        anchorX - halfDistance, y + h,\n                        x + r, y + h\n                        );\n                } else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top\n                    path.splice(3, 3,\n                        'L', anchorX - halfDistance, y,\n                        anchorX, y - arrowLength,\n                        anchorX + halfDistance, y,\n                        w - r, y\n                        );\n                }\n                return path;\n            }\n        },\n\n        /**\n         * Define a clipping rectangle\n         * @param {String} id\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Number} width\n         * @param {Number} height\n         */\n        clipRect: function (x, y, width, height) {\n            var wrapper,\n                id = PREFIX + idCounter++,\n\n                clipPath = this.createElement('clipPath').attr({\n                    id: id\n                }).add(this.defs);\n\n            wrapper = this.rect(x, y, width, height, 0).add(clipPath);\n            wrapper.id = id;\n            wrapper.clipPath = clipPath;\n            wrapper.count = 0;\n\n            return wrapper;\n        },\n\n\n\n\n\n        /**\n         * Add text to the SVG object\n         * @param {String} str\n         * @param {Number} x Left position\n         * @param {Number} y Top position\n         * @param {Boolean} useHTML Use HTML to render the text\n         */\n        text: function (str, x, y, useHTML) {\n\n            // declare variables\n            var renderer = this,\n                fakeSVG = useCanVG || (!hasSVG && renderer.forExport),\n                wrapper,\n                attr = {};\n\n            if (useHTML && (renderer.allowHTML || !renderer.forExport)) {\n                return renderer.html(str, x, y);\n            }\n\n            attr.x = Math.round(x || 0); // X is always needed for line-wrap logic\n            if (y) {\n                attr.y = Math.round(y);\n            }\n            if (str || str === 0) {\n                attr.text = str;\n            }\n\n            wrapper = renderer.createElement('text')\n                .attr(attr);\n\n            // Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)\n            if (fakeSVG) {\n                wrapper.css({\n                    position: ABSOLUTE\n                });\n            }\n\n            if (!useHTML) {\n                wrapper.xSetter = function (value, key, element) {\n                    var tspans = element.getElementsByTagName('tspan'),\n                        tspan,\n                        parentVal = element.getAttribute(key),\n                        i;\n                    for (i = 0; i < tspans.length; i++) {\n                        tspan = tspans[i];\n                        // If the x values are equal, the tspan represents a linebreak\n                        if (tspan.getAttribute(key) === parentVal) {\n                            tspan.setAttribute(key, value);\n                        }\n                    }\n                    element.setAttribute(key, value);\n                };\n            }\n\n            return wrapper;\n        },\n\n        /**\n         * Utility to return the baseline offset and total line height from the font size\n         */\n        fontMetrics: function (fontSize, elem) {\n            var lineHeight,\n                baseline,\n                style;\n\n            fontSize = fontSize || this.style.fontSize;\n            if (!fontSize && elem && win.getComputedStyle) {\n                elem = elem.element || elem; // SVGElement\n                style = win.getComputedStyle(elem, '');\n                fontSize = style && style.fontSize; // #4309, the style doesn't exist inside a hidden iframe in Firefox\n            }\n            fontSize = /px/.test(fontSize) ? pInt(fontSize) : /em/.test(fontSize) ? parseFloat(fontSize) * 12 : 12;\n\n            // Empirical values found by comparing font size and bounding box height.\n            // Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/\n            lineHeight = fontSize < 24 ? fontSize + 3 : mathRound(fontSize * 1.2);\n            baseline = mathRound(lineHeight * 0.8);\n\n            return {\n                h: lineHeight,\n                b: baseline,\n                f: fontSize\n            };\n        },\n\n        /**\n         * Correct X and Y positioning of a label for rotation (#1764)\n         */\n        rotCorr: function (baseline, rotation, alterY) {\n            var y = baseline;\n            if (rotation && alterY) {\n                y = mathMax(y * mathCos(rotation * deg2rad), 4);\n            }\n            return {\n                x: (-baseline / 3) * mathSin(rotation * deg2rad),\n                y: y\n            };\n        },\n\n        /**\n         * Add a label, a text item that can hold a colored or gradient background\n         * as well as a border and shadow.\n         * @param {string} str\n         * @param {Number} x\n         * @param {Number} y\n         * @param {String} shape\n         * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the\n         *    coordinates it should be pinned to\n         * @param {Number} anchorY\n         * @param {Boolean} baseline Whether to position the label relative to the text baseline,\n         *    like renderer.text, or to the upper border of the rectangle.\n         * @param {String} className Class name for the group\n         */\n        label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {\n\n            var renderer = this,\n                wrapper = renderer.g(className),\n                text = renderer.text('', 0, 0, useHTML)\n                    .attr({\n                        zIndex: 1\n                    }),\n                    //.add(wrapper),\n                box,\n                bBox,\n                alignFactor = 0,\n                padding = 3,\n                paddingLeft = 0,\n                width,\n                height,\n                wrapperX,\n                wrapperY,\n                crispAdjust = 0,\n                deferredAttr = {},\n                baselineOffset,\n                needsBox,\n                updateBoxSize,\n                updateTextPadding,\n                boxAttr;\n\n            /**\n             * This function runs after the label is added to the DOM (when the bounding box is\n             * available), and after the text of the label is updated to detect the new bounding\n             * box and reflect it in the border box.\n             */\n            updateBoxSize = function () {\n                var boxX,\n                    boxY,\n                    style = text.element.style;\n\n                bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && defined(text.textStr) &&\n                    text.getBBox(); //#3295 && 3514 box failure when string equals 0\n                wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;\n                wrapper.height = (height || bBox.height || 0) + 2 * padding;\n\n                // update the label-scoped y offset\n                baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;\n\n\n                if (needsBox) {\n\n                    if (!box) {\n                        // create the border box if it is not already present\n                        boxX = crispAdjust;\n                        boxY = (baseline ? -baselineOffset : 0) + crispAdjust;\n\n                        wrapper.box = box = shape ?\n                                renderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height, deferredAttr) :\n                                renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);\n\n                        if (!box.isImg) { // #4324, fill \"none\" causes it to be ignored by mouse events in IE\n                            box.attr('fill', NONE);\n                        }\n                        box.add(wrapper);\n                    }\n\n                    // apply the box attributes\n                    if (!box.isImg) { // #1630\n                        box.attr(extend({\n                            width: mathRound(wrapper.width),\n                            height: mathRound(wrapper.height)\n                        }, deferredAttr));\n                    }\n                    deferredAttr = null;\n                }\n            };\n\n            /**\n             * This function runs after setting text or padding, but only if padding is changed\n             */\n            updateTextPadding = function () {\n                var styles = wrapper.styles,\n                    textAlign = styles && styles.textAlign,\n                    x = paddingLeft + padding,\n                    y;\n\n                // determin y based on the baseline\n                y = baseline ? 0 : baselineOffset;\n\n                // compensate for alignment\n                if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {\n                    x += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);\n                }\n\n                // update if anything changed\n                if (x !== text.x || y !== text.y) {\n                    text.attr('x', x);\n                    if (y !== UNDEFINED) {\n                        text.attr('y', y);\n                    }\n                }\n\n                // record current values\n                text.x = x;\n                text.y = y;\n            };\n\n            /**\n             * Set a box attribute, or defer it if the box is not yet created\n             * @param {Object} key\n             * @param {Object} value\n             */\n            boxAttr = function (key, value) {\n                if (box) {\n                    box.attr(key, value);\n                } else {\n                    deferredAttr[key] = value;\n                }\n            };\n\n            /**\n             * After the text element is added, get the desired size of the border box\n             * and add it before the text in the DOM.\n             */\n            wrapper.onAdd = function () {\n                text.add(wrapper);\n                wrapper.attr({\n                    text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value\n                    x: x,\n                    y: y\n                });\n\n                if (box && defined(anchorX)) {\n                    wrapper.attr({\n                        anchorX: anchorX,\n                        anchorY: anchorY\n                    });\n                }\n            };\n\n            /*\n             * Add specific attribute setters.\n             */\n\n            // only change local variables\n            wrapper.widthSetter = function (value) {\n                width = value;\n            };\n            wrapper.heightSetter = function (value) {\n                height = value;\n            };\n            wrapper.paddingSetter =  function (value) {\n                if (defined(value) && value !== padding) {\n                    padding = wrapper.padding = value;\n                    updateTextPadding();\n                }\n            };\n            wrapper.paddingLeftSetter =  function (value) {\n                if (defined(value) && value !== paddingLeft) {\n                    paddingLeft = value;\n                    updateTextPadding();\n                }\n            };\n\n\n            // change local variable and prevent setting attribute on the group\n            wrapper.alignSetter = function (value) {\n                value = { left: 0, center: 0.5, right: 1 }[value];\n                if (value !== alignFactor) {\n                    alignFactor = value;\n                    if (bBox) { // Bounding box exists, means we're dynamically changing\n                        wrapper.attr({ x: x });\n                    }\n                }\n            };\n\n            // apply these to the box and the text alike\n            wrapper.textSetter = function (value) {\n                if (value !== UNDEFINED) {\n                    text.textSetter(value);\n                }\n                updateBoxSize();\n                updateTextPadding();\n            };\n\n            // apply these to the box but not to the text\n            wrapper['stroke-widthSetter'] = function (value, key) {\n                if (value) {\n                    needsBox = true;\n                }\n                crispAdjust = value % 2 / 2;\n                boxAttr(key, value);\n            };\n            wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {\n                if (key === 'fill' && value) {\n                    needsBox = true;\n                }\n                boxAttr(key, value);\n            };\n            wrapper.anchorXSetter = function (value, key) {\n                anchorX = value;\n                boxAttr(key, mathRound(value) - crispAdjust - wrapperX);\n            };\n            wrapper.anchorYSetter = function (value, key) {\n                anchorY = value;\n                boxAttr(key, value - wrapperY);\n            };\n\n            // rename attributes\n            wrapper.xSetter = function (value) {\n                wrapper.x = value; // for animation getter\n                if (alignFactor) {\n                    value -= alignFactor * ((width || bBox.width) + 2 * padding);\n                }\n                wrapperX = mathRound(value);\n                wrapper.attr('translateX', wrapperX);\n            };\n            wrapper.ySetter = function (value) {\n                wrapperY = wrapper.y = mathRound(value);\n                wrapper.attr('translateY', wrapperY);\n            };\n\n            // Redirect certain methods to either the box or the text\n            var baseCss = wrapper.css;\n            return extend(wrapper, {\n                /**\n                 * Pick up some properties and apply them to the text instead of the wrapper\n                 */\n                css: function (styles) {\n                    if (styles) {\n                        var textStyles = {};\n                        styles = merge(styles); // create a copy to avoid altering the original object (#537)\n                        each(wrapper.textProps, function (prop) {\n                            if (styles[prop] !== UNDEFINED) {\n                                textStyles[prop] = styles[prop];\n                                delete styles[prop];\n                            }\n                        });\n                        text.css(textStyles);\n                    }\n                    return baseCss.call(wrapper, styles);\n                },\n                /**\n                 * Return the bounding box of the box, not the group\n                 */\n                getBBox: function () {\n                    return {\n                        width: bBox.width + 2 * padding,\n                        height: bBox.height + 2 * padding,\n                        x: bBox.x - padding,\n                        y: bBox.y - padding\n                    };\n                },\n                /**\n                 * Apply the shadow to the box\n                 */\n                shadow: function (b) {\n                    if (box) {\n                        box.shadow(b);\n                    }\n                    return wrapper;\n                },\n                /**\n                 * Destroy and release memory.\n                 */\n                destroy: function () {\n\n                    // Added by button implementation\n                    removeEvent(wrapper.element, 'mouseenter');\n                    removeEvent(wrapper.element, 'mouseleave');\n\n                    if (text) {\n                        text = text.destroy();\n                    }\n                    if (box) {\n                        box = box.destroy();\n                    }\n                    // Call base implementation to destroy the rest\n                    SVGElement.prototype.destroy.call(wrapper);\n\n                    // Release local pointers (#1298)\n                    wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;\n                }\n            });\n        }\n    }; // end SVGRenderer\n\n\n    // general renderer\n    Renderer = SVGRenderer;\n    // extend SvgElement for useHTML option\n    extend(SVGElement.prototype, {\n        /**\n         * Apply CSS to HTML elements. This is used in text within SVG rendering and\n         * by the VML renderer\n         */\n        htmlCss: function (styles) {\n            var wrapper = this,\n                element = wrapper.element,\n                textWidth = styles && element.tagName === 'SPAN' && styles.width;\n\n            if (textWidth) {\n                delete styles.width;\n                wrapper.textWidth = textWidth;\n                wrapper.updateTransform();\n            }\n            if (styles && styles.textOverflow === 'ellipsis') {\n                styles.whiteSpace = 'nowrap';\n                styles.overflow = 'hidden';\n            }\n            wrapper.styles = extend(wrapper.styles, styles);\n            css(wrapper.element, styles);\n\n            return wrapper;\n        },\n\n        /**\n         * VML and useHTML method for calculating the bounding box based on offsets\n         * @param {Boolean} refresh Whether to force a fresh value from the DOM or to\n         * use the cached value\n         *\n         * @return {Object} A hash containing values for x, y, width and height\n         */\n\n        htmlGetBBox: function () {\n            var wrapper = this,\n                element = wrapper.element;\n\n            // faking getBBox in exported SVG in legacy IE\n            // faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)\n            if (element.nodeName === 'text') {\n                element.style.position = ABSOLUTE;\n            }\n\n            return {\n                x: element.offsetLeft,\n                y: element.offsetTop,\n                width: element.offsetWidth,\n                height: element.offsetHeight\n            };\n        },\n\n        /**\n         * VML override private method to update elements based on internal\n         * properties based on SVG transform\n         */\n        htmlUpdateTransform: function () {\n            // aligning non added elements is expensive\n            if (!this.added) {\n                this.alignOnAdd = true;\n                return;\n            }\n\n            var wrapper = this,\n                renderer = wrapper.renderer,\n                elem = wrapper.element,\n                translateX = wrapper.translateX || 0,\n                translateY = wrapper.translateY || 0,\n                x = wrapper.x || 0,\n                y = wrapper.y || 0,\n                align = wrapper.textAlign || 'left',\n                alignCorrection = { left: 0, center: 0.5, right: 1 }[align],\n                shadows = wrapper.shadows,\n                styles = wrapper.styles;\n\n            // apply translate\n            css(elem, {\n                marginLeft: translateX,\n                marginTop: translateY\n            });\n            if (shadows) { // used in labels/tooltip\n                each(shadows, function (shadow) {\n                    css(shadow, {\n                        marginLeft: translateX + 1,\n                        marginTop: translateY + 1\n                    });\n                });\n            }\n\n            // apply inversion\n            if (wrapper.inverted) { // wrapper is a group\n                each(elem.childNodes, function (child) {\n                    renderer.invertChild(child, elem);\n                });\n            }\n\n            if (elem.tagName === 'SPAN') {\n\n                var rotation = wrapper.rotation,\n                    baseline,\n                    textWidth = pInt(wrapper.textWidth),\n                    whiteSpace = styles && styles.whiteSpace,\n                    currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth, wrapper.textAlign].join(',');\n\n                if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed\n\n\n                    baseline = renderer.fontMetrics(elem.style.fontSize).b;\n\n                    // Renderer specific handling of span rotation\n                    if (defined(rotation)) {\n                        wrapper.setSpanRotation(rotation, alignCorrection, baseline);\n                    }\n\n                    // Update textWidth\n                    if (elem.offsetWidth > textWidth && /[ \\-]/.test(elem.textContent || elem.innerText)) { // #983, #1254\n                        css(elem, {\n                            width: textWidth + PX,\n                            display: 'block',\n                            whiteSpace: whiteSpace || 'normal' // #3331\n                        });\n                        wrapper.hasTextWidth = true;\n                    } else if (wrapper.hasTextWidth) { // #4928\n                        css(elem, {\n                            width: '',\n                            display: '',\n                            whiteSpace: whiteSpace || 'nowrap'\n                        });\n                        wrapper.hasTextWidth = false;\n                    }\n\n                    wrapper.getSpanCorrection(wrapper.hasTextWidth ? textWidth : elem.offsetWidth, baseline, alignCorrection, rotation, align);\n                }\n\n                // apply position with correction\n                css(elem, {\n                    left: (x + (wrapper.xCorr || 0)) + PX,\n                    top: (y + (wrapper.yCorr || 0)) + PX\n                });\n\n                // force reflow in webkit to apply the left and top on useHTML element (#1249)\n                if (isWebKit) {\n                    baseline = elem.offsetHeight; // assigned to baseline for lint purpose\n                }\n\n                // record current text transform\n                wrapper.cTT = currentTextTransform;\n            }\n        },\n\n        /**\n         * Set the rotation of an individual HTML span\n         */\n        setSpanRotation: function (rotation, alignCorrection, baseline) {\n            var rotationStyle = {},\n                cssTransformKey = isMS ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : isOpera ? '-o-transform' : '';\n\n            rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';\n            rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';\n            css(this.element, rotationStyle);\n        },\n\n        /**\n         * Get the correction in X and Y positioning as the element is rotated.\n         */\n        getSpanCorrection: function (width, baseline, alignCorrection) {\n            this.xCorr = -width * alignCorrection;\n            this.yCorr = -baseline;\n        }\n    });\n\n    // Extend SvgRenderer for useHTML option.\n    extend(SVGRenderer.prototype, {\n        /**\n         * Create HTML text node. This is used by the VML renderer as well as the SVG\n         * renderer through the useHTML option.\n         *\n         * @param {String} str\n         * @param {Number} x\n         * @param {Number} y\n         */\n        html: function (str, x, y) {\n            var wrapper = this.createElement('span'),\n                element = wrapper.element,\n                renderer = wrapper.renderer,\n                addSetters = function (element, style) {\n                    // These properties are set as attributes on the SVG group, and as\n                    // identical CSS properties on the div. (#3542)\n                    each(['opacity', 'visibility'], function (prop) {\n                        wrap(element, prop + 'Setter', function (proceed, value, key, elem) {\n                            proceed.call(this, value, key, elem);\n                            style[key] = value;\n                        });\n                    });            \n                };\n\n            // Text setter\n            wrapper.textSetter = function (value) {\n                if (value !== element.innerHTML) {\n                    delete this.bBox;\n                }\n                element.innerHTML = this.textStr = value;\n                wrapper.htmlUpdateTransform();\n            };\n            addSetters(wrapper, wrapper.element.style);\n\n            // Various setters which rely on update transform\n            wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {\n                if (key === 'align') {\n                    key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.\n                }\n                wrapper[key] = value;\n                wrapper.htmlUpdateTransform();\n            };\n\n            // Set the default attributes\n            wrapper\n                .attr({\n                    text: str,\n                    x: mathRound(x),\n                    y: mathRound(y)\n                })\n                .css({\n                    position: ABSOLUTE,\n                    fontFamily: this.style.fontFamily,\n                    fontSize: this.style.fontSize\n                });\n\n            // Keep the whiteSpace style outside the wrapper.styles collection\n            element.style.whiteSpace = 'nowrap';\n\n            // Use the HTML specific .css method\n            wrapper.css = wrapper.htmlCss;\n\n            // This is specific for HTML within SVG\n            if (renderer.isSVG) {\n                wrapper.add = function (svgGroupWrapper) {\n\n                    var htmlGroup,\n                        container = renderer.box.parentNode,\n                        parentGroup,\n                        parents = [];\n\n                    this.parentGroup = svgGroupWrapper;\n\n                    // Create a mock group to hold the HTML elements\n                    if (svgGroupWrapper) {\n                        htmlGroup = svgGroupWrapper.div;\n                        if (!htmlGroup) {\n\n                            // Read the parent chain into an array and read from top down\n                            parentGroup = svgGroupWrapper;\n                            while (parentGroup) {\n\n                                parents.push(parentGroup);\n\n                                // Move up to the next parent group\n                                parentGroup = parentGroup.parentGroup;\n                            }\n\n                            // Ensure dynamically updating position when any parent is translated\n                            each(parents.reverse(), function (parentGroup) {\n                                var htmlGroupStyle,\n                                    cls = attr(parentGroup.element, 'class');\n\n                                if (cls) {\n                                    cls = { className: cls };\n                                } // else null\n\n                                // Create a HTML div and append it to the parent div to emulate\n                                // the SVG group structure\n                                htmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, cls, {\n                                    position: ABSOLUTE,\n                                    left: (parentGroup.translateX || 0) + PX,\n                                    top: (parentGroup.translateY || 0) + PX\n                                }, htmlGroup || container); // the top group is appended to container\n\n                                // Shortcut\n                                htmlGroupStyle = htmlGroup.style;\n\n                                // Set listeners to update the HTML div's position whenever the SVG group\n                                // position is changed\n                                extend(parentGroup, {\n                                    translateXSetter: function (value, key) {\n                                        htmlGroupStyle.left = value + PX;\n                                        parentGroup[key] = value;\n                                        parentGroup.doTransform = true;\n                                    },\n                                    translateYSetter: function (value, key) {\n                                        htmlGroupStyle.top = value + PX;\n                                        parentGroup[key] = value;\n                                        parentGroup.doTransform = true;\n                                    }\n                                });\n                                addSetters(parentGroup, htmlGroupStyle);\n                            });\n\n                        }\n                    } else {\n                        htmlGroup = container;\n                    }\n\n                    htmlGroup.appendChild(element);\n\n                    // Shared with VML:\n                    wrapper.added = true;\n                    if (wrapper.alignOnAdd) {\n                        wrapper.htmlUpdateTransform();\n                    }\n\n                    return wrapper;\n                };\n            }\n            return wrapper;\n        }\n    });\n\n\n    /* ****************************************************************************\n     *                                                                            *\n     * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *\n     *                                                                            *\n     * For applications and websites that don't need IE support, like platform    *\n     * targeted mobile apps and web apps, this code can be removed.               *\n     *                                                                            *\n     *****************************************************************************/\n\n    /**\n     * @constructor\n     */\n    var VMLRenderer, VMLElement;\n    if (!hasSVG && !useCanVG) {\n\n    /**\n     * The VML element wrapper.\n     */\n    VMLElement = {\n\n        /**\n         * Initialize a new VML element wrapper. It builds the markup as a string\n         * to minimize DOM traffic.\n         * @param {Object} renderer\n         * @param {Object} nodeName\n         */\n        init: function (renderer, nodeName) {\n            var wrapper = this,\n                markup =  ['<', nodeName, ' filled=\"f\" stroked=\"f\"'],\n                style = ['position: ', ABSOLUTE, ';'],\n                isDiv = nodeName === DIV;\n\n            // divs and shapes need size\n            if (nodeName === 'shape' || isDiv) {\n                style.push('left:0;top:0;width:1px;height:1px;');\n            }\n            style.push('visibility: ', isDiv ? HIDDEN : VISIBLE);\n\n            markup.push(' style=\"', style.join(''), '\"/>');\n\n            // create element with default attributes and style\n            if (nodeName) {\n                markup = isDiv || nodeName === 'span' || nodeName === 'img' ?\n                    markup.join('')    :\n                    renderer.prepVML(markup);\n                wrapper.element = createElement(markup);\n            }\n\n            wrapper.renderer = renderer;\n        },\n\n        /**\n         * Add the node to the given parent\n         * @param {Object} parent\n         */\n        add: function (parent) {\n            var wrapper = this,\n                renderer = wrapper.renderer,\n                element = wrapper.element,\n                box = renderer.box,\n                inverted = parent && parent.inverted,\n\n                // get the parent node\n                parentNode = parent ?\n                    parent.element || parent :\n                    box;\n\n            if (parent) {\n                this.parentGroup = parent;\n            }\n\n            // if the parent group is inverted, apply inversion on all children\n            if (inverted) { // only on groups\n                renderer.invertChild(element, parentNode);\n            }\n\n            // append it\n            parentNode.appendChild(element);\n\n            // align text after adding to be able to read offset\n            wrapper.added = true;\n            if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {\n                wrapper.updateTransform();\n            }\n\n            // fire an event for internal hooks\n            if (wrapper.onAdd) {\n                wrapper.onAdd();\n            }\n\n            return wrapper;\n        },\n\n        /**\n         * VML always uses htmlUpdateTransform\n         */\n        updateTransform: SVGElement.prototype.htmlUpdateTransform,\n\n        /**\n         * Set the rotation of a span with oldIE's filter\n         */\n        setSpanRotation: function () {\n            // Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented\n            // but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+\n            // has support for CSS3 transform. The getBBox method also needs to be updated\n            // to compensate for the rotation, like it currently does for SVG.\n            // Test case: http://jsfiddle.net/highcharts/Ybt44/\n\n            var rotation = this.rotation,\n                costheta = mathCos(rotation * deg2rad),\n                sintheta = mathSin(rotation * deg2rad);\n\n            css(this.element, {\n                filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,\n                    ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,\n                    ', sizingMethod=\\'auto expand\\')'].join('') : NONE\n            });\n        },\n\n        /**\n         * Get the positioning correction for the span after rotating.\n         */\n        getSpanCorrection: function (width, baseline, alignCorrection, rotation, align) {\n\n            var costheta = rotation ? mathCos(rotation * deg2rad) : 1,\n                sintheta = rotation ? mathSin(rotation * deg2rad) : 0,\n                height = pick(this.elemHeight, this.element.offsetHeight),\n                quad,\n                nonLeft = align && align !== 'left';\n\n            // correct x and y\n            this.xCorr = costheta < 0 && -width;\n            this.yCorr = sintheta < 0 && -height;\n\n            // correct for baseline and corners spilling out after rotation\n            quad = costheta * sintheta < 0;\n            this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);\n            this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);\n            // correct for the length/height of the text\n            if (nonLeft) {\n                this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);\n                if (rotation) {\n                    this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);\n                }\n                css(this.element, {\n                    textAlign: align\n                });\n            }\n        },\n\n        /**\n         * Converts a subset of an SVG path definition to its VML counterpart. Takes an array\n         * as the parameter and returns a string.\n         */\n        pathToVML: function (value) {\n            // convert paths\n            var i = value.length,\n                path = [];\n\n            while (i--) {\n\n                // Multiply by 10 to allow subpixel precision.\n                // Substracting half a pixel seems to make the coordinates\n                // align with SVG, but this hasn't been tested thoroughly\n                if (isNumber(value[i])) {\n                    path[i] = mathRound(value[i] * 10) - 5;\n                } else if (value[i] === 'Z') { // close the path\n                    path[i] = 'x';\n                } else {\n                    path[i] = value[i];\n\n                    // When the start X and end X coordinates of an arc are too close,\n                    // they are rounded to the same value above. In this case, substract or\n                    // add 1 from the end X and Y positions. #186, #760, #1371, #1410.\n                    if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {\n                        // Start and end X\n                        if (path[i + 5] === path[i + 7]) {\n                            path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;\n                        }\n                        // Start and end Y\n                        if (path[i + 6] === path[i + 8]) {\n                            path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;\n                        }\n                    }\n                }\n            }\n\n\n            // Loop up again to handle path shortcuts (#2132)\n            /*while (i++ < path.length) {\n                if (path[i] === 'H') { // horizontal line to\n                    path[i] = 'L';\n                    path.splice(i + 2, 0, path[i - 1]);\n                } else if (path[i] === 'V') { // vertical line to\n                    path[i] = 'L';\n                    path.splice(i + 1, 0, path[i - 2]);\n                }\n            }*/\n            return path.join(' ') || 'x';\n        },\n\n        /**\n         * Set the element's clipping to a predefined rectangle\n         *\n         * @param {String} id The id of the clip rectangle\n         */\n        clip: function (clipRect) {\n            var wrapper = this,\n                clipMembers,\n                cssRet;\n\n            if (clipRect) {\n                clipMembers = clipRect.members;\n                erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)\n                clipMembers.push(wrapper);\n                wrapper.destroyClip = function () {\n                    erase(clipMembers, wrapper);\n                };\n                cssRet = clipRect.getCSS(wrapper);\n\n            } else {\n                if (wrapper.destroyClip) {\n                    wrapper.destroyClip();\n                }\n                cssRet = { clip: docMode8 ? 'inherit' : 'rect(auto)' }; // #1214\n            }\n\n            return wrapper.css(cssRet);\n\n        },\n\n        /**\n         * Set styles for the element\n         * @param {Object} styles\n         */\n        css: SVGElement.prototype.htmlCss,\n\n        /**\n         * Removes a child either by removeChild or move to garbageBin.\n         * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n         */\n        safeRemoveChild: function (element) {\n            // discardElement will detach the node from its parent before attaching it\n            // to the garbage bin. Therefore it is important that the node is attached and have parent.\n            if (element.parentNode) {\n                discardElement(element);\n            }\n        },\n\n        /**\n         * Extend element.destroy by removing it from the clip members array\n         */\n        destroy: function () {\n            if (this.destroyClip) {\n                this.destroyClip();\n            }\n\n            return SVGElement.prototype.destroy.apply(this);\n        },\n\n        /**\n         * Add an event listener. VML override for normalizing event parameters.\n         * @param {String} eventType\n         * @param {Function} handler\n         */\n        on: function (eventType, handler) {\n            // simplest possible event model for internal use\n            this.element['on' + eventType] = function () {\n                var evt = win.event;\n                evt.target = evt.srcElement;\n                handler(evt);\n            };\n            return this;\n        },\n\n        /**\n         * In stacked columns, cut off the shadows so that they don't overlap\n         */\n        cutOffPath: function (path, length) {\n\n            var len;\n\n            path = path.split(/[ ,]/);\n            len = path.length;\n\n            if (len === 9 || len === 11) {\n                path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;\n            }\n            return path.join(' ');\n        },\n\n        /**\n         * Apply a drop shadow by copying elements and giving them different strokes\n         * @param {Boolean|Object} shadowOptions\n         */\n        shadow: function (shadowOptions, group, cutOff) {\n            var shadows = [],\n                i,\n                element = this.element,\n                renderer = this.renderer,\n                shadow,\n                elemStyle = element.style,\n                markup,\n                path = element.path,\n                strokeWidth,\n                modifiedPath,\n                shadowWidth,\n                shadowElementOpacity;\n\n            // some times empty paths are not strings\n            if (path && typeof path.value !== 'string') {\n                path = 'x';\n            }\n            modifiedPath = path;\n\n            if (shadowOptions) {\n                shadowWidth = pick(shadowOptions.width, 3);\n                shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n                for (i = 1; i <= 3; i++) {\n\n                    strokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n\n                    // Cut off shadows for stacked column items\n                    if (cutOff) {\n                        modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);\n                    }\n\n                    markup = ['<shape isShadow=\"true\" strokeweight=\"', strokeWidth,\n                        '\" filled=\"false\" path=\"', modifiedPath,\n                        '\" coordsize=\"10 10\" style=\"', element.style.cssText, '\" />'];\n\n                    shadow = createElement(renderer.prepVML(markup),\n                        null, {\n                            left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),\n                            top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)\n                        }\n                    );\n                    if (cutOff) {\n                        shadow.cutOff = strokeWidth + 1;\n                    }\n\n                    // apply the opacity\n                    markup = ['<stroke color=\"', shadowOptions.color || 'black', '\" opacity=\"', shadowElementOpacity * i, '\"/>'];\n                    createElement(renderer.prepVML(markup), null, null, shadow);\n\n\n                    // insert it\n                    if (group) {\n                        group.element.appendChild(shadow);\n                    } else {\n                        element.parentNode.insertBefore(shadow, element);\n                    }\n\n                    // record it\n                    shadows.push(shadow);\n\n                }\n\n                this.shadows = shadows;\n            }\n            return this;\n        },\n        updateShadows: noop, // Used in SVG only\n\n        setAttr: function (key, value) {\n            if (docMode8) { // IE8 setAttribute bug\n                this.element[key] = value;\n            } else {\n                this.element.setAttribute(key, value);\n            }\n        },\n        classSetter: function (value) {\n            // IE8 Standards mode has problems retrieving the className unless set like this\n            this.element.className = value;\n        },\n        dashstyleSetter: function (value, key, element) {\n            var strokeElem = element.getElementsByTagName('stroke')[0] ||\n                createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);\n            strokeElem[key] = value || 'solid';\n            this[key] = value; /* because changing stroke-width will change the dash length\n                and cause an epileptic effect */\n        },\n        dSetter: function (value, key, element) {\n            var i,\n                shadows = this.shadows;\n            value = value || [];\n            this.d = value.join && value.join(' '); // used in getter for animation\n\n            element.path = value = this.pathToVML(value);\n\n            // update shadows\n            if (shadows) {\n                i = shadows.length;\n                while (i--) {\n                    shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;\n                }\n            }\n            this.setAttr(key, value);\n        },\n        fillSetter: function (value, key, element) {\n            var nodeName = element.nodeName;\n            if (nodeName === 'SPAN') { // text color\n                element.style.color = value;\n            } else if (nodeName !== 'IMG') { // #1336\n                element.filled = value !== NONE;\n                this.setAttr('fillcolor', this.renderer.color(value, element, key, this));\n            }\n        },\n        'fill-opacitySetter': function (value, key, element) {\n            createElement(\n                this.renderer.prepVML(['<', key.split('-')[0], ' opacity=\"', value, '\"/>']),\n                null,\n                null,\n                element\n            );\n        },\n        opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts\n        rotationSetter: function (value, key, element) {\n            var style = element.style;\n            this[key] = style[key] = value; // style is for #1873\n\n            // Correction for the 1x1 size of the shape container. Used in gauge needles.\n            style.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;\n            style.top = mathRound(mathCos(value * deg2rad)) + PX;\n        },\n        strokeSetter: function (value, key, element) {\n            this.setAttr('strokecolor', this.renderer.color(value, element, key, this));\n        },\n        'stroke-widthSetter': function (value, key, element) {\n            element.stroked = !!value; // VML \"stroked\" attribute\n            this[key] = value; // used in getter, issue #113\n            if (isNumber(value)) {\n                value += PX;\n            }\n            this.setAttr('strokeweight', value);\n        },\n        titleSetter: function (value, key) {\n            this.setAttr(key, value);\n        },\n        visibilitySetter: function (value, key, element) {\n\n            // Handle inherited visibility\n            if (value === 'inherit') {\n                value = VISIBLE;\n            }\n\n            // Let the shadow follow the main element\n            if (this.shadows) {\n                each(this.shadows, function (shadow) {\n                    shadow.style[key] = value;\n                });\n            }\n\n            // Instead of toggling the visibility CSS property, move the div out of the viewport.\n            // This works around #61 and #586\n            if (element.nodeName === 'DIV') {\n                value = value === HIDDEN ? '-999em' : 0;\n\n                // In order to redraw, IE7 needs the div to be visible when tucked away\n                // outside the viewport. So the visibility is actually opposite of\n                // the expected value. This applies to the tooltip only.\n                if (!docMode8) {\n                    element.style[key] = value ? VISIBLE : HIDDEN;\n                }\n                key = 'top';\n            }\n            element.style[key] = value;\n        },\n        xSetter: function (value, key, element) {\n            this[key] = value; // used in getter\n\n            if (key === 'x') {\n                key = 'left';\n            } else if (key === 'y') {\n                key = 'top';\n            }/* else {\n                value = mathMax(0, value); // don't set width or height below zero (#311)\n            }*/\n\n            // clipping rectangle special\n            if (this.updateClipping) {\n                this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'\n                this.updateClipping();\n            } else {\n                // normal\n                element.style[key] = value;\n            }\n        },\n        zIndexSetter: function (value, key, element) {\n            element.style[key] = value;\n        }\n    };\n    VMLElement['stroke-opacitySetter'] = VMLElement['fill-opacitySetter'];\n\n    Highcharts.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);\n\n    // Some shared setters\n    VMLElement.prototype.ySetter =\n        VMLElement.prototype.widthSetter =\n        VMLElement.prototype.heightSetter =\n        VMLElement.prototype.xSetter;\n\n\n    /**\n     * The VML renderer\n     */\n    var VMLRendererExtension = { // inherit SVGRenderer\n\n        Element: VMLElement,\n        isIE8: userAgent.indexOf('MSIE 8.0') > -1,\n\n\n        /**\n         * Initialize the VMLRenderer\n         * @param {Object} container\n         * @param {Number} width\n         * @param {Number} height\n         */\n        init: function (container, width, height, style) {\n            var renderer = this,\n                boxWrapper,\n                box,\n                css;\n\n            renderer.alignedObjects = [];\n\n            boxWrapper = renderer.createElement(DIV)\n                .css(extend(this.getStyle(style), { position: 'relative' }));\n            box = boxWrapper.element;\n            container.appendChild(boxWrapper.element);\n\n\n            // generate the containing box\n            renderer.isVML = true;\n            renderer.box = box;\n            renderer.boxWrapper = boxWrapper;\n            renderer.gradients = {};\n            renderer.cache = {}; // Cache for numerical bounding boxes\n            renderer.cacheKeys = [];\n            renderer.imgCount = 0;\n\n\n            renderer.setSize(width, height, false);\n\n            // The only way to make IE6 and IE7 print is to use a global namespace. However,\n            // with IE8 the only way to make the dynamic shapes visible in screen and print mode\n            // seems to be to add the xmlns attribute and the behaviour style inline.\n            if (!doc.namespaces.hcv) {\n\n                doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');\n\n                // Setup default CSS (#2153, #2368, #2384)\n                css = 'hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke' +\n                    '{ behavior:url(#default#VML); display: inline-block; } ';\n                try {\n                    doc.createStyleSheet().cssText = css;\n                } catch (e) {\n                    doc.styleSheets[0].cssText += css;\n                }\n\n            }\n        },\n\n\n        /**\n         * Detect whether the renderer is hidden. This happens when one of the parent elements\n         * has display: none\n         */\n        isHidden: function () {\n            return !this.box.offsetWidth;\n        },\n\n        /**\n         * Define a clipping rectangle. In VML it is accomplished by storing the values\n         * for setting the CSS style to all associated members.\n         *\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Number} width\n         * @param {Number} height\n         */\n        clipRect: function (x, y, width, height) {\n\n            // create a dummy element\n            var clipRect = this.createElement(),\n                isObj = isObject(x);\n\n            // mimic a rectangle with its style object for automatic updating in attr\n            return extend(clipRect, {\n                members: [],\n                count: 0,\n                left: (isObj ? x.x : x) + 1,\n                top: (isObj ? x.y : y) + 1,\n                width: (isObj ? x.width : width) - 1,\n                height: (isObj ? x.height : height) - 1,\n                getCSS: function (wrapper) {\n                    var element = wrapper.element,\n                        nodeName = element.nodeName,\n                        isShape = nodeName === 'shape',\n                        inverted = wrapper.inverted,\n                        rect = this,\n                        top = rect.top - (isShape ? element.offsetTop : 0),\n                        left = rect.left,\n                        right = left + rect.width,\n                        bottom = top + rect.height,\n                        ret = {\n                            clip: 'rect(' +\n                                mathRound(inverted ? left : top) + 'px,' +\n                                mathRound(inverted ? bottom : right) + 'px,' +\n                                mathRound(inverted ? right : bottom) + 'px,' +\n                                mathRound(inverted ? top : left) + 'px)'\n                        };\n\n                    // issue 74 workaround\n                    if (!inverted && docMode8 && nodeName === 'DIV') {\n                        extend(ret, {\n                            width: right + PX,\n                            height: bottom + PX\n                        });\n                    }\n                    return ret;\n                },\n\n                // used in attr and animation to update the clipping of all members\n                updateClipping: function () {\n                    each(clipRect.members, function (member) {\n                        if (member.element) { // Deleted series, like in stock/members/series-remove demo. Should be removed from members, but this will do.\n                            member.css(clipRect.getCSS(member));\n                        }\n                    });\n                }\n            });\n\n        },\n\n\n        /**\n         * Take a color and return it if it's a string, make it a gradient if it's a\n         * gradient configuration object, and apply opacity.\n         *\n         * @param {Object} color The color or config object\n         */\n        color: function (color, elem, prop, wrapper) {\n            var renderer = this,\n                colorObject,\n                regexRgba = /^rgba/,\n                markup,\n                fillType,\n                ret = NONE;\n\n            // Check for linear or radial gradient\n            if (color && color.linearGradient) {\n                fillType = 'gradient';\n            } else if (color && color.radialGradient) {\n                fillType = 'pattern';\n            }\n\n\n            if (fillType) {\n\n                var stopColor,\n                    stopOpacity,\n                    gradient = color.linearGradient || color.radialGradient,\n                    x1,\n                    y1,\n                    x2,\n                    y2,\n                    opacity1,\n                    opacity2,\n                    color1,\n                    color2,\n                    fillAttr = '',\n                    stops = color.stops,\n                    firstStop,\n                    lastStop,\n                    colors = [],\n                    addFillNode = function () {\n                        // Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2\n                        // are reversed.\n                        markup = ['<fill colors=\"' + colors.join(',') + '\" opacity=\"', opacity2, '\" o:opacity2=\"', opacity1,\n                            '\" type=\"', fillType, '\" ', fillAttr, 'focus=\"100%\" method=\"any\" />'];\n                        createElement(renderer.prepVML(markup), null, null, elem);\n                    };\n\n                // Extend from 0 to 1\n                firstStop = stops[0];\n                lastStop = stops[stops.length - 1];\n                if (firstStop[0] > 0) {\n                    stops.unshift([\n                        0,\n                        firstStop[1]\n                    ]);\n                }\n                if (lastStop[0] < 1) {\n                    stops.push([\n                        1,\n                        lastStop[1]\n                    ]);\n                }\n\n                // Compute the stops\n                each(stops, function (stop, i) {\n                    if (regexRgba.test(stop[1])) {\n                        colorObject = Color(stop[1]);\n                        stopColor = colorObject.get('rgb');\n                        stopOpacity = colorObject.get('a');\n                    } else {\n                        stopColor = stop[1];\n                        stopOpacity = 1;\n                    }\n\n                    // Build the color attribute\n                    colors.push((stop[0] * 100) + '% ' + stopColor);\n\n                    // Only start and end opacities are allowed, so we use the first and the last\n                    if (!i) {\n                        opacity1 = stopOpacity;\n                        color2 = stopColor;\n                    } else {\n                        opacity2 = stopOpacity;\n                        color1 = stopColor;\n                    }\n                });\n\n                // Apply the gradient to fills only.\n                if (prop === 'fill') {\n\n                    // Handle linear gradient angle\n                    if (fillType === 'gradient') {\n                        x1 = gradient.x1 || gradient[0] || 0;\n                        y1 = gradient.y1 || gradient[1] || 0;\n                        x2 = gradient.x2 || gradient[2] || 0;\n                        y2 = gradient.y2 || gradient[3] || 0;\n                        fillAttr = 'angle=\"' + (90  - math.atan(\n                            (y2 - y1) / // y vector\n                            (x2 - x1) // x vector\n                            ) * 180 / mathPI) + '\"';\n\n                        addFillNode();\n\n                    // Radial (circular) gradient\n                    } else {\n\n                        var r = gradient.r,\n                            sizex = r * 2,\n                            sizey = r * 2,\n                            cx = gradient.cx,\n                            cy = gradient.cy,\n                            radialReference = elem.radialReference,\n                            bBox,\n                            applyRadialGradient = function () {\n                                if (radialReference) {\n                                    bBox = wrapper.getBBox();\n                                    cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;\n                                    cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;\n                                    sizex *= radialReference[2] / bBox.width;\n                                    sizey *= radialReference[2] / bBox.height;\n                                }\n                                fillAttr = 'src=\"' + defaultOptions.global.VMLRadialGradientURL + '\" ' +\n                                    'size=\"' + sizex + ',' + sizey + '\" ' +\n                                    'origin=\"0.5,0.5\" ' +\n                                    'position=\"' + cx + ',' + cy + '\" ' +\n                                    'color2=\"' + color2 + '\" ';\n\n                                addFillNode();\n                            };\n\n                        // Apply radial gradient\n                        if (wrapper.added) {\n                            applyRadialGradient();\n                        } else {\n                            // We need to know the bounding box to get the size and position right\n                            wrapper.onAdd = applyRadialGradient;\n                        }\n\n                        // The fill element's color attribute is broken in IE8 standards mode, so we\n                        // need to set the parent shape's fillcolor attribute instead.\n                        ret = color1;\n                    }\n\n                // Gradients are not supported for VML stroke, return the first color. #722.\n                } else {\n                    ret = stopColor;\n                }\n\n            // If the color is an rgba color, split it and add a fill node\n            // to hold the opacity component\n            } else if (regexRgba.test(color) && elem.tagName !== 'IMG') {\n\n                colorObject = Color(color);\n\n                wrapper[prop + '-opacitySetter'](colorObject.get('a'), prop, elem);\n\n                ret = colorObject.get('rgb');\n\n\n            } else {\n                var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node\n                if (propNodes.length) {\n                    propNodes[0].opacity = 1;\n                    propNodes[0].type = 'solid';\n                }\n                ret = color;\n            }\n\n            return ret;\n        },\n\n        /**\n         * Take a VML string and prepare it for either IE8 or IE6/IE7.\n         * @param {Array} markup A string array of the VML markup to prepare\n         */\n        prepVML: function (markup) {\n            var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',\n                isIE8 = this.isIE8;\n\n            markup = markup.join('');\n\n            if (isIE8) { // add xmlns and style inline\n                markup = markup.replace('/>', ' xmlns=\"urn:schemas-microsoft-com:vml\" />');\n                if (markup.indexOf('style=\"') === -1) {\n                    markup = markup.replace('/>', ' style=\"' + vmlStyle + '\" />');\n                } else {\n                    markup = markup.replace('style=\"', 'style=\"' + vmlStyle);\n                }\n\n            } else { // add namespace\n                markup = markup.replace('<', '<hcv:');\n            }\n\n            return markup;\n        },\n\n        /**\n         * Create rotated and aligned text\n         * @param {String} str\n         * @param {Number} x\n         * @param {Number} y\n         */\n        text: SVGRenderer.prototype.html,\n\n        /**\n         * Create and return a path element\n         * @param {Array} path\n         */\n        path: function (path) {\n            var attr = {\n                // subpixel precision down to 0.1 (width and height = 1px)\n                coordsize: '10 10'\n            };\n            if (isArray(path)) {\n                attr.d = path;\n            } else if (isObject(path)) { // attributes\n                extend(attr, path);\n            }\n            // create the shape\n            return this.createElement('shape').attr(attr);\n        },\n\n        /**\n         * Create and return a circle element. In VML circles are implemented as\n         * shapes, which is faster than v:oval\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Number} r\n         */\n        circle: function (x, y, r) {\n            var circle = this.symbol('circle');\n            if (isObject(x)) {\n                r = x.r;\n                y = x.y;\n                x = x.x;\n            }\n            circle.isCircle = true; // Causes x and y to mean center (#1682)\n            circle.r = r;\n            return circle.attr({ x: x, y: y });\n        },\n\n        /**\n         * Create a group using an outer div and an inner v:group to allow rotating\n         * and flipping. A simple v:group would have problems with positioning\n         * child HTML elements and CSS clip.\n         *\n         * @param {String} name The name of the group\n         */\n        g: function (name) {\n            var wrapper,\n                attribs;\n\n            // set the class name\n            if (name) {\n                attribs = { 'className': PREFIX + name, 'class': PREFIX + name };\n            }\n\n            // the div to hold HTML and clipping\n            wrapper = this.createElement(DIV).attr(attribs);\n\n            return wrapper;\n        },\n\n        /**\n         * VML override to create a regular HTML image\n         * @param {String} src\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Number} width\n         * @param {Number} height\n         */\n        image: function (src, x, y, width, height) {\n            var obj = this.createElement('img')\n                .attr({ src: src });\n\n            if (arguments.length > 1) {\n                obj.attr({\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }\n            return obj;\n        },\n\n        /**\n         * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems\n         */\n        createElement: function (nodeName) {\n            return nodeName === 'rect' ? this.symbol(nodeName) : SVGRenderer.prototype.createElement.call(this, nodeName);\n        },\n\n        /**\n         * In the VML renderer, each child of an inverted div (group) is inverted\n         * @param {Object} element\n         * @param {Object} parentNode\n         */\n        invertChild: function (element, parentNode) {\n            var ren = this,\n                parentStyle = parentNode.style,\n                imgStyle = element.tagName === 'IMG' && element.style; // #1111\n\n            css(element, {\n                flip: 'x',\n                left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),\n                top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),\n                rotation: -90\n            });\n\n            // Recursively invert child elements, needed for nested composite shapes like box plots and error bars. #1680, #1806.\n            each(element.childNodes, function (child) {\n                ren.invertChild(child, element);\n            });\n        },\n\n        /**\n         * Symbol definitions that override the parent SVG renderer's symbols\n         *\n         */\n        symbols: {\n            // VML specific arc function\n            arc: function (x, y, w, h, options) {\n                var start = options.start,\n                    end = options.end,\n                    radius = options.r || w || h,\n                    innerRadius = options.innerR,\n                    cosStart = mathCos(start),\n                    sinStart = mathSin(start),\n                    cosEnd = mathCos(end),\n                    sinEnd = mathSin(end),\n                    ret;\n\n                if (end - start === 0) { // no angle, don't show it.\n                    return ['x'];\n                }\n\n                ret = [\n                    'wa', // clockwise arc to\n                    x - radius, // left\n                    y - radius, // top\n                    x + radius, // right\n                    y + radius, // bottom\n                    x + radius * cosStart, // start x\n                    y + radius * sinStart, // start y\n                    x + radius * cosEnd, // end x\n                    y + radius * sinEnd  // end y\n                ];\n\n                if (options.open && !innerRadius) {\n                    ret.push(\n                        'e',\n                        M,\n                        x, // - innerRadius,\n                        y// - innerRadius\n                    );\n                }\n\n                ret.push(\n                    'at', // anti clockwise arc to\n                    x - innerRadius, // left\n                    y - innerRadius, // top\n                    x + innerRadius, // right\n                    y + innerRadius, // bottom\n                    x + innerRadius * cosEnd, // start x\n                    y + innerRadius * sinEnd, // start y\n                    x + innerRadius * cosStart, // end x\n                    y + innerRadius * sinStart, // end y\n                    'x', // finish path\n                    'e' // close\n                );\n\n                ret.isArc = true;\n                return ret;\n\n            },\n            // Add circle symbol path. This performs significantly faster than v:oval.\n            circle: function (x, y, w, h, wrapper) {\n\n                if (wrapper) {\n                    w = h = 2 * wrapper.r;\n                }\n\n                // Center correction, #1682\n                if (wrapper && wrapper.isCircle) {\n                    x -= w / 2;\n                    y -= h / 2;\n                }\n\n                // Return the path\n                return [\n                    'wa', // clockwisearcto\n                    x, // left\n                    y, // top\n                    x + w, // right\n                    y + h, // bottom\n                    x + w, // start x\n                    y + h / 2,     // start y\n                    x + w, // end x\n                    y + h / 2,     // end y\n                    //'x', // finish path\n                    'e' // close\n                ];\n            },\n            /**\n             * Add rectangle symbol path which eases rotation and omits arcsize problems\n             * compared to the built-in VML roundrect shape. When borders are not rounded,\n             * use the simpler square path, else use the callout path without the arrow.\n             */\n            rect: function (x, y, w, h, options) {\n                return SVGRenderer.prototype.symbols[\n                    !defined(options) || !options.r ? 'square' : 'callout'\n                ].call(0, x, y, w, h, options);\n            }\n        }\n    };\n    Highcharts.VMLRenderer = VMLRenderer = function () {\n        this.init.apply(this, arguments);\n    };\n    VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);\n\n        // general renderer\n        Renderer = VMLRenderer;\n    }\n\n    // This method is used with exporting in old IE, when emulating SVG (see #2314)\n    SVGRenderer.prototype.measureSpanWidth = function (text, styles) {\n        var measuringSpan = doc.createElement('span'),\n            offsetWidth,\n            textNode = doc.createTextNode(text);\n\n        measuringSpan.appendChild(textNode);\n        css(measuringSpan, styles);\n        this.box.appendChild(measuringSpan);\n        offsetWidth = measuringSpan.offsetWidth;\n        discardElement(measuringSpan); // #2463\n        return offsetWidth;\n    };\n\n\n    /* ****************************************************************************\n     *                                                                            *\n     * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *\n     *                                                                            *\n     *****************************************************************************/\n    /* ****************************************************************************\n     *                                                                            *\n     * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *\n     * TARGETING THAT SYSTEM.                                                     *\n     *                                                                            *\n     *****************************************************************************/\n    var CanVGRenderer,\n        CanVGController;\n\n    /**\n     * Downloads a script and executes a callback when done.\n     * @param {String} scriptLocation\n     * @param {Function} callback\n     */\n    function getScript(scriptLocation, callback) {\n        var head = doc.getElementsByTagName('head')[0],\n            script = doc.createElement('script');\n\n        script.type = 'text/javascript';\n        script.src = scriptLocation;\n        script.onload = callback;\n\n        head.appendChild(script);\n    }\n\n    if (useCanVG) {\n        /**\n         * The CanVGRenderer is empty from start to keep the source footprint small.\n         * When requested, the CanVGController downloads the rest of the source packaged\n         * together with the canvg library.\n         */\n        Highcharts.CanVGRenderer = CanVGRenderer = function () {\n            // Override the global SVG namespace to fake SVG/HTML that accepts CSS\n            SVG_NS = 'http://www.w3.org/1999/xhtml';\n        };\n\n        /**\n         * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but\n         * the implementation from SvgRenderer will not be merged in until first render.\n         */\n        CanVGRenderer.prototype.symbols = {};\n\n        /**\n         * Handles on demand download of canvg rendering support.\n         */\n        CanVGController = (function () {\n            // List of renderering calls\n            var deferredRenderCalls = [];\n\n            /**\n             * When downloaded, we are ready to draw deferred charts.\n             */\n            function drawDeferred() {\n                var callLength = deferredRenderCalls.length,\n                    callIndex;\n\n                // Draw all pending render calls\n                for (callIndex = 0; callIndex < callLength; callIndex++) {\n                    deferredRenderCalls[callIndex]();\n                }\n                // Clear the list\n                deferredRenderCalls = [];\n            }\n\n            return {\n                push: function (func, scriptLocation) {\n                    // Only get the script once\n                    if (deferredRenderCalls.length === 0) {\n                        getScript(scriptLocation, drawDeferred);\n                    }\n                    // Register render call\n                    deferredRenderCalls.push(func);\n                }\n            };\n        }());\n\n        Renderer = CanVGRenderer;\n    } // end CanVGRenderer\n\n    /* ****************************************************************************\n     *                                                                            *\n     * END OF ANDROID < 3 SPECIFIC CODE                                           *\n     *                                                                            *\n     *****************************************************************************/\n\n    /**\n     * The Tick class\n     */\n    function Tick(axis, pos, type, noLabel) {\n        this.axis = axis;\n        this.pos = pos;\n        this.type = type || '';\n        this.isNew = true;\n\n        if (!type && !noLabel) {\n            this.addLabel();\n        }\n    }\n\n    Tick.prototype = {\n        /**\n         * Write the tick label\n         */\n        addLabel: function () {\n            var tick = this,\n                axis = tick.axis,\n                options = axis.options,\n                chart = axis.chart,\n                categories = axis.categories,\n                names = axis.names,\n                pos = tick.pos,\n                labelOptions = options.labels,\n                str,\n                tickPositions = axis.tickPositions,\n                isFirst = pos === tickPositions[0],\n                isLast = pos === tickPositions[tickPositions.length - 1],\n                value = categories ?\n                    pick(categories[pos], names[pos], pos) :\n                    pos,\n                label = tick.label,\n                tickPositionInfo = tickPositions.info,\n                dateTimeLabelFormat;\n\n            // Set the datetime label format. If a higher rank is set for this position, use that. If not,\n            // use the general format.\n            if (axis.isDatetimeAxis && tickPositionInfo) {\n                dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];\n            }\n            // set properties for access in render method\n            tick.isFirst = isFirst;\n            tick.isLast = isLast;\n\n            // get the string\n            str = axis.labelFormatter.call({\n                axis: axis,\n                chart: chart,\n                isFirst: isFirst,\n                isLast: isLast,\n                dateTimeLabelFormat: dateTimeLabelFormat,\n                value: axis.isLog ? correctFloat(lin2log(value)) : value\n            });\n\n            // prepare CSS\n            //css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };\n\n            // first call\n            if (!defined(label)) {\n\n                tick.label = label =\n                    defined(str) && labelOptions.enabled ?\n                        chart.renderer.text(\n                                str,\n                                0,\n                                0,\n                                labelOptions.useHTML\n                            )\n                            //.attr(attr)\n                            // without position absolute, IE export sometimes is wrong\n                            .css(merge(labelOptions.style))\n                            .add(axis.labelGroup) :\n                        null;\n                tick.labelLength = label && label.getBBox().width; // Un-rotated length\n                tick.rotation = 0; // Base value to detect change for new calls to getBBox\n\n            // update\n            } else if (label) {\n                label.attr({ text: str });\n            }\n        },\n\n        /**\n         * Get the offset height or width of the label\n         */\n        getLabelSize: function () {\n            return this.label ?\n                this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :\n                0;\n        },\n\n        /**\n         * Handle the label overflow by adjusting the labels to the left and right edge, or\n         * hide them if they collide into the neighbour label.\n         */\n        handleOverflow: function (xy) {\n            var axis = this.axis,\n                pxPos = xy.x,\n                chartWidth = axis.chart.chartWidth,\n                spacing = axis.chart.spacing,\n                leftBound = pick(axis.labelLeft, mathMin(axis.pos, spacing[3])),\n                rightBound = pick(axis.labelRight, mathMax(axis.pos + axis.len, chartWidth - spacing[1])),\n                label = this.label,\n                rotation = this.rotation,\n                factor = { left: 0, center: 0.5, right: 1 }[axis.labelAlign],\n                labelWidth = label.getBBox().width,\n                slotWidth = axis.slotWidth,\n                xCorrection = factor,\n                goRight = 1,\n                leftPos,\n                rightPos,\n                textWidth,\n                css = {};\n\n            // Check if the label overshoots the chart spacing box. If it does, move it.\n            // If it now overshoots the slotWidth, add ellipsis.\n            if (!rotation) {\n                leftPos = pxPos - factor * labelWidth;\n                rightPos = pxPos + (1 - factor) * labelWidth;\n\n                if (leftPos < leftBound) {\n                    slotWidth = xy.x + slotWidth * (1 - factor) - leftBound;\n                } else if (rightPos > rightBound) {\n                    slotWidth = rightBound - xy.x + slotWidth * factor;\n                    goRight = -1;\n                }\n\n                slotWidth = mathMin(axis.slotWidth, slotWidth); // #4177\n                if (slotWidth < axis.slotWidth && axis.labelAlign === 'center') {\n                    xy.x += goRight * (axis.slotWidth - slotWidth - xCorrection * (axis.slotWidth - mathMin(labelWidth, slotWidth)));\n                }\n                // If the label width exceeds the available space, set a text width to be\n                // picked up below. Also, if a width has been set before, we need to set a new\n                // one because the reported labelWidth will be limited by the box (#3938).\n                if (labelWidth > slotWidth || (axis.autoRotation && label.styles.width)) {\n                    textWidth = slotWidth;\n                }\n\n            // Add ellipsis to prevent rotated labels to be clipped against the edge of the chart\n            } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {\n                textWidth = mathRound(pxPos / mathCos(rotation * deg2rad) - leftBound);\n            } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {\n                textWidth = mathRound((chartWidth - pxPos) / mathCos(rotation * deg2rad));\n            }\n\n            if (textWidth) {\n                css.width = textWidth;\n                if (!axis.options.labels.style.textOverflow) {\n                    css.textOverflow = 'ellipsis';\n                }\n                label.css(css);\n            }\n        },\n\n        /**\n         * Get the x and y position for ticks and labels\n         */\n        getPosition: function (horiz, pos, tickmarkOffset, old) {\n            var axis = this.axis,\n                chart = axis.chart,\n                cHeight = (old && chart.oldChartHeight) || chart.chartHeight;\n\n            return {\n                x: horiz ?\n                    axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :\n                    axis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),\n\n                y: horiz ?\n                    cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :\n                    cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB\n            };\n\n        },\n\n        /**\n         * Get the x, y position of the tick label\n         */\n        getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n            var axis = this.axis,\n                transA = axis.transA,\n                reversed = axis.reversed,\n                staggerLines = axis.staggerLines,\n                rotCorr = axis.tickRotCorr || { x: 0, y: 0 },\n                yOffset = labelOptions.y,\n                line;\n\n            if (!defined(yOffset)) {\n                yOffset = axis.side === 2 ? \n                    rotCorr.y + 8 :\n                    // #3140, #3140\n                    yOffset = mathCos(label.rotation * deg2rad) * (rotCorr.y - label.getBBox(false, 0).height / 2);\n            }\n\n            x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?\n                tickmarkOffset * transA * (reversed ? -1 : 1) : 0);\n            y = y + yOffset - (tickmarkOffset && !horiz ?\n                tickmarkOffset * transA * (reversed ? 1 : -1) : 0);\n\n            // Correct for staggered labels\n            if (staggerLines) {\n                line = (index / (step || 1) % staggerLines);\n                if (axis.opposite) {\n                    line = staggerLines - line - 1;\n                }\n                y += line * (axis.labelOffset / staggerLines);\n            }\n\n            return {\n                x: x,\n                y: mathRound(y)\n            };\n        },\n\n        /**\n         * Extendible method to return the path of the marker\n         */\n        getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {\n            return renderer.crispLine([\n                M,\n                x,\n                y,\n                L,\n                x + (horiz ? 0 : -tickLength),\n                y + (horiz ? tickLength : 0)\n            ], tickWidth);\n        },\n\n        /**\n         * Put everything in place\n         *\n         * @param index {Number}\n         * @param old {Boolean} Use old coordinates to prepare an animation into new position\n         */\n        render: function (index, old, opacity) {\n            var tick = this,\n                axis = tick.axis,\n                options = axis.options,\n                chart = axis.chart,\n                renderer = chart.renderer,\n                horiz = axis.horiz,\n                type = tick.type,\n                label = tick.label,\n                pos = tick.pos,\n                labelOptions = options.labels,\n                gridLine = tick.gridLine,\n                gridPrefix = type ? type + 'Grid' : 'grid',\n                tickPrefix = type ? type + 'Tick' : 'tick',\n                gridLineWidth = options[gridPrefix + 'LineWidth'],\n                gridLineColor = options[gridPrefix + 'LineColor'],\n                dashStyle = options[gridPrefix + 'LineDashStyle'],\n                tickLength = options[tickPrefix + 'Length'],\n                tickWidth = pick(options[tickPrefix + 'Width'], !type && axis.isXAxis ? 1 : 0), // X axis defaults to 1\n                tickColor = options[tickPrefix + 'Color'],\n                tickPosition = options[tickPrefix + 'Position'],\n                gridLinePath,\n                mark = tick.mark,\n                markPath,\n                step = /*axis.labelStep || */labelOptions.step,\n                attribs,\n                show = true,\n                tickmarkOffset = axis.tickmarkOffset,\n                xy = tick.getPosition(horiz, pos, tickmarkOffset, old),\n                x = xy.x,\n                y = xy.y,\n                reverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687\n\n            opacity = pick(opacity, 1);\n            this.isActive = true;\n\n            // create the grid line\n            if (gridLineWidth) {\n                gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);\n\n                if (gridLine === UNDEFINED) {\n                    attribs = {\n                        stroke: gridLineColor,\n                        'stroke-width': gridLineWidth\n                    };\n                    if (dashStyle) {\n                        attribs.dashstyle = dashStyle;\n                    }\n                    if (!type) {\n                        attribs.zIndex = 1;\n                    }\n                    if (old) {\n                        attribs.opacity = 0;\n                    }\n                    tick.gridLine = gridLine =\n                        gridLineWidth ?\n                            renderer.path(gridLinePath)\n                                .attr(attribs).add(axis.gridGroup) :\n                            null;\n                }\n\n                // If the parameter 'old' is set, the current call will be followed\n                // by another call, therefore do not do any animations this time\n                if (!old && gridLine && gridLinePath) {\n                    gridLine[tick.isNew ? 'attr' : 'animate']({\n                        d: gridLinePath,\n                        opacity: opacity\n                    });\n                }\n            }\n\n            // create the tick mark\n            if (tickWidth && tickLength) {\n\n                // negate the length\n                if (tickPosition === 'inside') {\n                    tickLength = -tickLength;\n                }\n                if (axis.opposite) {\n                    tickLength = -tickLength;\n                }\n\n                markPath = tick.getMarkPath(x, y, tickLength, tickWidth * reverseCrisp, horiz, renderer);\n                if (mark) { // updating\n                    mark.animate({\n                        d: markPath,\n                        opacity: opacity\n                    });\n                } else { // first time\n                    tick.mark = renderer.path(\n                        markPath\n                    ).attr({\n                        stroke: tickColor,\n                        'stroke-width': tickWidth,\n                        opacity: opacity\n                    }).add(axis.axisGroup);\n                }\n            }\n\n            // the label is created on init - now move it into place\n            if (label && !isNaN(x)) {\n                label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);\n\n                // Apply show first and show last. If the tick is both first and last, it is\n                // a single centered tick, in which case we show the label anyway (#2100).\n                if ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||\n                        (tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {\n                    show = false;\n\n                // Handle label overflow and show or hide accordingly\n                } else if (horiz && !axis.isRadial && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {\n                    tick.handleOverflow(xy);\n                }\n\n                // apply step\n                if (step && index % step) {\n                    // show those indices dividable by step\n                    show = false;\n                }\n\n                // Set the new position, and show or hide\n                if (show && !isNaN(xy.y)) {\n                    xy.opacity = opacity;\n                    label[tick.isNew ? 'attr' : 'animate'](xy);\n                    tick.isNew = false;\n                } else {\n                    label.attr('y', -9999); // #1338\n                }\n            }\n        },\n\n        /**\n         * Destructor for the tick prototype\n         */\n        destroy: function () {\n            destroyObjectProperties(this, this.axis);\n        }\n    };\n\n    /**\n     * The object wrapper for plot lines and plot bands\n     * @param {Object} options\n     */\n    Highcharts.PlotLineOrBand = function (axis, options) {\n        this.axis = axis;\n\n        if (options) {\n            this.options = options;\n            this.id = options.id;\n        }\n    };\n\n    Highcharts.PlotLineOrBand.prototype = {\n\n        /**\n         * Render the plot line or plot band. If it is already existing,\n         * move it.\n         */\n        render: function () {\n            var plotLine = this,\n                axis = plotLine.axis,\n                horiz = axis.horiz,\n                options = plotLine.options,\n                optionsLabel = options.label,\n                label = plotLine.label,\n                width = options.width,\n                to = options.to,\n                from = options.from,\n                isBand = defined(from) && defined(to),\n                value = options.value,\n                dashStyle = options.dashStyle,\n                svgElem = plotLine.svgElem,\n                path = [],\n                addEvent,\n                eventType,\n                color = options.color,\n                zIndex = pick(options.zIndex, 0),\n                events = options.events,\n                attribs = {},\n                renderer = axis.chart.renderer;\n\n            // logarithmic conversion\n            if (axis.isLog) {\n                from = log2lin(from);\n                to = log2lin(to);\n                value = log2lin(value);\n            }\n\n            // plot line\n            if (width) {\n                path = axis.getPlotLinePath(value, width);\n                attribs = {\n                    stroke: color,\n                    'stroke-width': width\n                };\n                if (dashStyle) {\n                    attribs.dashstyle = dashStyle;\n                }\n            } else if (isBand) { // plot band\n\n                path = axis.getPlotBandPath(from, to, options);\n                if (color) {\n                    attribs.fill = color;\n                }\n                if (options.borderWidth) {\n                    attribs.stroke = options.borderColor;\n                    attribs['stroke-width'] = options.borderWidth;\n                }\n            } else {\n                return;\n            }\n            // zIndex\n            attribs.zIndex = zIndex;\n\n            // common for lines and bands\n            if (svgElem) {\n                if (path) {\n                    svgElem.show();\n                    svgElem.animate({ d: path });\n                } else {\n                    svgElem.hide();\n                    if (label) {\n                        plotLine.label = label = label.destroy();\n                    }\n                }\n            } else if (path && path.length) {\n                plotLine.svgElem = svgElem = renderer.path(path)\n                    .attr(attribs).add();\n\n                // events\n                if (events) {\n                    addEvent = function (eventType) {\n                        svgElem.on(eventType, function (e) {\n                            events[eventType].apply(plotLine, [e]);\n                        });\n                    };\n                    for (eventType in events) {\n                        addEvent(eventType);\n                    }\n                }\n            }\n\n            // the plot band/line label\n            if (optionsLabel && defined(optionsLabel.text) && path && path.length && \n                    axis.width > 0 && axis.height > 0 && !path.flat) {\n                // apply defaults\n                optionsLabel = merge({\n                    align: horiz && isBand && 'center',\n                    x: horiz ? !isBand && 4 : 10,\n                    verticalAlign: !horiz && isBand && 'middle',\n                    y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,\n                    rotation: horiz && !isBand && 90\n                }, optionsLabel);\n\n                this.renderLabel(optionsLabel, path, isBand, zIndex);\n\n            } else if (label) { // move out of sight\n                label.hide();\n            }\n\n            // chainable\n            return plotLine;\n        },\n\n        /**\n         * Render and align label for plot line or band.\n         */\n        renderLabel: function (optionsLabel, path, isBand, zIndex) {\n            var plotLine = this,\n                label = plotLine.label,\n                renderer = plotLine.axis.chart.renderer,\n                attribs,\n                xs,\n                ys,\n                x,\n                y;\n\n            // add the SVG element\n            if (!label) {\n                attribs = {\n                    align: optionsLabel.textAlign || optionsLabel.align,\n                    rotation: optionsLabel.rotation\n                };\n            \n                attribs.zIndex = zIndex;\n            \n                plotLine.label = label = renderer.text(\n                        optionsLabel.text,\n                        0,\n                        0,\n                        optionsLabel.useHTML\n                    )\n                    .attr(attribs)\n                    .css(optionsLabel.style)\n                    .add();\n            }\n\n            // get the bounding box and align the label\n            // #3000 changed to better handle choice between plotband or plotline\n            xs = [path[1], path[4], (isBand ? path[6] : path[1])];\n            ys = [path[2], path[5], (isBand ? path[7] : path[2])];\n            x = arrayMin(xs);\n            y = arrayMin(ys);\n\n            label.align(optionsLabel, false, {\n                x: x,\n                y: y,\n                width: arrayMax(xs) - x,\n                height: arrayMax(ys) - y\n            });\n            label.show();\n        },\n\n        /**\n         * Remove the plot line or band\n         */\n        destroy: function () {\n            // remove it from the lookup\n            erase(this.axis.plotLinesAndBands, this);\n\n            delete this.axis;\n            destroyObjectProperties(this);\n        }\n    };\n\n    /**\n     * Object with members for extending the Axis prototype\n     */\n\n    AxisPlotLineOrBandExtension = {\n\n        /**\n         * Create the path for a plot band\n         */\n        getPlotBandPath: function (from, to) {\n            var toPath = this.getPlotLinePath(to, null, null, true),\n                path = this.getPlotLinePath(from, null, null, true);\n\n            if (path && toPath) {\n\n                // Flat paths don't need labels (#3836)\n                path.flat = path.toString() === toPath.toString();\n\n                path.push(\n                    toPath[4],\n                    toPath[5],\n                    toPath[1],\n                    toPath[2]\n                );\n            } else { // outside the axis area\n                path = null;\n            }\n\n            return path;\n        },\n\n        addPlotBand: function (options) {\n            return this.addPlotBandOrLine(options, 'plotBands');\n        },\n\n        addPlotLine: function (options) {\n            return this.addPlotBandOrLine(options, 'plotLines');\n        },\n\n        /**\n         * Add a plot band or plot line after render time\n         *\n         * @param options {Object} The plotBand or plotLine configuration object\n         */\n        addPlotBandOrLine: function (options, coll) {\n            var obj = new Highcharts.PlotLineOrBand(this, options).render(),\n                userOptions = this.userOptions;\n\n            if (obj) { // #2189\n                // Add it to the user options for exporting and Axis.update\n                if (coll) {\n                    userOptions[coll] = userOptions[coll] || [];\n                    userOptions[coll].push(options);\n                }\n                this.plotLinesAndBands.push(obj);\n            }\n\n            return obj;\n        },\n\n        /**\n         * Remove a plot band or plot line from the chart by id\n         * @param {Object} id\n         */\n        removePlotBandOrLine: function (id) {\n            var plotLinesAndBands = this.plotLinesAndBands,\n                options = this.options,\n                userOptions = this.userOptions,\n                i = plotLinesAndBands.length;\n            while (i--) {\n                if (plotLinesAndBands[i].id === id) {\n                    plotLinesAndBands[i].destroy();\n                }\n            }\n            each([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {\n                i = arr.length;\n                while (i--) {\n                    if (arr[i].id === id) {\n                        erase(arr, arr[i]);\n                    }\n                }\n            });\n        }\n    };\n\n    /**\n     * Create a new axis object\n     * @param {Object} chart\n     * @param {Object} options\n     */\n    var Axis = Highcharts.Axis = function () {\n        this.init.apply(this, arguments);\n    };\n\n    Axis.prototype = {\n\n        /**\n         * Default options for the X axis - the Y axis has extended defaults\n         */\n        defaultOptions: {\n            // allowDecimals: null,\n            // alternateGridColor: null,\n            // categories: [],\n            dateTimeLabelFormats: {\n                millisecond: '%H:%M:%S.%L',\n                second: '%H:%M:%S',\n                minute: '%H:%M',\n                hour: '%H:%M',\n                day: '%e. %b',\n                week: '%e. %b',\n                month: '%b \\'%y',\n                year: '%Y'\n            },\n            endOnTick: false,\n            gridLineColor: '#D8D8D8',\n            // gridLineDashStyle: 'solid',\n            // gridLineWidth: 0,\n            // reversed: false,\n\n            labels: {\n                enabled: true,\n                // rotation: 0,\n                // align: 'center',\n                // step: null,\n                style: {\n                    color: '#606060',\n                    cursor: 'default',\n                    fontSize: '11px'\n                },\n                x: 0,\n                y: 15\n                /*formatter: function () {\n                    return this.value;\n                },*/\n            },\n            lineColor: '#C0D0E0',\n            lineWidth: 1,\n            //linkedTo: null,\n            //max: undefined,\n            //min: undefined,\n            minPadding: 0.01,\n            maxPadding: 0.01,\n            //minRange: null,\n            minorGridLineColor: '#E0E0E0',\n            // minorGridLineDashStyle: null,\n            minorGridLineWidth: 1,\n            minorTickColor: '#A0A0A0',\n            //minorTickInterval: null,\n            minorTickLength: 2,\n            minorTickPosition: 'outside', // inside or outside\n            //minorTickWidth: 0,\n            //opposite: false,\n            //offset: 0,\n            //plotBands: [{\n            //    events: {},\n            //    zIndex: 1,\n            //    labels: { align, x, verticalAlign, y, style, rotation, textAlign }\n            //}],\n            //plotLines: [{\n            //    events: {}\n            //  dashStyle: {}\n            //    zIndex:\n            //    labels: { align, x, verticalAlign, y, style, rotation, textAlign }\n            //}],\n            //reversed: false,\n            // showFirstLabel: true,\n            // showLastLabel: true,\n            startOfWeek: 1,\n            startOnTick: false,\n            tickColor: '#C0D0E0',\n            //tickInterval: null,\n            tickLength: 10,\n            tickmarkPlacement: 'between', // on or between\n            tickPixelInterval: 100,\n            tickPosition: 'outside',\n            //tickWidth: 1,\n            title: {\n                //text: null,\n                align: 'middle', // low, middle or high\n                //margin: 0 for horizontal, 10 for vertical axes,\n                //rotation: 0,\n                //side: 'outside',\n                style: {\n                    color: '#707070'\n                }\n                //x: 0,\n                //y: 0\n            },\n            type: 'linear' // linear, logarithmic or datetime\n            //visible: true\n        },\n\n        /**\n         * This options set extends the defaultOptions for Y axes\n         */\n        defaultYAxisOptions: {\n            endOnTick: true,\n            gridLineWidth: 1,\n            tickPixelInterval: 72,\n            showLastLabel: true,\n            labels: {\n                x: -8,\n                y: 3\n            },\n            lineWidth: 0,\n            maxPadding: 0.05,\n            minPadding: 0.05,\n            startOnTick: true,\n            //tickWidth: 0,\n            title: {\n                rotation: 270,\n                text: 'Values'\n            },\n            stackLabels: {\n                enabled: false,\n                //align: dynamic,\n                //y: dynamic,\n                //x: dynamic,\n                //verticalAlign: dynamic,\n                //textAlign: dynamic,\n                //rotation: 0,\n                formatter: function () {\n                    return Highcharts.numberFormat(this.total, -1);\n                },\n                style: merge(defaultPlotOptions.line.dataLabels.style, { color: '#000000' })\n            }\n        },\n\n        /**\n         * These options extend the defaultOptions for left axes\n         */\n        defaultLeftAxisOptions: {\n            labels: {\n                x: -15,\n                y: null\n            },\n            title: {\n                rotation: 270\n            }\n        },\n\n        /**\n         * These options extend the defaultOptions for right axes\n         */\n        defaultRightAxisOptions: {\n            labels: {\n                x: 15,\n                y: null\n            },\n            title: {\n                rotation: 90\n            }\n        },\n\n        /**\n         * These options extend the defaultOptions for bottom axes\n         */\n        defaultBottomAxisOptions: {\n            labels: {\n                autoRotation: [-45],\n                x: 0,\n                y: null // based on font size\n                // overflow: undefined,\n                // staggerLines: null\n            },\n            title: {\n                rotation: 0\n            }\n        },\n        /**\n         * These options extend the defaultOptions for top axes\n         */\n        defaultTopAxisOptions: {\n            labels: {\n                autoRotation: [-45],\n                x: 0,\n                y: -15\n                // overflow: undefined\n                // staggerLines: null\n            },\n            title: {\n                rotation: 0\n            }\n        },\n\n        /**\n         * Initialize the axis\n         */\n        init: function (chart, userOptions) {\n\n\n            var isXAxis = userOptions.isX,\n                axis = this;\n\n            axis.chart = chart;\n\n            // Flag, is the axis horizontal\n            axis.horiz = chart.inverted ? !isXAxis : isXAxis;\n\n            // Flag, isXAxis\n            axis.isXAxis = isXAxis;\n            axis.coll = isXAxis ? 'xAxis' : 'yAxis';\n\n            axis.opposite = userOptions.opposite; // needed in setOptions\n            axis.side = userOptions.side || (axis.horiz ?\n                    (axis.opposite ? 0 : 2) : // top : bottom\n                    (axis.opposite ? 1 : 3));  // right : left\n\n            axis.setOptions(userOptions);\n\n\n            var options = this.options,\n                type = options.type,\n                isDatetimeAxis = type === 'datetime';\n\n            axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format\n\n\n            // Flag, stagger lines or not\n            axis.userOptions = userOptions;\n\n            //axis.axisTitleMargin = UNDEFINED,// = options.title.margin,\n            axis.minPixelPadding = 0;\n\n            axis.reversed = options.reversed;\n            axis.visible = options.visible !== false;\n            axis.zoomEnabled = options.zoomEnabled !== false;\n\n            // Initial categories\n            axis.categories = options.categories || type === 'category';\n            axis.names = axis.names || []; // Preserve on update (#3830)\n\n            // Elements\n            //axis.axisGroup = UNDEFINED;\n            //axis.gridGroup = UNDEFINED;\n            //axis.axisTitle = UNDEFINED;\n            //axis.axisLine = UNDEFINED;\n\n            // Shorthand types\n            axis.isLog = type === 'logarithmic';\n            axis.isDatetimeAxis = isDatetimeAxis;\n\n            // Flag, if axis is linked to another axis\n            axis.isLinked = defined(options.linkedTo);\n            // Linked axis.\n            //axis.linkedParent = UNDEFINED;\n\n            // Tick positions\n            //axis.tickPositions = UNDEFINED; // array containing predefined positions\n            // Tick intervals\n            //axis.tickInterval = UNDEFINED;\n            //axis.minorTickInterval = UNDEFINED;\n\n\n            // Major ticks\n            axis.ticks = {};\n            axis.labelEdge = [];\n            // Minor ticks\n            axis.minorTicks = {};\n\n            // List of plotLines/Bands\n            axis.plotLinesAndBands = [];\n\n            // Alternate bands\n            axis.alternateBands = {};\n\n            // Axis metrics\n            //axis.left = UNDEFINED;\n            //axis.top = UNDEFINED;\n            //axis.width = UNDEFINED;\n            //axis.height = UNDEFINED;\n            //axis.bottom = UNDEFINED;\n            //axis.right = UNDEFINED;\n            //axis.transA = UNDEFINED;\n            //axis.transB = UNDEFINED;\n            //axis.oldTransA = UNDEFINED;\n            axis.len = 0;\n            //axis.oldMin = UNDEFINED;\n            //axis.oldMax = UNDEFINED;\n            //axis.oldUserMin = UNDEFINED;\n            //axis.oldUserMax = UNDEFINED;\n            //axis.oldAxisLength = UNDEFINED;\n            axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;\n            axis.range = options.range;\n            axis.offset = options.offset || 0;\n\n\n            // Dictionary for stacks\n            axis.stacks = {};\n            axis.oldStacks = {};\n            axis.stacksTouched = 0;\n\n            // Min and max in the data\n            //axis.dataMin = UNDEFINED,\n            //axis.dataMax = UNDEFINED,\n\n            // The axis range\n            axis.max = null;\n            axis.min = null;\n\n            // User set min and max\n            //axis.userMin = UNDEFINED,\n            //axis.userMax = UNDEFINED,\n\n            // Crosshair options\n            axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);\n            // Run Axis\n\n            var eventType,\n                events = axis.options.events;\n\n            // Register\n            if (inArray(axis, chart.axes) === -1) { // don't add it again on Axis.update()\n                if (isXAxis && !this.isColorAxis) { // #2713\n                    chart.axes.splice(chart.xAxis.length, 0, axis);\n                } else {\n                    chart.axes.push(axis);\n                }\n\n                chart[axis.coll].push(axis);\n            }\n\n            axis.series = axis.series || []; // populated by Series\n\n            // inverted charts have reversed xAxes as default\n            if (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {\n                axis.reversed = true;\n            }\n\n            axis.removePlotBand = axis.removePlotBandOrLine;\n            axis.removePlotLine = axis.removePlotBandOrLine;\n\n\n            // register event listeners\n            for (eventType in events) {\n                addEvent(axis, eventType, events[eventType]);\n            }\n\n            // extend logarithmic axis\n            if (axis.isLog) {\n                axis.val2lin = log2lin;\n                axis.lin2val = lin2log;\n            }\n        },\n\n        /**\n         * Merge and set options\n         */\n        setOptions: function (userOptions) {\n            this.options = merge(\n                this.defaultOptions,\n                this.isXAxis ? {} : this.defaultYAxisOptions,\n                [this.defaultTopAxisOptions, this.defaultRightAxisOptions,\n                    this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],\n                merge(\n                    defaultOptions[this.coll], // if set in setOptions (#1053)\n                    userOptions\n                )\n            );\n        },\n\n        /**\n         * The default label formatter. The context is a special config object for the label.\n         */\n        defaultLabelFormatter: function () {\n            var axis = this.axis,\n                value = this.value,\n                categories = axis.categories,\n                dateTimeLabelFormat = this.dateTimeLabelFormat,\n                numericSymbols = defaultOptions.lang.numericSymbols,\n                i = numericSymbols && numericSymbols.length,\n                multi,\n                ret,\n                formatOption = axis.options.labels.format,\n\n                // make sure the same symbol is added for all labels on a linear axis\n                numericSymbolDetector = axis.isLog ? value : axis.tickInterval;\n\n            if (formatOption) {\n                ret = format(formatOption, this);\n\n            } else if (categories) {\n                ret = value;\n\n            } else if (dateTimeLabelFormat) { // datetime axis\n                ret = dateFormat(dateTimeLabelFormat, value);\n\n            } else if (i && numericSymbolDetector >= 1000) {\n                // Decide whether we should add a numeric symbol like k (thousands) or M (millions).\n                // If we are to enable this in tooltip or other places as well, we can move this\n                // logic to the numberFormatter and enable it by a parameter.\n                while (i-- && ret === UNDEFINED) {\n                    multi = Math.pow(1000, i + 1);\n                    if (numericSymbolDetector >= multi && (value * 10) % multi === 0 && numericSymbols[i] !== null) {\n                        ret = Highcharts.numberFormat(value / multi, -1) + numericSymbols[i];\n                    }\n                }\n            }\n\n            if (ret === UNDEFINED) {\n                if (mathAbs(value) >= 10000) { // add thousands separators\n                    ret = Highcharts.numberFormat(value, -1);\n\n                } else { // small numbers\n                    ret = Highcharts.numberFormat(value, -1, UNDEFINED, ''); // #2466\n                }\n            }\n\n            return ret;\n        },\n\n        /**\n         * Get the minimum and maximum for the series of each axis\n         */\n        getSeriesExtremes: function () {\n            var axis = this,\n                chart = axis.chart;\n\n            axis.hasVisibleSeries = false;\n\n            // Reset properties in case we're redrawing (#3353)\n            axis.dataMin = axis.dataMax = axis.threshold = null;\n            axis.softThreshold = !axis.isXAxis;\n\n            if (axis.buildStacks) {\n                axis.buildStacks();\n            }\n\n            // loop through this axis' series\n            each(axis.series, function (series) {\n\n                if (series.visible || !chart.options.chart.ignoreHiddenSeries) {\n\n                    var seriesOptions = series.options,\n                        xData,\n                        threshold = seriesOptions.threshold,\n                        seriesDataMin,\n                        seriesDataMax;\n\n                    axis.hasVisibleSeries = true;\n\n                    // Validate threshold in logarithmic axes\n                    if (axis.isLog && threshold <= 0) {\n                        threshold = null;\n                    }\n\n                    // Get dataMin and dataMax for X axes\n                    if (axis.isXAxis) {\n                        xData = series.xData;\n                        if (xData.length) {\n                            axis.dataMin = mathMin(pick(axis.dataMin, xData[0]), arrayMin(xData));\n                            axis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));\n                        }\n\n                    // Get dataMin and dataMax for Y axes, as well as handle stacking and processed data\n                    } else {\n\n                        // Get this particular series extremes\n                        series.getExtremes();\n                        seriesDataMax = series.dataMax;\n                        seriesDataMin = series.dataMin;\n\n                        // Get the dataMin and dataMax so far. If percentage is used, the min and max are\n                        // always 0 and 100. If seriesDataMin and seriesDataMax is null, then series\n                        // doesn't have active y data, we continue with nulls\n                        if (defined(seriesDataMin) && defined(seriesDataMax)) {\n                            axis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);\n                            axis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);\n                        }\n\n                        // Adjust to threshold\n                        if (defined(threshold)) {\n                            axis.threshold = threshold;\n                        }\n                        // If any series has a hard threshold, it takes precedence\n                        if (!seriesOptions.softThreshold || axis.isLog) {\n                            axis.softThreshold = false;\n                        }\n                    }\n                }\n            });\n        },\n\n        /**\n         * Translate from axis value to pixel position on the chart, or back\n         *\n         */\n        translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {\n            var axis = this.linkedParent || this, // #1417\n                sign = 1,\n                cvsOffset = 0,\n                localA = old ? axis.oldTransA : axis.transA,\n                localMin = old ? axis.oldMin : axis.min,\n                returnValue,\n                minPixelPadding = axis.minPixelPadding,\n                doPostTranslate = (axis.isOrdinal || axis.isBroken || (axis.isLog && handleLog)) && axis.lin2val;\n\n            if (!localA) {\n                localA = axis.transA;\n            }\n\n            // In vertical axes, the canvas coordinates start from 0 at the top like in\n            // SVG.\n            if (cvsCoord) {\n                sign *= -1; // canvas coordinates inverts the value\n                cvsOffset = axis.len;\n            }\n\n            // Handle reversed axis\n            if (axis.reversed) {\n                sign *= -1;\n                cvsOffset -= sign * (axis.sector || axis.len);\n            }\n\n            // From pixels to value\n            if (backwards) { // reverse translation\n\n                val = val * sign + cvsOffset;\n                val -= minPixelPadding;\n                returnValue = val / localA + localMin; // from chart pixel to value\n                if (doPostTranslate) { // log and ordinal axes\n                    returnValue = axis.lin2val(returnValue);\n                }\n\n            // From value to pixels\n            } else {\n                if (doPostTranslate) { // log and ordinal axes\n                    val = axis.val2lin(val);\n                }\n                if (pointPlacement === 'between') {\n                    pointPlacement = 0.5;\n                }\n                returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +\n                    (isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);\n            }\n\n            return returnValue;\n        },\n\n        /**\n         * Utility method to translate an axis value to pixel position.\n         * @param {Number} value A value in terms of axis units\n         * @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart\n         *        or just the axis/pane itself.\n         */\n        toPixels: function (value, paneCoordinates) {\n            return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);\n        },\n\n        /*\n         * Utility method to translate a pixel position in to an axis value\n         * @param {Number} pixel The pixel value coordinate\n         * @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the\n         *        axis/pane itself.\n         */\n        toValue: function (pixel, paneCoordinates) {\n            return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);\n        },\n\n        /**\n         * Create the path for a plot line that goes from the given value on\n         * this axis, across the plot to the opposite side\n         * @param {Number} value\n         * @param {Number} lineWidth Used for calculation crisp line\n         * @param {Number] old Use old coordinates (for resizing and rescaling)\n         */\n        getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {\n            var axis = this,\n                chart = axis.chart,\n                axisLeft = axis.left,\n                axisTop = axis.top,\n                x1,\n                y1,\n                x2,\n                y2,\n                cHeight = (old && chart.oldChartHeight) || chart.chartHeight,\n                cWidth = (old && chart.oldChartWidth) || chart.chartWidth,\n                skip,\n                transB = axis.transB,\n                /**\n                 * Check if x is between a and b. If not, either move to a/b or skip,\n                 * depending on the force parameter.\n                 */\n                between = function (x, a, b) {\n                    if (x < a || x > b) {\n                        if (force) {\n                            x = mathMin(mathMax(a, x), b);\n                        } else {\n                            skip = true;\n                        }\n                    }\n                    return x;\n                };\n\n            translatedValue = pick(translatedValue, axis.translate(value, null, null, old));\n            x1 = x2 = mathRound(translatedValue + transB);\n            y1 = y2 = mathRound(cHeight - translatedValue - transB);\n\n            if (isNaN(translatedValue)) { // no min or max\n                skip = true;\n\n            } else if (axis.horiz) {\n                y1 = axisTop;\n                y2 = cHeight - axis.bottom;\n                x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);\n            } else {\n                x1 = axisLeft;\n                x2 = cWidth - axis.right;\n                y1 = y2 = between(y1, axisTop, axisTop + axis.height);\n            }\n            return skip && !force ?\n                null :\n                chart.renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 1);\n        },\n\n        /**\n         * Set the tick positions of a linear axis to round values like whole tens or every five.\n         */\n        getLinearTickPositions: function (tickInterval, min, max) {\n            var pos,\n                lastPos,\n                roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),\n                roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),\n                tickPositions = [];\n\n            // For single points, add a tick regardless of the relative position (#2662)\n            if (min === max && isNumber(min)) {\n                return [min];\n            }\n\n            // Populate the intermediate values\n            pos = roundedMin;\n            while (pos <= roundedMax) {\n\n                // Place the tick on the rounded value\n                tickPositions.push(pos);\n\n                // Always add the raw tickInterval, not the corrected one.\n                pos = correctFloat(pos + tickInterval);\n\n                // If the interval is not big enough in the current min - max range to actually increase\n                // the loop variable, we need to break out to prevent endless loop. Issue #619\n                if (pos === lastPos) {\n                    break;\n                }\n\n                // Record the last value\n                lastPos = pos;\n            }\n            return tickPositions;\n        },\n\n        /**\n         * Return the minor tick positions. For logarithmic axes, reuse the same logic\n         * as for major ticks.\n         */\n        getMinorTickPositions: function () {\n            var axis = this,\n                options = axis.options,\n                tickPositions = axis.tickPositions,\n                minorTickInterval = axis.minorTickInterval,\n                minorTickPositions = [],\n                pos,\n                i,\n                pointRangePadding = axis.pointRangePadding || 0,\n                min = axis.min - pointRangePadding, // #1498\n                max = axis.max + pointRangePadding, // #1498\n                range = max - min,\n                len;\n\n            // If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.\n            if (range && range / minorTickInterval < axis.len / 3) { // #3875\n\n                if (axis.isLog) {\n                    len = tickPositions.length;\n                    for (i = 1; i < len; i++) {\n                        minorTickPositions = minorTickPositions.concat(\n                            axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)\n                        );\n                    }\n                } else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314\n                    minorTickPositions = minorTickPositions.concat(\n                        axis.getTimeTicks(\n                            axis.normalizeTimeTickInterval(minorTickInterval),\n                            min,\n                            max,\n                            options.startOfWeek\n                        )\n                    );\n                } else {\n                    for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {\n                        minorTickPositions.push(pos);\n                    }\n                }\n            }\n\n            if (minorTickPositions.length !== 0) { // don't change the extremes, when there is no minor ticks\n                axis.trimTicks(minorTickPositions, options.startOnTick, options.endOnTick); // #3652 #3743 #1498\n            }\n            return minorTickPositions;\n        },\n\n        /**\n         * Adjust the min and max for the minimum range. Keep in mind that the series data is\n         * not yet processed, so we don't have information on data cropping and grouping, or\n         * updated axis.pointRange or series.pointRange. The data can't be processed until\n         * we have finally established min and max.\n         */\n        adjustForMinRange: function () {\n            var axis = this,\n                options = axis.options,\n                min = axis.min,\n                max = axis.max,\n                zoomOffset,\n                spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,\n                closestDataRange,\n                i,\n                distance,\n                xData,\n                loopLength,\n                minArgs,\n                maxArgs,\n                minRange;\n\n            // Set the automatic minimum range based on the closest point distance\n            if (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {\n\n                if (defined(options.min) || defined(options.max)) {\n                    axis.minRange = null; // don't do this again\n\n                } else {\n\n                    // Find the closest distance between raw data points, as opposed to\n                    // closestPointRange that applies to processed points (cropped and grouped)\n                    each(axis.series, function (series) {\n                        xData = series.xData;\n                        loopLength = series.xIncrement ? 1 : xData.length - 1;\n                        for (i = loopLength; i > 0; i--) {\n                            distance = xData[i] - xData[i - 1];\n                            if (closestDataRange === UNDEFINED || distance < closestDataRange) {\n                                closestDataRange = distance;\n                            }\n                        }\n                    });\n                    axis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);\n                }\n            }\n\n            // if minRange is exceeded, adjust\n            if (max - min < axis.minRange) {\n                minRange = axis.minRange;\n                zoomOffset = (minRange - max + min) / 2;\n\n                // if min and max options have been set, don't go beyond it\n                minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];\n                if (spaceAvailable) { // if space is available, stay within the data range\n                    minArgs[2] = axis.dataMin;\n                }\n                min = arrayMax(minArgs);\n\n                maxArgs = [min + minRange, pick(options.max, min + minRange)];\n                if (spaceAvailable) { // if space is availabe, stay within the data range\n                    maxArgs[2] = axis.dataMax;\n                }\n\n                max = arrayMin(maxArgs);\n\n                // now if the max is adjusted, adjust the min back\n                if (max - min < minRange) {\n                    minArgs[0] = max - minRange;\n                    minArgs[1] = pick(options.min, max - minRange);\n                    min = arrayMax(minArgs);\n                }\n            }\n\n            // Record modified extremes\n            axis.min = min;\n            axis.max = max;\n        },\n\n        /**\n         * Update translation information\n         */\n        setAxisTranslation: function (saveOld) {\n            var axis = this,\n                range = axis.max - axis.min,\n                pointRange = axis.axisPointRange || 0,\n                closestPointRange,\n                minPointOffset = 0,\n                pointRangePadding = 0,\n                linkedParent = axis.linkedParent,\n                ordinalCorrection,\n                hasCategories = !!axis.categories,\n                transA = axis.transA,\n                isXAxis = axis.isXAxis;\n\n            // Adjust translation for padding. Y axis with categories need to go through the same (#1784).\n            if (isXAxis || hasCategories || pointRange) {\n                if (linkedParent) {\n                    minPointOffset = linkedParent.minPointOffset;\n                    pointRangePadding = linkedParent.pointRangePadding;\n\n                } else {\n                    // Find the closestPointRange across all series\n                    each(axis.series, function (series) {\n                        var seriesClosest = series.closestPointRange;\n                        if (!series.noSharedTooltip && defined(seriesClosest)) {\n                            closestPointRange = defined(closestPointRange) ?\n                                mathMin(closestPointRange, seriesClosest) :\n                                seriesClosest;\n                        }\n                    });\n\n                    each(axis.series, function (series) {\n                        var seriesPointRange = hasCategories ? \n                            1 : \n                            (isXAxis ? \n                                pick(series.options.pointRange, closestPointRange, 0) : \n                                (axis.axisPointRange || 0)), // #2806\n                            pointPlacement = series.options.pointPlacement;\n\n                        pointRange = mathMax(pointRange, seriesPointRange);\n\n                        if (!axis.single) {\n                            // minPointOffset is the value padding to the left of the axis in order to make\n                            // room for points with a pointRange, typically columns. When the pointPlacement option\n                            // is 'between' or 'on', this padding does not apply.\n                            minPointOffset = mathMax(\n                                minPointOffset,\n                                isString(pointPlacement) ? 0 : seriesPointRange / 2\n                            );\n\n                            // Determine the total padding needed to the length of the axis to make room for the\n                            // pointRange. If the series' pointPlacement is 'on', no padding is added.\n                            pointRangePadding = mathMax(\n                                pointRangePadding,\n                                pointPlacement === 'on' ? 0 : seriesPointRange\n                            );\n                        }\n                    });\n                }\n\n                // Record minPointOffset and pointRangePadding\n                ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853\n                axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;\n                axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;\n\n                // pointRange means the width reserved for each point, like in a column chart\n                axis.pointRange = mathMin(pointRange, range);\n\n                // closestPointRange means the closest distance between points. In columns\n                // it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange\n                // is some other value\n                if (isXAxis) {\n                    axis.closestPointRange = closestPointRange;\n                }\n            }\n\n            // Secondary values\n            if (saveOld) {\n                axis.oldTransA = transA;\n            }\n            axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);\n            axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend\n            axis.minPixelPadding = transA * minPointOffset;\n        },\n\n        minFromRange: function () {\n            return this.max - this.range;\n        },\n\n        /**\n         * Set the tick positions to round values and optionally extend the extremes\n         * to the nearest tick\n         */\n        setTickInterval: function (secondPass) {\n            var axis = this,\n                chart = axis.chart,\n                options = axis.options,\n                isLog = axis.isLog,\n                isDatetimeAxis = axis.isDatetimeAxis,\n                isXAxis = axis.isXAxis,\n                isLinked = axis.isLinked,\n                maxPadding = options.maxPadding,\n                minPadding = options.minPadding,\n                length,\n                linkedParentExtremes,\n                tickIntervalOption = options.tickInterval,\n                minTickInterval,\n                tickPixelIntervalOption = options.tickPixelInterval,\n                categories = axis.categories,\n                threshold = axis.threshold,\n                softThreshold = axis.softThreshold,\n                thresholdMin,\n                thresholdMax,\n                hardMin,\n                hardMax;\n\n            if (!isDatetimeAxis && !categories && !isLinked) {\n                this.getTickAmount();\n            }\n\n            // Min or max set either by zooming/setExtremes or initial options\n            hardMin = pick(axis.userMin, options.min);\n            hardMax = pick(axis.userMax, options.max);\n\n            // Linked axis gets the extremes from the parent axis\n            if (isLinked) {\n                axis.linkedParent = chart[axis.coll][options.linkedTo];\n                linkedParentExtremes = axis.linkedParent.getExtremes();\n                axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);\n                axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);\n                if (options.type !== axis.linkedParent.options.type) {\n                    error(11, 1); // Can't link axes of different type\n                }\n\n            // Initial min and max from the extreme data values\n            } else {\n\n                // Adjust to hard threshold\n                if (!softThreshold && defined(threshold)) {\n                    if (axis.dataMin >= threshold) {\n                        thresholdMin = threshold;\n                        minPadding = 0;\n                    } else if (axis.dataMax <= threshold) {\n                        thresholdMax = threshold;\n                        maxPadding = 0;\n                    }\n                }\n\n                axis.min = pick(hardMin, thresholdMin, axis.dataMin);\n                axis.max = pick(hardMax, thresholdMax, axis.dataMax);\n\n            }\n\n            if (isLog) {\n                if (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978\n                    error(10, 1); // Can't plot negative values on log axis\n                }\n                // The correctFloat cures #934, float errors on full tens. But it\n                // was too aggressive for #4360 because of conversion back to lin,\n                // therefore use precision 15.\n                axis.min = correctFloat(log2lin(axis.min), 15);\n                axis.max = correctFloat(log2lin(axis.max), 15);\n            }\n\n            // handle zoomed range\n            if (axis.range && defined(axis.max)) {\n                axis.userMin = axis.min = hardMin = mathMax(axis.min, axis.minFromRange()); // #618\n                axis.userMax = hardMax = axis.max;\n\n                axis.range = null;  // don't use it when running setExtremes\n            }\n\n            // Hook for adjusting this.min and this.max. Used by bubble series.\n            if (axis.beforePadding) {\n                axis.beforePadding();\n            }\n\n            // adjust min and max for the minimum range\n            axis.adjustForMinRange();\n\n            // Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding\n            // into account, we do this after computing tick interval (#1337).\n            if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {\n                length = axis.max - axis.min;\n                if (length) {\n                    if (!defined(hardMin) && minPadding) {\n                        axis.min -= length * minPadding;\n                    }\n                    if (!defined(hardMax)  && maxPadding) {\n                        axis.max += length * maxPadding;\n                    }\n                }\n            }\n\n            // Stay within floor and ceiling\n            if (isNumber(options.floor)) {\n                axis.min = mathMax(axis.min, options.floor);\n            }\n            if (isNumber(options.ceiling)) {\n                axis.max = mathMin(axis.max, options.ceiling);\n            }\n\n            // When the threshold is soft, adjust the extreme value only if\n            // the data extreme and the padded extreme land on either side of the threshold. For example,\n            // a series of [0, 1, 2, 3] would make the yAxis add a tick for -1 because of the\n            // default minPadding and startOnTick options. This is prevented by the softThreshold\n            // option.\n            if (softThreshold && defined(axis.dataMin)) {\n                threshold = threshold || 0;\n                if (!defined(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {\n                    axis.min = threshold;\n                } else if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {\n                    axis.max = threshold;\n                }\n            }\n\n\n            // get tickInterval\n            if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {\n                axis.tickInterval = 1;\n            } else if (isLinked && !tickIntervalOption &&\n                    tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {\n                axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;\n            } else {\n                axis.tickInterval = pick(\n                    tickIntervalOption,\n                    this.tickAmount ? ((axis.max - axis.min) / mathMax(this.tickAmount - 1, 1)) : undefined,\n                    categories ? // for categoried axis, 1 is default, for linear axis use tickPix\n                        1 :\n                        // don't let it be more than the data range\n                        (axis.max - axis.min) * tickPixelIntervalOption / mathMax(axis.len, tickPixelIntervalOption)\n                );\n            }\n\n            // Now we're finished detecting min and max, crop and group series data. This\n            // is in turn needed in order to find tick positions in ordinal axes.\n            if (isXAxis && !secondPass) {\n                each(axis.series, function (series) {\n                    series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);\n                });\n            }\n\n            // set the translation factor used in translate function\n            axis.setAxisTranslation(true);\n\n            // hook for ordinal axes and radial axes\n            if (axis.beforeSetTickPositions) {\n                axis.beforeSetTickPositions();\n            }\n\n            // hook for extensions, used in Highstock ordinal axes\n            if (axis.postProcessTickInterval) {\n                axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);\n            }\n\n            // In column-like charts, don't cramp in more ticks than there are points (#1943, #4184)\n            if (axis.pointRange && !tickIntervalOption) {\n                axis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);\n            }\n\n            // Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.\n            minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);\n            if (!tickIntervalOption && axis.tickInterval < minTickInterval) {\n                axis.tickInterval = minTickInterval;\n            }\n\n            // for linear axes, get magnitude and normalize the interval\n            if (!isDatetimeAxis && !isLog && !tickIntervalOption) {\n                axis.tickInterval = normalizeTickInterval(\n                    axis.tickInterval,\n                    null,\n                    getMagnitude(axis.tickInterval),\n                    // If the tick interval is between 0.5 and 5 and the axis max is in the order of\n                    // thousands, chances are we are dealing with years. Don't allow decimals. #3363.\n                    pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)),\n                    !!this.tickAmount\n                );\n            }\n\n            // Prevent ticks from getting so close that we can't draw the labels\n            if (!this.tickAmount && this.len) { // Color axis with disabled legend has no length\n                axis.tickInterval = axis.unsquish();\n            }\n\n            this.setTickPositions();\n        },\n\n        /**\n         * Now we have computed the normalized tickInterval, get the tick positions\n         */\n        setTickPositions: function () {\n\n            var options = this.options,\n                tickPositions,\n                tickPositionsOption = options.tickPositions,\n                tickPositioner = options.tickPositioner,\n                startOnTick = options.startOnTick,\n                endOnTick = options.endOnTick,\n                single;\n\n            // Set the tickmarkOffset\n            this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' &&\n                this.tickInterval === 1) ? 0.5 : 0; // #3202\n\n\n            // get minorTickInterval\n            this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?\n                this.tickInterval / 5 : options.minorTickInterval;\n\n            // Find the tick positions\n            this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice(); // Work on a copy (#1565)\n            if (!tickPositions) {\n\n                if (this.isDatetimeAxis) {\n                    tickPositions = this.getTimeTicks(\n                        this.normalizeTimeTickInterval(this.tickInterval, options.units),\n                        this.min,\n                        this.max,\n                        options.startOfWeek,\n                        this.ordinalPositions,\n                        this.closestPointRange,\n                        true\n                    );\n                } else if (this.isLog) {\n                    tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);\n                } else {\n                    tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);\n                }\n\n                // Too dense ticks, keep only the first and last (#4477)\n                if (tickPositions.length > this.len) {\n                    tickPositions = [tickPositions[0], tickPositions.pop()];\n                }\n\n                this.tickPositions = tickPositions;\n\n                // Run the tick positioner callback, that allows modifying auto tick positions.\n                if (tickPositioner) {\n                    tickPositioner = tickPositioner.apply(this, [this.min, this.max]);\n                    if (tickPositioner) {\n                        this.tickPositions = tickPositions = tickPositioner;\n                    }\n                }\n\n            }\n\n            if (!this.isLinked) {\n\n                // reset min/max or remove extremes based on start/end on tick\n                this.trimTicks(tickPositions, startOnTick, endOnTick);\n\n                // When there is only one point, or all points have the same value on this axis, then min\n                // and max are equal and tickPositions.length is 0 or 1. In this case, add some padding\n                // in order to center the point, but leave it with one tick. #1337.\n                if (this.min === this.max && defined(this.min) && !this.tickAmount) {\n                    // Substract half a unit (#2619, #2846, #2515, #3390)\n                    single = true;\n                    this.min -= 0.5;\n                    this.max += 0.5;\n                }\n                this.single = single;\n\n                if (!tickPositionsOption && !tickPositioner) {\n                    this.adjustTickAmount();\n                }\n            }\n        },\n\n        /**\n         * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max\n         */\n        trimTicks: function (tickPositions, startOnTick, endOnTick) {\n            var roundedMin = tickPositions[0],\n                roundedMax = tickPositions[tickPositions.length - 1],\n                minPointOffset = this.minPointOffset || 0;\n\n            if (startOnTick) {\n                this.min = roundedMin;\n            } else {\n                while (this.min - minPointOffset > tickPositions[0]) {\n                    tickPositions.shift();\n                }\n            }\n\n            if (endOnTick) {\n                this.max = roundedMax;\n            } else {\n                while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {\n                    tickPositions.pop();\n                }\n            }\n\n            // If no tick are left, set one tick in the middle (#3195)\n            if (tickPositions.length === 0 && defined(roundedMin)) {\n                tickPositions.push((roundedMax + roundedMin) / 2);\n            }\n        },\n\n        /**\n         * Check if there are multiple axes in the same pane\n         * @returns {Boolean} There are other axes\n         */\n        alignToOthers: function () {\n            var others = {}, // Whether there is another axis to pair with this one\n                hasOther,\n                options = this.options;\n\n            if (this.chart.options.chart.alignTicks !== false && options.alignTicks !== false) {\n                each(this.chart[this.coll], function (axis) {\n                    var otherOptions = axis.options,\n                        horiz = axis.horiz,\n                        key = [\n                            horiz ? otherOptions.left : otherOptions.top, \n                            otherOptions.width,\n                            otherOptions.height, \n                            otherOptions.pane\n                        ].join(',');\n\n\n                    if (axis.series.length) { // #4442\n                        if (others[key]) {\n                            hasOther = true; // #4201\n                        } else {\n                            others[key] = 1;\n                        }\n                    }\n                });\n            }\n            return hasOther;\n        },\n\n        /**\n         * Set the max ticks of either the x and y axis collection\n         */\n        getTickAmount: function () {\n            var options = this.options,\n                tickAmount = options.tickAmount,\n                tickPixelInterval = options.tickPixelInterval;\n\n            if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&\n                    !this.isLog && options.startOnTick && options.endOnTick) {\n                tickAmount = 2;\n            }\n\n            if (!tickAmount && this.alignToOthers()) {\n                // Add 1 because 4 tick intervals require 5 ticks (including first and last)\n                tickAmount = mathCeil(this.len / tickPixelInterval) + 1;\n            }\n\n            // For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This\n            // prevents the axis from adding ticks that are too far away from the data extremes.\n            if (tickAmount < 4) {\n                this.finalTickAmt = tickAmount;\n                tickAmount = 5;\n            }\n\n            this.tickAmount = tickAmount;\n        },\n\n        /**\n         * When using multiple axes, adjust the number of ticks to match the highest\n         * number of ticks in that group\n         */\n        adjustTickAmount: function () {\n            var tickInterval = this.tickInterval,\n                tickPositions = this.tickPositions,\n                tickAmount = this.tickAmount,\n                finalTickAmt = this.finalTickAmt,\n                currentTickAmount = tickPositions && tickPositions.length,\n                i,\n                len;\n\n            if (currentTickAmount < tickAmount) {\n                while (tickPositions.length < tickAmount) {\n                    tickPositions.push(correctFloat(\n                        tickPositions[tickPositions.length - 1] + tickInterval\n                    ));\n                }\n                this.transA *= (currentTickAmount - 1) / (tickAmount - 1);\n                this.max = tickPositions[tickPositions.length - 1];\n\n            // We have too many ticks, run second pass to try to reduce ticks\n            } else if (currentTickAmount > tickAmount) {\n                this.tickInterval *= 2;\n                this.setTickPositions();\n            }\n\n            // The finalTickAmt property is set in getTickAmount\n            if (defined(finalTickAmt)) {\n                i = len = tickPositions.length;\n                while (i--) {\n                    if (\n                        (finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick\n                        (finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last\n                    ) {\n                        tickPositions.splice(i, 1);\n                    }\n                }\n                this.finalTickAmt = UNDEFINED;\n            }\n        },\n\n        /**\n         * Set the scale based on data min and max, user set min and max or options\n         *\n         */\n        setScale: function () {\n            var axis = this,\n                isDirtyData,\n                isDirtyAxisLength;\n\n            axis.oldMin = axis.min;\n            axis.oldMax = axis.max;\n            axis.oldAxisLength = axis.len;\n\n            // set the new axisLength\n            axis.setAxisSize();\n            //axisLength = horiz ? axisWidth : axisHeight;\n            isDirtyAxisLength = axis.len !== axis.oldAxisLength;\n\n            // is there new data?\n            each(axis.series, function (series) {\n                if (series.isDirtyData || series.isDirty ||\n                        series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well\n                    isDirtyData = true;\n                }\n            });\n\n            // do we really need to go through all this?\n            if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||\n                axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax || axis.alignToOthers()) {\n\n                if (axis.resetStacks) {\n                    axis.resetStacks();\n                }\n\n                axis.forceRedraw = false;\n\n                // get data extremes if needed\n                axis.getSeriesExtremes();\n\n                // get fixed positions based on tickInterval\n                axis.setTickInterval();\n\n                // record old values to decide whether a rescale is necessary later on (#540)\n                axis.oldUserMin = axis.userMin;\n                axis.oldUserMax = axis.userMax;\n\n                // Mark as dirty if it is not already set to dirty and extremes have changed. #595.\n                if (!axis.isDirty) {\n                    axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;\n                }\n            } else if (axis.cleanStacks) {\n                axis.cleanStacks();\n            }\n        },\n\n        /**\n         * Set the extremes and optionally redraw\n         * @param {Number} newMin\n         * @param {Number} newMax\n         * @param {Boolean} redraw\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         * @param {Object} eventArguments\n         *\n         */\n        setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {\n            var axis = this,\n                chart = axis.chart;\n\n            redraw = pick(redraw, true); // defaults to true\n\n            each(axis.series, function (serie) {\n                delete serie.kdTree;\n            });\n\n            // Extend the arguments with min and max\n            eventArguments = extend(eventArguments, {\n                min: newMin,\n                max: newMax\n            });\n\n            // Fire the event\n            fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler\n\n                axis.userMin = newMin;\n                axis.userMax = newMax;\n                axis.eventArgs = eventArguments;\n\n                if (redraw) {\n                    chart.redraw(animation);\n                }\n            });\n        },\n\n        /**\n         * Overridable method for zooming chart. Pulled out in a separate method to allow overriding\n         * in stock charts.\n         */\n        zoom: function (newMin, newMax) {\n            var dataMin = this.dataMin,\n                dataMax = this.dataMax,\n                options = this.options,\n                min = mathMin(dataMin, pick(options.min, dataMin)),\n                max = mathMax(dataMax, pick(options.max, dataMax));\n\n            // Prevent pinch zooming out of range. Check for defined is for #1946. #1734.\n            if (!this.allowZoomOutside) {\n                if (defined(dataMin) && newMin <= min) {\n                    newMin = min;\n                }\n                if (defined(dataMax) && newMax >= max) {\n                    newMax = max;\n                }\n            }\n\n            // In full view, displaying the reset zoom button is not required\n            this.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;\n\n            // Do it\n            this.setExtremes(\n                newMin,\n                newMax,\n                false,\n                UNDEFINED,\n                { trigger: 'zoom' }\n            );\n            return true;\n        },\n\n        /**\n         * Update the axis metrics\n         */\n        setAxisSize: function () {\n            var chart = this.chart,\n                options = this.options,\n                offsetLeft = options.offsetLeft || 0,\n                offsetRight = options.offsetRight || 0,\n                horiz = this.horiz,\n                width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight),\n                height = pick(options.height, chart.plotHeight),\n                top = pick(options.top, chart.plotTop),\n                left = pick(options.left, chart.plotLeft + offsetLeft),\n                percentRegex = /%$/;\n\n            // Check for percentage based input values. Rounding fixes problems with\n            // column overflow and plot line filtering (#4898, #4899)\n            if (percentRegex.test(height)) {\n                height = Math.round(parseFloat(height) / 100 * chart.plotHeight);\n            }\n            if (percentRegex.test(top)) {\n                top = Math.round(parseFloat(top) / 100 * chart.plotHeight + chart.plotTop);\n            }\n\n            // Expose basic values to use in Series object and navigator\n            this.left = left;\n            this.top = top;\n            this.width = width;\n            this.height = height;\n            this.bottom = chart.chartHeight - height - top;\n            this.right = chart.chartWidth - width - left;\n\n            // Direction agnostic properties\n            this.len = mathMax(horiz ? width : height, 0); // mathMax fixes #905\n            this.pos = horiz ? left : top; // distance from SVG origin\n        },\n\n        /**\n         * Get the actual axis extremes\n         */\n        getExtremes: function () {\n            var axis = this,\n                isLog = axis.isLog;\n\n            return {\n                min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,\n                max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,\n                dataMin: axis.dataMin,\n                dataMax: axis.dataMax,\n                userMin: axis.userMin,\n                userMax: axis.userMax\n            };\n        },\n\n        /**\n         * Get the zero plane either based on zero or on the min or max value.\n         * Used in bar and area plots\n         */\n        getThreshold: function (threshold) {\n            var axis = this,\n                isLog = axis.isLog,\n                realMin = isLog ? lin2log(axis.min) : axis.min,\n                realMax = isLog ? lin2log(axis.max) : axis.max;\n\n            // With a threshold of null, make the columns/areas rise from the top or bottom\n            // depending on the value, assuming an actual threshold of 0 (#4233).\n            if (threshold === null) {\n                threshold = realMax < 0 ? realMax : realMin;\n            } else if (realMin > threshold) {\n                threshold = realMin;\n            } else if (realMax < threshold) {\n                threshold = realMax;\n            }\n\n            return axis.translate(threshold, 0, 1, 0, 1);\n        },\n\n        /**\n         * Compute auto alignment for the axis label based on which side the axis is on\n         * and the given rotation for the label\n         */\n        autoLabelAlign: function (rotation) {\n            var ret,\n                angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;\n\n            if (angle > 15 && angle < 165) {\n                ret = 'right';\n            } else if (angle > 195 && angle < 345) {\n                ret = 'left';\n            } else {\n                ret = 'center';\n            }\n            return ret;\n        },\n\n        /**\n         * Prevent the ticks from getting so close we can't draw the labels. On a horizontal\n         * axis, this is handled by rotating the labels, removing ticks and adding ellipsis.\n         * On a vertical axis remove ticks and add ellipsis.\n         */\n        unsquish: function () {\n            var chart = this.chart,\n                ticks = this.ticks,\n                labelOptions = this.options.labels,\n                horiz = this.horiz,\n                tickInterval = this.tickInterval,\n                newTickInterval = tickInterval,\n                slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),\n                rotation,\n                rotationOption = labelOptions.rotation,\n                labelMetrics = chart.renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),\n                step,\n                bestScore = Number.MAX_VALUE,\n                autoRotation,\n                // Return the multiple of tickInterval that is needed to avoid collision\n                getStep = function (spaceNeeded) {\n                    var step = spaceNeeded / (slotSize || 1);\n                    step = step > 1 ? mathCeil(step) : 1;\n                    return step * tickInterval;\n                };\n\n            if (horiz) {\n                autoRotation = !labelOptions.staggerLines && !labelOptions.step && ( // #3971\n                    defined(rotationOption) ?\n                        [rotationOption] :\n                        slotSize < pick(labelOptions.autoRotationLimit, 80) && labelOptions.autoRotation\n                );\n\n                if (autoRotation) {\n\n                    // Loop over the given autoRotation options, and determine which gives the best score. The\n                    // best score is that with the lowest number of steps and a rotation closest to horizontal.\n                    each(autoRotation, function (rot) {\n                        var score;\n\n                        if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891\n\n                            step = getStep(mathAbs(labelMetrics.h / mathSin(deg2rad * rot)));\n\n                            score = step + mathAbs(rot / 360);\n\n                            if (score < bestScore) {\n                                bestScore = score;\n                                rotation = rot;\n                                newTickInterval = step;\n                            }\n                        }\n                    });\n                }\n\n            } else if (!labelOptions.step) { // #4411\n                newTickInterval = getStep(labelMetrics.h);\n            }\n\n            this.autoRotation = autoRotation;\n            this.labelRotation = pick(rotation, rotationOption);\n\n            return newTickInterval;\n        },\n\n        renderUnsquish: function () {\n            var chart = this.chart,\n                renderer = chart.renderer,\n                tickPositions = this.tickPositions,\n                ticks = this.ticks,\n                labelOptions = this.options.labels,\n                horiz = this.horiz,\n                margin = chart.margin,\n                slotCount = this.categories ? tickPositions.length : tickPositions.length - 1,\n                slotWidth = this.slotWidth = (horiz && (labelOptions.step || 0) < 2 && !labelOptions.rotation && // #4415\n                    ((this.staggerLines || 1) * chart.plotWidth) / slotCount) ||\n                    (!horiz && ((margin[3] && (margin[3] - chart.spacing[3])) || chart.chartWidth * 0.33)), // #1580, #1931,\n                innerWidth = mathMax(1, mathRound(slotWidth - 2 * (labelOptions.padding || 5))),\n                attr = {},\n                labelMetrics = renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),\n                textOverflowOption = labelOptions.style.textOverflow,\n                css,\n                labelLength = 0,\n                label,\n                i,\n                pos;\n\n            // Set rotation option unless it is \"auto\", like in gauges\n            if (!isString(labelOptions.rotation)) {\n                attr.rotation = labelOptions.rotation || 0; // #4443\n            }\n\n            // Handle auto rotation on horizontal axis\n            if (this.autoRotation) {\n\n                // Get the longest label length\n                each(tickPositions, function (tick) {\n                    tick = ticks[tick];\n                    if (tick && tick.labelLength > labelLength) {\n                        labelLength = tick.labelLength;\n                    }\n                });\n\n                // Apply rotation only if the label is too wide for the slot, and\n                // the label is wider than its height.\n                if (labelLength > innerWidth && labelLength > labelMetrics.h) {\n                    attr.rotation = this.labelRotation;\n                } else {\n                    this.labelRotation = 0;\n                }\n\n            // Handle word-wrap or ellipsis on vertical axis\n            } else if (slotWidth) {\n                // For word-wrap or ellipsis\n                css = { width: innerWidth + PX };\n\n                if (!textOverflowOption) {\n                    css.textOverflow = 'clip';\n\n                    // On vertical axis, only allow word wrap if there is room for more lines.\n                    i = tickPositions.length;\n                    while (!horiz && i--) {\n                        pos = tickPositions[i];\n                        label = ticks[pos].label;\n                        if (label) {\n                            // Reset ellipsis in order to get the correct bounding box (#4070)\n                            if (label.styles.textOverflow === 'ellipsis') {\n                                label.css({ textOverflow: 'clip' });\n                            }\n                            if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f) ||\n                                    ticks[pos].labelLength > slotWidth) { // #4678\n                                label.specCss = { textOverflow: 'ellipsis' };\n                            }\n                        }\n                    }\n                }\n            }\n\n\n            // Add ellipsis if the label length is significantly longer than ideal\n            if (attr.rotation) {\n                css = {\n                    width: (labelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + PX\n                };\n                if (!textOverflowOption) {\n                    css.textOverflow = 'ellipsis';\n                }\n            }\n\n            // Set the explicit or automatic label alignment\n            this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);\n            if (this.labelAlign) {\n                attr.align = this.labelAlign;\n            }\n\n            // Apply general and specific CSS\n            each(tickPositions, function (pos) {\n                var tick = ticks[pos],\n                    label = tick && tick.label;\n                if (label) {\n                    label.attr(attr); // This needs to go before the CSS in old IE (#4502)\n                    if (css) {\n                        label.css(merge(css, label.specCss));\n                    }\n                    delete label.specCss;\n                    tick.rotation = attr.rotation;\n                }\n            });\n\n            // Note: Why is this not part of getLabelPosition?\n            this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);\n        },\n\n        /**\n         * Return true if the axis has associated data\n         */\n        hasData: function () {\n            return this.hasVisibleSeries || (defined(this.min) && defined(this.max) && !!this.tickPositions);\n        },\n\n        /**\n         * Render the tick labels to a preliminary position to get their sizes\n         */\n        getOffset: function () {\n            var axis = this,\n                chart = axis.chart,\n                renderer = chart.renderer,\n                options = axis.options,\n                tickPositions = axis.tickPositions,\n                ticks = axis.ticks,\n                horiz = axis.horiz,\n                side = axis.side,\n                invertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,\n                hasData,\n                showAxis,\n                titleOffset = 0,\n                titleOffsetOption,\n                titleMargin = 0,\n                axisTitleOptions = options.title,\n                labelOptions = options.labels,\n                labelOffset = 0, // reset\n                labelOffsetPadded,\n                opposite = axis.opposite,\n                axisOffset = chart.axisOffset,\n                clipOffset = chart.clipOffset,\n                clip,\n                directionFactor = [-1, 1, 1, -1][side],\n                n,\n                axisParent = axis.axisParent, // Used in color axis\n                lineHeightCorrection;\n\n            // For reuse in Axis.render\n            hasData = axis.hasData();\n            axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);\n\n            // Set/reset staggerLines\n            axis.staggerLines = axis.horiz && labelOptions.staggerLines;\n\n            // Create the axisGroup and gridGroup elements on first iteration\n            if (!axis.axisGroup) {\n                axis.gridGroup = renderer.g('grid')\n                    .attr({ zIndex: options.gridZIndex || 1 })\n                    .add(axisParent);\n                axis.axisGroup = renderer.g('axis')\n                    .attr({ zIndex: options.zIndex || 2 })\n                    .add(axisParent);\n                axis.labelGroup = renderer.g('axis-labels')\n                    .attr({ zIndex: labelOptions.zIndex || 7 })\n                    .addClass(PREFIX + axis.coll.toLowerCase() + '-labels')\n                    .add(axisParent);\n            }\n\n            if (hasData || axis.isLinked) {\n\n                // Generate ticks\n                each(tickPositions, function (pos) {\n                    if (!ticks[pos]) {\n                        ticks[pos] = new Tick(axis, pos);\n                    } else {\n                        ticks[pos].addLabel(); // update labels depending on tick interval\n                    }\n                });\n\n                axis.renderUnsquish();\n\n\n                // Left side must be align: right and right side must have align: left for labels\n                if (labelOptions.reserveSpace !== false && (side === 0 || side === 2 ||\n                        { 1: 'left', 3: 'right' }[side] === axis.labelAlign || axis.labelAlign === 'center')) {\n                    each(tickPositions, function (pos) {\n\n                        // get the highest offset\n                        labelOffset = mathMax(\n                            ticks[pos].getLabelSize(),\n                            labelOffset\n                        );\n                    });\n                }\n\n                if (axis.staggerLines) {\n                    labelOffset *= axis.staggerLines;\n                    axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);\n                }\n\n\n            } else { // doesn't have data\n                for (n in ticks) {\n                    ticks[n].destroy();\n                    delete ticks[n];\n                }\n            }\n\n            if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {\n                if (!axis.axisTitle) {\n                    axis.axisTitle = renderer.text(\n                        axisTitleOptions.text,\n                        0,\n                        0,\n                        axisTitleOptions.useHTML\n                    )\n                    .attr({\n                        zIndex: 7,\n                        rotation: axisTitleOptions.rotation || 0,\n                        align: \n                            axisTitleOptions.textAlign ||\n                            { \n                                low: opposite ? 'right' : 'left',\n                                middle: 'center',\n                                high: opposite ? 'left' : 'right'\n                            }[axisTitleOptions.align]\n                    })\n                    .addClass(PREFIX + this.coll.toLowerCase() + '-title')\n                    .css(axisTitleOptions.style)\n                    .add(axis.axisGroup);\n                    axis.axisTitle.isNew = true;\n                }\n\n                if (showAxis) {\n                    titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];\n                    titleOffsetOption = axisTitleOptions.offset;\n                    titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);\n                }\n\n                // hide or show the title depending on whether showEmpty is set\n                axis.axisTitle[showAxis ? 'show' : 'hide'](true);\n            }\n\n            // handle automatic or user set offset\n            axis.offset = directionFactor * pick(options.offset, axisOffset[side]);\n\n            axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar\n            lineHeightCorrection = side === 2 ? axis.tickRotCorr.y : 0;\n            labelOffsetPadded = Math.abs(labelOffset) + titleMargin +\n                (labelOffset && (directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + 8) : labelOptions.x) - lineHeightCorrection));\n            axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);\n\n            axisOffset[side] = mathMax(\n                axisOffset[side],\n                axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,\n                labelOffsetPadded // #3027\n            );\n\n            // Decide the clipping needed to keep the graph inside the plot area and axis lines\n            clip = options.offset ? 0 : mathFloor(options.lineWidth / 2) * 2; // #4308, #4371\n            clipOffset[invertedSide] = mathMax(clipOffset[invertedSide], clip);\n        },\n\n        /**\n         * Get the path for the axis line\n         */\n        getLinePath: function (lineWidth) {\n            var chart = this.chart,\n                opposite = this.opposite,\n                offset = this.offset,\n                horiz = this.horiz,\n                lineLeft = this.left + (opposite ? this.width : 0) + offset,\n                lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;\n\n            if (opposite) {\n                lineWidth *= -1; // crispify the other way - #1480, #1687\n            }\n\n            return chart.renderer\n                .crispLine([\n                    M,\n                    horiz ?\n                        this.left :\n                        lineLeft,\n                    horiz ?\n                        lineTop :\n                        this.top,\n                    L,\n                    horiz ?\n                        chart.chartWidth - this.right :\n                        lineLeft,\n                    horiz ?\n                        lineTop :\n                        chart.chartHeight - this.bottom\n                ], lineWidth);\n        },\n\n        /**\n         * Position the title\n         */\n        getTitlePosition: function () {\n            // compute anchor points for each of the title align options\n            var horiz = this.horiz,\n                axisLeft = this.left,\n                axisTop = this.top,\n                axisLength = this.len,\n                axisTitleOptions = this.options.title,\n                margin = horiz ? axisLeft : axisTop,\n                opposite = this.opposite,\n                offset = this.offset,\n                xOption = axisTitleOptions.x || 0,\n                yOption = axisTitleOptions.y || 0,\n                fontSize = pInt(axisTitleOptions.style.fontSize || 12),\n\n                // the position in the length direction of the axis\n                alongAxis = {\n                    low: margin + (horiz ? 0 : axisLength),\n                    middle: margin + axisLength / 2,\n                    high: margin + (horiz ? axisLength : 0)\n                }[axisTitleOptions.align],\n\n                // the position in the perpendicular direction of the axis\n                offAxis = (horiz ? axisTop + this.height : axisLeft) +\n                    (horiz ? 1 : -1) * // horizontal axis reverses the margin\n                    (opposite ? -1 : 1) * // so does opposite axes\n                    this.axisTitleMargin +\n                    (this.side === 2 ? fontSize : 0);\n\n            return {\n                x: horiz ?\n                    alongAxis + xOption :\n                    offAxis + (opposite ? this.width : 0) + offset + xOption,\n                y: horiz ?\n                    offAxis + yOption - (opposite ? this.height : 0) + offset :\n                    alongAxis + yOption\n            };\n        },\n\n        /**\n         * Render the axis\n         */\n        render: function () {\n            var axis = this,\n                chart = axis.chart,\n                renderer = chart.renderer,\n                options = axis.options,\n                isLog = axis.isLog,\n                isLinked = axis.isLinked,\n                tickPositions = axis.tickPositions,\n                axisTitle = axis.axisTitle,\n                ticks = axis.ticks,\n                minorTicks = axis.minorTicks,\n                alternateBands = axis.alternateBands,\n                stackLabelOptions = options.stackLabels,\n                alternateGridColor = options.alternateGridColor,\n                tickmarkOffset = axis.tickmarkOffset,\n                lineWidth = options.lineWidth,\n                linePath,\n                hasRendered = chart.hasRendered,\n                slideInTicks = hasRendered && defined(axis.oldMin) && !isNaN(axis.oldMin),\n                showAxis = axis.showAxis,\n                globalAnimation = renderer.globalAnimation,\n                from,\n                to;\n\n            // Reset\n            axis.labelEdge.length = 0;\n            //axis.justifyToPlot = overflow === 'justify';\n            axis.overlap = false;\n\n            // Mark all elements inActive before we go over and mark the active ones\n            each([ticks, minorTicks, alternateBands], function (coll) {\n                var pos;\n                for (pos in coll) {\n                    coll[pos].isActive = false;\n                }\n            });\n\n            // If the series has data draw the ticks. Else only the line and title\n            if (axis.hasData() || isLinked) {\n\n                // minor ticks\n                if (axis.minorTickInterval && !axis.categories) {\n                    each(axis.getMinorTickPositions(), function (pos) {\n                        if (!minorTicks[pos]) {\n                            minorTicks[pos] = new Tick(axis, pos, 'minor');\n                        }\n\n                        // render new ticks in old position\n                        if (slideInTicks && minorTicks[pos].isNew) {\n                            minorTicks[pos].render(null, true);\n                        }\n\n                        minorTicks[pos].render(null, false, 1);\n                    });\n                }\n\n                // Major ticks. Pull out the first item and render it last so that\n                // we can get the position of the neighbour label. #808.\n                if (tickPositions.length) { // #1300\n                    each(tickPositions, function (pos, i) {\n\n                        // linked axes need an extra check to find out if\n                        if (!isLinked || (pos >= axis.min && pos <= axis.max)) {\n\n                            if (!ticks[pos]) {\n                                ticks[pos] = new Tick(axis, pos);\n                            }\n\n                            // render new ticks in old position\n                            if (slideInTicks && ticks[pos].isNew) {\n                                ticks[pos].render(i, true, 0.1);\n                            }\n\n                            ticks[pos].render(i);\n                        }\n\n                    });\n                    // In a categorized axis, the tick marks are displayed between labels. So\n                    // we need to add a tick mark and grid line at the left edge of the X axis.\n                    if (tickmarkOffset && (axis.min === 0 || axis.single)) {\n                        if (!ticks[-1]) {\n                            ticks[-1] = new Tick(axis, -1, null, true);\n                        }\n                        ticks[-1].render(-1);\n                    }\n\n                }\n\n                // alternate grid color\n                if (alternateGridColor) {\n                    each(tickPositions, function (pos, i) {\n                        to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset; \n                        if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) { // #2248, #4660\n                            if (!alternateBands[pos]) {\n                                alternateBands[pos] = new Highcharts.PlotLineOrBand(axis);\n                            }\n                            from = pos + tickmarkOffset; // #949\n                            alternateBands[pos].options = {\n                                from: isLog ? lin2log(from) : from,\n                                to: isLog ? lin2log(to) : to,\n                                color: alternateGridColor\n                            };\n                            alternateBands[pos].render();\n                            alternateBands[pos].isActive = true;\n                        }\n                    });\n                }\n\n                // custom plot lines and bands\n                if (!axis._addedPlotLB) { // only first time\n                    each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {\n                        axis.addPlotBandOrLine(plotLineOptions);\n                    });\n                    axis._addedPlotLB = true;\n                }\n\n            } // end if hasData\n\n            // Remove inactive ticks\n            each([ticks, minorTicks, alternateBands], function (coll) {\n                var pos,\n                    i,\n                    forDestruction = [],\n                    delay = globalAnimation ? globalAnimation.duration || 500 : 0,\n                    destroyInactiveItems = function () {\n                        i = forDestruction.length;\n                        while (i--) {\n                            // When resizing rapidly, the same items may be destroyed in different timeouts,\n                            // or the may be reactivated\n                            if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {\n                                coll[forDestruction[i]].destroy();\n                                delete coll[forDestruction[i]];\n                            }\n                        }\n\n                    };\n\n                for (pos in coll) {\n\n                    if (!coll[pos].isActive) {\n                        // Render to zero opacity\n                        coll[pos].render(pos, false, 0);\n                        coll[pos].isActive = false;\n                        forDestruction.push(pos);\n                    }\n                }\n\n                // When the objects are finished fading out, destroy them\n                syncTimeout(\n                    destroyInactiveItems, \n                    coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay\n                );\n            });\n\n            // Static items. As the axis group is cleared on subsequent calls\n            // to render, these items are added outside the group.\n            // axis line\n            if (lineWidth) {\n                linePath = axis.getLinePath(lineWidth);\n                if (!axis.axisLine) {\n                    axis.axisLine = renderer.path(linePath)\n                        .attr({\n                            stroke: options.lineColor,\n                            'stroke-width': lineWidth,\n                            zIndex: 7\n                        })\n                        .add(axis.axisGroup);\n                } else {\n                    axis.axisLine.animate({ d: linePath });\n                }\n\n                // show or hide the line depending on options.showEmpty\n                axis.axisLine[showAxis ? 'show' : 'hide'](true);\n            }\n\n            if (axisTitle && showAxis) {\n\n                axisTitle[axisTitle.isNew ? 'attr' : 'animate'](\n                    axis.getTitlePosition()\n                );\n                axisTitle.isNew = false;\n            }\n\n            // Stacked totals:\n            if (stackLabelOptions && stackLabelOptions.enabled) {\n                axis.renderStackTotals();\n            }\n            // End stacked totals\n\n            axis.isDirty = false;\n        },\n\n        /**\n         * Redraw the axis to reflect changes in the data or axis extremes\n         */\n        redraw: function () {\n\n            if (this.visible) {\n                // render the axis\n                this.render();\n\n                // move plot lines and bands\n                each(this.plotLinesAndBands, function (plotLine) {\n                    plotLine.render();\n                });\n            }\n\n            // mark associated series as dirty and ready for redraw\n            each(this.series, function (series) {\n                series.isDirty = true;\n            });\n\n        },\n\n        /**\n         * Destroys an Axis instance.\n         */\n        destroy: function (keepEvents) {\n            var axis = this,\n                stacks = axis.stacks,\n                stackKey,\n                plotLinesAndBands = axis.plotLinesAndBands,\n                i;\n\n            // Remove the events\n            if (!keepEvents) {\n                removeEvent(axis);\n            }\n\n            // Destroy each stack total\n            for (stackKey in stacks) {\n                destroyObjectProperties(stacks[stackKey]);\n\n                stacks[stackKey] = null;\n            }\n\n            // Destroy collections\n            each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {\n                destroyObjectProperties(coll);\n            });\n            i = plotLinesAndBands.length;\n            while (i--) { // #1975\n                plotLinesAndBands[i].destroy();\n            }\n\n            // Destroy local variables\n            each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'cross', 'gridGroup', 'labelGroup'], function (prop) {\n                if (axis[prop]) {\n                    axis[prop] = axis[prop].destroy();\n                }\n            });\n\n            // Destroy crosshair\n            if (this.cross) {\n                this.cross.destroy();\n            }\n        },\n\n        /**\n         * Draw the crosshair\n         * \n         * @param  {Object} e The event arguments from the modified pointer event\n         * @param  {Object} point The Point object\n         */\n        drawCrosshair: function (e, point) {\n\n            var path,\n                options = this.crosshair,\n                pos,\n                attribs,\n                categorized,\n                strokeWidth;\n\n            if (\n                // Disabled in options\n                !this.crosshair ||\n                // Snap\n                ((defined(point) || !pick(options.snap, true)) === false)\n            ) {\n                this.hideCrosshair();\n\n            } else {\n\n                // Get the path\n                if (!pick(options.snap, true)) {\n                    pos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);\n                } else if (defined(point)) {\n                    pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834\n                }\n\n                if (this.isRadial) {\n                    path = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y)) || null; // #3189\n                } else {\n                    path = this.getPlotLinePath(null, null, null, null, pos) || null; // #3189\n                }\n\n                if (path === null) {\n                    this.hideCrosshair();\n                    return;\n                }\n\n                categorized = this.categories && !this.isRadial;\n                strokeWidth = pick(options.width, (categorized ? this.transA : 1));\n\n                // Draw the cross\n                if (this.cross) {\n                    this.cross\n                        .attr({\n                            d: path,\n                            visibility: 'visible',\n                            'stroke-width': strokeWidth // #4737\n                        });\n                } else {\n                    attribs = {\n                        'stroke-width': strokeWidth,\n                        stroke: options.color || (categorized ? 'rgba(155,200,255,0.2)' : '#C0C0C0'),\n                        zIndex: pick(options.zIndex, 2)\n                    };\n                    if (options.dashStyle) {\n                        attribs.dashstyle = options.dashStyle;\n                    }\n                    this.cross = this.chart.renderer.path(path).attr(attribs).add();\n                }\n\n            }\n\n        },\n\n        /**\n         *    Hide the crosshair.\n         */\n        hideCrosshair: function () {\n            if (this.cross) {\n                this.cross.hide();\n            }\n        }\n    }; // end Axis\n\n    extend(Axis.prototype, AxisPlotLineOrBandExtension);\n\n    /**\n     * Set the tick positions to a time unit that makes sense, for example\n     * on the first of each month or on every Monday. Return an array\n     * with the time positions. Used in datetime axes as well as for grouping\n     * data on a datetime axis.\n     *\n     * @param {Object} normalizedInterval The interval in axis values (ms) and the count\n     * @param {Number} min The minimum in axis values\n     * @param {Number} max The maximum in axis values\n     * @param {Number} startOfWeek\n     */\n    Axis.prototype.getTimeTicks = function (normalizedInterval, min, max, startOfWeek) {\n        var tickPositions = [],\n            i,\n            higherRanks = {},\n            useUTC = defaultOptions.global.useUTC,\n            minYear, // used in months and years as a basis for Date.UTC()\n            minDate = new Date(min - getTZOffset(min)),\n            interval = normalizedInterval.unitRange,\n            count = normalizedInterval.count;\n\n        if (defined(min)) { // #1300\n            minDate[setMilliseconds](interval >= timeUnits.second ? 0 : // #3935\n                count * mathFloor(minDate.getMilliseconds() / count)); // #3652, #3654\n\n            if (interval >= timeUnits.second) { // second\n                minDate[setSeconds](interval >= timeUnits.minute ? 0 : // #3935\n                    count * mathFloor(minDate.getSeconds() / count));\n            }\n\n            if (interval >= timeUnits.minute) { // minute\n                minDate[setMinutes](interval >= timeUnits.hour ? 0 :\n                    count * mathFloor(minDate[getMinutes]() / count));\n            }\n\n            if (interval >= timeUnits.hour) { // hour\n                minDate[setHours](interval >= timeUnits.day ? 0 :\n                    count * mathFloor(minDate[getHours]() / count));\n            }\n\n            if (interval >= timeUnits.day) { // day\n                minDate[setDate](interval >= timeUnits.month ? 1 :\n                    count * mathFloor(minDate[getDate]() / count));\n            }\n\n            if (interval >= timeUnits.month) { // month\n                minDate[setMonth](interval >= timeUnits.year ? 0 :\n                    count * mathFloor(minDate[getMonth]() / count));\n                minYear = minDate[getFullYear]();\n            }\n\n            if (interval >= timeUnits.year) { // year\n                minYear -= minYear % count;\n                minDate[setFullYear](minYear);\n            }\n\n            // week is a special case that runs outside the hierarchy\n            if (interval === timeUnits.week) {\n                // get start of current week, independent of count\n                minDate[setDate](minDate[getDate]() - minDate[getDay]() +\n                    pick(startOfWeek, 1));\n            }\n\n\n            // get tick positions\n            i = 1;\n            if (timezoneOffset || getTimezoneOffset) {\n                minDate = minDate.getTime();\n                minDate = new Date(minDate + getTZOffset(minDate));\n            }\n            minYear = minDate[getFullYear]();\n            var time = minDate.getTime(),\n                minMonth = minDate[getMonth](),\n                minDateDate = minDate[getDate](),\n                variableDayLength = !useUTC || !!getTimezoneOffset, // #4951\n                localTimezoneOffset = (timeUnits.day +\n                        (useUTC ? getTZOffset(minDate) : minDate.getTimezoneOffset() * 60 * 1000)\n                    ) % timeUnits.day; // #950, #3359\n\n            // iterate and add tick positions at appropriate values\n            while (time < max) {\n                tickPositions.push(time);\n\n                // if the interval is years, use Date.UTC to increase years\n                if (interval === timeUnits.year) {\n                    time = makeTime(minYear + i * count, 0);\n\n                // if the interval is months, use Date.UTC to increase months\n                } else if (interval === timeUnits.month) {\n                    time = makeTime(minYear, minMonth + i * count);\n\n                // if we're using global time, the interval is not fixed as it jumps\n                // one hour at the DST crossover\n                } else if (variableDayLength && (interval === timeUnits.day || interval === timeUnits.week)) {\n                    time = makeTime(minYear, minMonth, minDateDate +\n                        i * count * (interval === timeUnits.day ? 1 : 7));\n\n                // else, the interval is fixed and we use simple addition\n                } else {\n                    time += interval * count;\n                }\n\n                i++;\n            }\n\n            // push the last time\n            tickPositions.push(time);\n\n\n            // mark new days if the time is dividible by day (#1649, #1760)\n            each(grep(tickPositions, function (time) {\n                return interval <= timeUnits.hour && time % timeUnits.day === localTimezoneOffset;\n            }), function (time) {\n                higherRanks[time] = 'day';\n            });\n        }\n\n\n        // record information on the chosen unit - for dynamic label formatter\n        tickPositions.info = extend(normalizedInterval, {\n            higherRanks: higherRanks,\n            totalRange: interval * count\n        });\n\n        return tickPositions;\n    };\n\n    /**\n     * Get a normalized tick interval for dates. Returns a configuration object with\n     * unit range (interval), count and name. Used to prepare data for getTimeTicks.\n     * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs\n     * of segments in stock charts, the normalizing logic was extracted in order to\n     * prevent it for running over again for each segment having the same interval.\n     * #662, #697.\n     */\n    Axis.prototype.normalizeTimeTickInterval = function (tickInterval, unitsOption) {\n        var units = unitsOption || [[\n                'millisecond', // unit name\n                [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n            ], [\n                'second',\n                [1, 2, 5, 10, 15, 30]\n            ], [\n                'minute',\n                [1, 2, 5, 10, 15, 30]\n            ], [\n                'hour',\n                [1, 2, 3, 4, 6, 8, 12]\n            ], [\n                'day',\n                [1, 2]\n            ], [\n                'week',\n                [1, 2]\n            ], [\n                'month',\n                [1, 2, 3, 4, 6]\n            ], [\n                'year',\n                null\n            ]],\n            unit = units[units.length - 1], // default unit is years\n            interval = timeUnits[unit[0]],\n            multiples = unit[1],\n            count,\n            i;\n\n        // loop through the units to find the one that best fits the tickInterval\n        for (i = 0; i < units.length; i++) {\n            unit = units[i];\n            interval = timeUnits[unit[0]];\n            multiples = unit[1];\n\n\n            if (units[i + 1]) {\n                // lessThan is in the middle between the highest multiple and the next unit.\n                var lessThan = (interval * multiples[multiples.length - 1] +\n                            timeUnits[units[i + 1][0]]) / 2;\n\n                // break and keep the current unit\n                if (tickInterval <= lessThan) {\n                    break;\n                }\n            }\n        }\n\n        // prevent 2.5 years intervals, though 25, 250 etc. are allowed\n        if (interval === timeUnits.year && tickInterval < 5 * interval) {\n            multiples = [1, 2, 5];\n        }\n\n        // get the count\n        count = normalizeTickInterval(\n            tickInterval / interval,\n            multiples,\n            unit[0] === 'year' ? mathMax(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360\n        );\n\n        return {\n            unitRange: interval,\n            count: count,\n            unitName: unit[0]\n        };\n    };\n    /**\n     * Methods defined on the Axis prototype\n     */\n\n    /**\n     * Set the tick positions of a logarithmic axis\n     */\n    Axis.prototype.getLogTickPositions = function (interval, min, max, minor) {\n        var axis = this,\n            options = axis.options,\n            axisLength = axis.len,\n            // Since we use this method for both major and minor ticks,\n            // use a local variable and return the result\n            positions = [];\n\n        // Reset\n        if (!minor) {\n            axis._minorAutoInterval = null;\n        }\n\n        // First case: All ticks fall on whole logarithms: 1, 10, 100 etc.\n        if (interval >= 0.5) {\n            interval = mathRound(interval);\n            positions = axis.getLinearTickPositions(interval, min, max);\n\n        // Second case: We need intermediary ticks. For example\n        // 1, 2, 4, 6, 8, 10, 20, 40 etc.\n        } else if (interval >= 0.08) {\n            var roundedMin = mathFloor(min),\n                intermediate,\n                i,\n                j,\n                len,\n                pos,\n                lastPos,\n                break2;\n\n            if (interval > 0.3) {\n                intermediate = [1, 2, 4];\n            } else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc\n                intermediate = [1, 2, 4, 6, 8];\n            } else { // 0.1 equals ten minor ticks per 1, 10, 100 etc\n                intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n            }\n\n            for (i = roundedMin; i < max + 1 && !break2; i++) {\n                len = intermediate.length;\n                for (j = 0; j < len && !break2; j++) {\n                    pos = log2lin(lin2log(i) * intermediate[j]);\n                    if (pos > min && (!minor || lastPos <= max) && lastPos !== UNDEFINED) { // #1670, lastPos is #3113\n                        positions.push(lastPos);\n                    }\n\n                    if (lastPos > max) {\n                        break2 = true;\n                    }\n                    lastPos = pos;\n                }\n            }\n\n        // Third case: We are so deep in between whole logarithmic values that\n        // we might as well handle the tick positions like a linear axis. For\n        // example 1.01, 1.02, 1.03, 1.04.\n        } else {\n            var realMin = lin2log(min),\n                realMax = lin2log(max),\n                tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],\n                filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,\n                tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),\n                totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;\n\n            interval = pick(\n                filteredTickIntervalOption,\n                axis._minorAutoInterval,\n                (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)\n            );\n\n            interval = normalizeTickInterval(\n                interval,\n                null,\n                getMagnitude(interval)\n            );\n\n            positions = map(axis.getLinearTickPositions(\n                interval,\n                realMin,\n                realMax\n            ), log2lin);\n\n            if (!minor) {\n                axis._minorAutoInterval = interval / 5;\n            }\n        }\n\n        // Set the axis-level tickInterval variable\n        if (!minor) {\n            axis.tickInterval = interval;\n        }\n        return positions;\n    };/**\n     * The tooltip object\n     * @param {Object} chart The chart instance\n     * @param {Object} options Tooltip options\n     */\n    var Tooltip = Highcharts.Tooltip = function () {\n        this.init.apply(this, arguments);\n    };\n\n    Tooltip.prototype = {\n\n        init: function (chart, options) {\n\n            var borderWidth = options.borderWidth,\n                style = options.style,\n                padding = pInt(style.padding);\n\n            // Save the chart and options\n            this.chart = chart;\n            this.options = options;\n\n            // Keep track of the current series\n            //this.currentSeries = UNDEFINED;\n\n            // List of crosshairs\n            this.crosshairs = [];\n\n            // Current values of x and y when animating\n            this.now = { x: 0, y: 0 };\n\n            // The tooltip is initially hidden\n            this.isHidden = true;\n\n\n            // create the label\n            this.label = chart.renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip')\n                .attr({\n                    padding: padding,\n                    fill: options.backgroundColor,\n                    'stroke-width': borderWidth,\n                    r: options.borderRadius,\n                    zIndex: 8\n                })\n                .css(style)\n                .css({ padding: 0 }) // Remove it from VML, the padding is applied as an attribute instead (#1117)\n                .add()\n                .attr({ y: -9999 }); // #2301, #2657\n\n            // When using canVG the shadow shows up as a gray circle\n            // even if the tooltip is hidden.\n            if (!useCanVG) {\n                this.label.shadow(options.shadow);\n            }\n\n            // Public property for getting the shared state.\n            this.shared = options.shared;\n        },\n\n        /**\n         * Destroy the tooltip and its elements.\n         */\n        destroy: function () {\n            // Destroy and clear local variables\n            if (this.label) {\n                this.label = this.label.destroy();\n            }\n            clearTimeout(this.hideTimer);\n            clearTimeout(this.tooltipTimeout);\n        },\n\n        /**\n         * Provide a soft movement for the tooltip\n         *\n         * @param {Number} x\n         * @param {Number} y\n         * @private\n         */\n        move: function (x, y, anchorX, anchorY) {\n            var tooltip = this,\n                now = tooltip.now,\n                animate = tooltip.options.animation !== false && !tooltip.isHidden &&\n                    // When we get close to the target position, abort animation and land on the right place (#3056)\n                    (mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1),\n                skipAnchor = tooltip.followPointer || tooltip.len > 1;\n\n            // Get intermediate values for animation\n            extend(now, {\n                x: animate ? (2 * now.x + x) / 3 : x,\n                y: animate ? (now.y + y) / 2 : y,\n                anchorX: skipAnchor ? UNDEFINED : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,\n                anchorY: skipAnchor ? UNDEFINED : animate ? (now.anchorY + anchorY) / 2 : anchorY\n            });\n\n            // Move to the intermediate value\n            tooltip.label.attr(now);\n\n\n            // Run on next tick of the mouse tracker\n            if (animate) {\n\n                // Never allow two timeouts\n                clearTimeout(this.tooltipTimeout);\n\n                // Set the fixed interval ticking for the smooth tooltip\n                this.tooltipTimeout = setTimeout(function () {\n                    // The interval function may still be running during destroy, so check that the chart is really there before calling.\n                    if (tooltip) {\n                        tooltip.move(x, y, anchorX, anchorY);\n                    }\n                }, 32);\n\n            }\n        },\n\n        /**\n         * Hide the tooltip\n         */\n        hide: function (delay) {\n            var tooltip = this;\n            clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)\n            delay = pick(delay, this.options.hideDelay, 500);\n            if (!this.isHidden) {\n                this.hideTimer = syncTimeout(function () {\n                    tooltip.label[delay ? 'fadeOut' : 'hide']();\n                    tooltip.isHidden = true;\n                }, delay);\n            }\n        },\n\n        /**\n         * Extendable method to get the anchor position of the tooltip\n         * from a point or set of points\n         */\n        getAnchor: function (points, mouseEvent) {\n            var ret,\n                chart = this.chart,\n                inverted = chart.inverted,\n                plotTop = chart.plotTop,\n                plotLeft = chart.plotLeft,\n                plotX = 0,\n                plotY = 0,\n                yAxis,\n                xAxis;\n\n            points = splat(points);\n\n            // Pie uses a special tooltipPos\n            ret = points[0].tooltipPos;\n\n            // When tooltip follows mouse, relate the position to the mouse\n            if (this.followPointer && mouseEvent) {\n                if (mouseEvent.chartX === UNDEFINED) {\n                    mouseEvent = chart.pointer.normalize(mouseEvent);\n                }\n                ret = [\n                    mouseEvent.chartX - chart.plotLeft,\n                    mouseEvent.chartY - plotTop\n                ];\n            }\n            // When shared, use the average position\n            if (!ret) {\n                each(points, function (point) {\n                    yAxis = point.series.yAxis;\n                    xAxis = point.series.xAxis;\n                    plotX += point.plotX  + (!inverted && xAxis ? xAxis.left - plotLeft : 0);\n                    plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +\n                        (!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151\n                });\n\n                plotX /= points.length;\n                plotY /= points.length;\n\n                ret = [\n                    inverted ? chart.plotWidth - plotY : plotX,\n                    this.shared && !inverted && points.length > 1 && mouseEvent ?\n                        mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)\n                        inverted ? chart.plotHeight - plotX : plotY\n                ];\n            }\n\n            return map(ret, mathRound);\n        },\n\n        /**\n         * Place the tooltip in a chart without spilling over\n         * and not covering the point it self.\n         */\n        getPosition: function (boxWidth, boxHeight, point) {\n\n            var chart = this.chart,\n                distance = this.distance,\n                ret = {},\n                h = point.h || 0, // #4117\n                swapped,\n                first = ['y', chart.chartHeight, boxHeight, point.plotY + chart.plotTop, chart.plotTop, chart.plotTop + chart.plotHeight],\n                second = ['x', chart.chartWidth, boxWidth, point.plotX + chart.plotLeft, chart.plotLeft, chart.plotLeft + chart.plotWidth],\n                // The far side is right or bottom\n                preferFarSide = pick(point.ttBelow, (chart.inverted && !point.negative) || (!chart.inverted && point.negative)),\n                /**\n                 * Handle the preferred dimension. When the preferred dimension is tooltip\n                 * on top or bottom of the point, it will look for space there.\n                 */\n                firstDimension = function (dim, outerSize, innerSize, point, min, max) {\n                    var roomLeft = innerSize < point - distance,\n                        roomRight = point + distance + innerSize < outerSize,\n                        alignedLeft = point - distance - innerSize,\n                        alignedRight = point + distance;\n\n                    if (preferFarSide && roomRight) {\n                        ret[dim] = alignedRight;\n                    } else if (!preferFarSide && roomLeft) {\n                        ret[dim] = alignedLeft;\n                    } else if (roomLeft) {\n                        ret[dim] = mathMin(max - innerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);\n                    } else if (roomRight) {\n                        ret[dim] = mathMax(min, alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h);\n                    } else {\n                        return false;\n                    }\n                },\n                /**\n                 * Handle the secondary dimension. If the preferred dimension is tooltip\n                 * on top or bottom of the point, the second dimension is to align the tooltip\n                 * above the point, trying to align center but allowing left or right\n                 * align within the chart box.\n                 */\n                secondDimension = function (dim, outerSize, innerSize, point) {\n                    var retVal;\n\n                    // Too close to the edge, return false and swap dimensions\n                    if (point < distance || point > outerSize - distance) {\n                        retVal = false;\n                    // Align left/top\n                    } else if (point < innerSize / 2) {\n                        ret[dim] = 1;\n                    // Align right/bottom\n                    } else if (point > outerSize - innerSize / 2) {\n                        ret[dim] = outerSize - innerSize - 2;\n                    // Align center\n                    } else {\n                        ret[dim] = point - innerSize / 2;\n                    }\n                    return retVal;\n                },\n                /**\n                 * Swap the dimensions\n                 */\n                swap = function (count) {\n                    var temp = first;\n                    first = second;\n                    second = temp;\n                    swapped = count;\n                },\n                run = function () {\n                    if (firstDimension.apply(0, first) !== false) {\n                        if (secondDimension.apply(0, second) === false && !swapped) {\n                            swap(true);\n                            run();\n                        }\n                    } else if (!swapped) {\n                        swap(true);\n                        run();\n                    } else {\n                        ret.x = ret.y = 0;\n                    }\n                };\n\n            // Under these conditions, prefer the tooltip on the side of the point\n            if (chart.inverted || this.len > 1) {\n                swap();\n            }\n            run();\n\n            return ret;\n\n        },\n\n        /**\n         * In case no user defined formatter is given, this will be used. Note that the context\n         * here is an object holding point, series, x, y etc.\n         */\n        defaultFormatter: function (tooltip) {\n            var items = this.points || splat(this),\n                s;\n\n            // build the header\n            s = [tooltip.tooltipFooterHeaderFormatter(items[0])]; //#3397: abstraction to enable formatting of footer and header\n\n            // build the values\n            s = s.concat(tooltip.bodyFormatter(items));\n\n            // footer\n            s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true)); //#3397: abstraction to enable formatting of footer and header\n\n            return s.join('');\n        },\n\n        /**\n         * Refresh the tooltip's text and position.\n         * @param {Object} point\n         */\n        refresh: function (point, mouseEvent) {\n            var tooltip = this,\n                chart = tooltip.chart,\n                label = tooltip.label,\n                options = tooltip.options,\n                x,\n                y,\n                anchor,\n                textConfig = {},\n                text,\n                pointConfig = [],\n                formatter = options.formatter || tooltip.defaultFormatter,\n                hoverPoints = chart.hoverPoints,\n                borderColor,\n                shared = tooltip.shared,\n                currentSeries;\n\n            clearTimeout(this.hideTimer);\n\n            // get the reference point coordinates (pie charts use tooltipPos)\n            tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;\n            anchor = tooltip.getAnchor(point, mouseEvent);\n            x = anchor[0];\n            y = anchor[1];\n\n            // shared tooltip, array is sent over\n            if (shared && !(point.series && point.series.noSharedTooltip)) {\n\n                // hide previous hoverPoints and set new\n\n                chart.hoverPoints = point;\n                if (hoverPoints) {\n                    each(hoverPoints, function (point) {\n                        point.setState();\n                    });\n                }\n\n                each(point, function (item) {\n                    item.setState(HOVER_STATE);\n\n                    pointConfig.push(item.getLabelConfig());\n                });\n\n                textConfig = {\n                    x: point[0].category,\n                    y: point[0].y\n                };\n                textConfig.points = pointConfig;\n                this.len = pointConfig.length;\n                point = point[0];\n\n            // single point tooltip\n            } else {\n                textConfig = point.getLabelConfig();\n            }\n            text = formatter.call(textConfig, tooltip);\n\n            // register the current series\n            currentSeries = point.series;\n            this.distance = pick(currentSeries.tooltipOptions.distance, 16);\n\n            // update the inner HTML\n            if (text === false) {\n                this.hide();\n            } else {\n\n                // show it\n                if (tooltip.isHidden) {\n                    stop(label);\n                    label.attr('opacity', 1).show();\n                }\n\n                // update text\n                label.attr({\n                    text: text\n                });\n\n                // set the stroke color of the box\n                borderColor = options.borderColor || point.color || currentSeries.color || '#606060';\n                label.attr({\n                    stroke: borderColor\n                });\n                tooltip.updatePosition({\n                    plotX: x,\n                    plotY: y,\n                    negative: point.negative,\n                    ttBelow: point.ttBelow,\n                    h: anchor[2] || 0\n                });\n\n                this.isHidden = false;\n            }\n            fireEvent(chart, 'tooltipRefresh', {\n                text: text,\n                x: x + chart.plotLeft,\n                y: y + chart.plotTop,\n                borderColor: borderColor\n            });\n        },\n\n        /**\n         * Find the new position and perform the move\n         */\n        updatePosition: function (point) {\n            var chart = this.chart,\n                label = this.label,\n                pos = (this.options.positioner || this.getPosition).call(\n                    this,\n                    label.width,\n                    label.height,\n                    point\n                );\n\n            // do the move\n            this.move(\n                mathRound(pos.x),\n                mathRound(pos.y || 0), // can be undefined (#3977)\n                point.plotX + chart.plotLeft,\n                point.plotY + chart.plotTop\n            );\n        },\n\n        /**\n         * Get the best X date format based on the closest point range on the axis.\n         */\n        getXDateFormat: function (point, options, xAxis) {\n            var xDateFormat,\n                dateTimeLabelFormats = options.dateTimeLabelFormats,\n                closestPointRange = xAxis && xAxis.closestPointRange,\n                n,\n                blank = '01-01 00:00:00.000',\n                strpos = {\n                    millisecond: 15,\n                    second: 12,\n                    minute: 9,\n                    hour: 6,\n                    day: 3\n                },\n                date,\n                lastN = 'millisecond'; // for sub-millisecond data, #4223\n\n            if (closestPointRange) {\n                date = dateFormat('%m-%d %H:%M:%S.%L', point.x);\n                for (n in timeUnits) {\n\n                    // If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format\n                    if (closestPointRange === timeUnits.week && +dateFormat('%w', point.x) === xAxis.options.startOfWeek &&\n                            date.substr(6) === blank.substr(6)) {\n                        n = 'week';\n                        break;\n                    }\n\n                    // The first format that is too great for the range\n                    if (timeUnits[n] > closestPointRange) {\n                        n = lastN;\n                        break;\n                    }\n\n                    // If the point is placed every day at 23:59, we need to show\n                    // the minutes as well. #2637.\n                    if (strpos[n] && date.substr(strpos[n]) !== blank.substr(strpos[n])) {\n                        break;\n                    }\n\n                    // Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition\n                    if (n !== 'week') {\n                        lastN = n;\n                    }\n                }\n\n                if (n) {\n                    xDateFormat = dateTimeLabelFormats[n];\n                }\n            } else {\n                xDateFormat = dateTimeLabelFormats.day;\n            }\n\n            return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581\n        },\n\n        /**\n         * Format the footer/header of the tooltip\n         * #3397: abstraction to enable formatting of footer and header\n         */\n        tooltipFooterHeaderFormatter: function (point, isFooter) {\n            var footOrHead = isFooter ? 'footer' : 'header',\n                series = point.series,\n                tooltipOptions = series.tooltipOptions,\n                xDateFormat = tooltipOptions.xDateFormat,\n                xAxis = series.xAxis,\n                isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(point.key),\n                formatString = tooltipOptions[footOrHead + 'Format'];\n\n            // Guess the best date format based on the closest point distance (#568, #3418)\n            if (isDateTime && !xDateFormat) {\n                xDateFormat = this.getXDateFormat(point, tooltipOptions, xAxis);\n            }\n\n            // Insert the footer date format if any\n            if (isDateTime && xDateFormat) {\n                formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');\n            }\n\n            return format(formatString, {\n                point: point,\n                series: series\n            });\n        },\n\n        /**\n         * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,\n         * abstracting this functionality allows to easily overwrite and extend it.\n         */\n        bodyFormatter: function (items) {\n            return map(items, function (item) {\n                var tooltipOptions = item.series.tooltipOptions;\n                return (tooltipOptions.pointFormatter || item.point.tooltipFormatter).call(item.point, tooltipOptions.pointFormat);\n            });\n        }\n\n    };\n\n    var hoverChartIndex;\n\n    // Global flag for touch support\n    hasTouch = doc && doc.documentElement.ontouchstart !== UNDEFINED;\n\n    /**\n     * The mouse tracker object. All methods starting with \"on\" are primary DOM event handlers.\n     * Subsequent methods should be named differently from what they are doing.\n     * @param {Object} chart The Chart instance\n     * @param {Object} options The root options object\n     */\n    var Pointer = Highcharts.Pointer = function (chart, options) {\n        this.init(chart, options);\n    };\n\n    Pointer.prototype = {\n        /**\n         * Initialize Pointer\n         */\n        init: function (chart, options) {\n\n            var chartOptions = options.chart,\n                chartEvents = chartOptions.events,\n                zoomType = useCanVG ? '' : chartOptions.zoomType,\n                inverted = chart.inverted,\n                zoomX,\n                zoomY;\n\n            // Store references\n            this.options = options;\n            this.chart = chart;\n\n            // Zoom status\n            this.zoomX = zoomX = /x/.test(zoomType);\n            this.zoomY = zoomY = /y/.test(zoomType);\n            this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);\n            this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);\n            this.hasZoom = zoomX || zoomY;\n\n            // Do we need to handle click on a touch device?\n            this.runChartClick = chartEvents && !!chartEvents.click;\n\n            this.pinchDown = [];\n            this.lastValidTouch = {};\n\n            if (Highcharts.Tooltip && options.tooltip.enabled) {\n                chart.tooltip = new Tooltip(chart, options.tooltip);\n                this.followTouchMove = pick(options.tooltip.followTouchMove, true);\n            }\n\n            this.setDOMEvents();\n        },\n\n        /**\n         * Add crossbrowser support for chartX and chartY\n         * @param {Object} e The event object in standard browsers\n         */\n        normalize: function (e, chartPosition) {\n            var chartX,\n                chartY,\n                ePos;\n\n            // IE normalizing\n            e = e || win.event;\n            if (!e.target) {\n                e.target = e.srcElement;\n            }\n\n            // iOS (#2757)\n            ePos = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;\n\n            // Get mouse position\n            if (!chartPosition) {\n                this.chartPosition = chartPosition = offset(this.chart.container);\n            }\n\n            // chartX and chartY\n            if (ePos.pageX === UNDEFINED) { // IE < 9. #886.\n                chartX = mathMax(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is\n                    // for IE10 quirks mode within framesets\n                chartY = e.y;\n            } else {\n                chartX = ePos.pageX - chartPosition.left;\n                chartY = ePos.pageY - chartPosition.top;\n            }\n\n            return extend(e, {\n                chartX: mathRound(chartX),\n                chartY: mathRound(chartY)\n            });\n        },\n\n        /**\n         * Get the click position in terms of axis values.\n         *\n         * @param {Object} e A pointer event\n         */\n        getCoordinates: function (e) {\n            var coordinates = {\n                xAxis: [],\n                yAxis: []\n            };\n\n            each(this.chart.axes, function (axis) {\n                coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({\n                    axis: axis,\n                    value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])\n                });\n            });\n            return coordinates;\n        },\n\n        /**\n         * With line type charts with a single tracker, get the point closest to the mouse.\n         * Run Point.onMouseOver and display tooltip for the point or points.\n         */\n        runPointActions: function (e) {\n\n            var pointer = this,\n                chart = pointer.chart,\n                series = chart.series,\n                tooltip = chart.tooltip,\n                shared = tooltip ? tooltip.shared : false,\n                followPointer,\n                hoverPoint = chart.hoverPoint,\n                hoverSeries = chart.hoverSeries,\n                i,\n                distance = [Number.MAX_VALUE, Number.MAX_VALUE], // #4511\n                anchor,\n                noSharedTooltip,\n                stickToHoverSeries,\n                directTouch,\n                kdpoints = [],\n                kdpoint = [],\n                kdpointT;\n\n            // For hovering over the empty parts of the plot area (hoverSeries is undefined).\n            // If there is one series with point tracking (combo chart), don't go to nearest neighbour.\n            if (!shared && !hoverSeries) {\n                for (i = 0; i < series.length; i++) {\n                    if (series[i].directTouch || !series[i].options.stickyTracking) {\n                        series = [];\n                    }\n                }\n            }\n\n            // If it has a hoverPoint and that series requires direct touch (like columns, #3899), or we're on\n            // a noSharedTooltip series among shared tooltip series (#4546), use the hoverPoint . Otherwise,\n            // search the k-d tree.\n            stickToHoverSeries = hoverSeries && (shared ? hoverSeries.noSharedTooltip : hoverSeries.directTouch);\n            if (stickToHoverSeries && hoverPoint) {\n                kdpoint = [hoverPoint];\n\n            // Handle shared tooltip or cases where a series is not yet hovered\n            } else {\n                // Find nearest points on all series\n                each(series, function (s) {\n                    // Skip hidden series\n                    noSharedTooltip = s.noSharedTooltip && shared;\n                    directTouch = !shared && s.directTouch;\n                    if (s.visible && !noSharedTooltip && !directTouch && pick(s.options.enableMouseTracking, true)) { // #3821\n                        kdpointT = s.searchPoint(e, !noSharedTooltip && s.kdDimensions === 1); // #3828\n                        if (kdpointT) {\n                            kdpoints.push(kdpointT);\n                        }\n                    }\n                });\n                // Find absolute nearest point\n                each(kdpoints, function (p) {\n                    if (p) {\n                        // Store both closest points, using point.dist and point.distX comparisons (#4645):\n                        each(['dist', 'distX'], function (dist, k) {\n                            if (typeof p[dist] === 'number' && p[dist] < distance[k]) {\n                                distance[k] = p[dist];\n                                kdpoint[k] = p;\n                            }\n                        });\n                    }\n                });\n            }\n\n            // Remove points with different x-positions, required for shared tooltip and crosshairs (#4645):\n            if (shared) {\n                i = kdpoints.length;\n                while (i--) {\n                    if (kdpoints[i].clientX !== kdpoint[1].clientX || kdpoints[i].series.noSharedTooltip) {\n                        kdpoints.splice(i, 1);\n                    }\n                }\n            }\n\n            // Refresh tooltip for kdpoint if new hover point or tooltip was hidden // #3926, #4200\n            if (kdpoint[0] && (kdpoint[0] !== this.prevKDPoint || (tooltip && tooltip.isHidden))) {\n                // Draw tooltip if necessary\n                if (shared && !kdpoint[0].series.noSharedTooltip) {\n                    if (kdpoints.length && tooltip) {\n                        tooltip.refresh(kdpoints, e);\n                    }\n\n                    // Do mouseover on all points (#3919, #3985, #4410)\n                    each(kdpoints, function (point) {\n                        point.onMouseOver(e, point !== ((hoverSeries && hoverSeries.directTouch && hoverPoint) || kdpoint[0]));\n                    });\n                    this.prevKDPoint = kdpoint[1];\n                } else {\n                    if (tooltip) {\n                        tooltip.refresh(kdpoint[0], e);\n                    }\n                    if (!hoverSeries || !hoverSeries.directTouch) { // #4448\n                        kdpoint[0].onMouseOver(e);\n                    }\n                    this.prevKDPoint = kdpoint[0];\n                }\n\n            // Update positions (regardless of kdpoint or hoverPoint)\n            } else {\n                followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;\n                if (tooltip && followPointer && !tooltip.isHidden) {\n                    anchor = tooltip.getAnchor([{}], e);\n                    tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });\n                }\n            }\n\n            // Start the event listener to pick up the tooltip and crosshairs\n            if (!pointer._onDocumentMouseMove) {\n                pointer._onDocumentMouseMove = function (e) {\n                    if (charts[hoverChartIndex]) {\n                        charts[hoverChartIndex].pointer.onDocumentMouseMove(e);\n                    }\n                };\n                addEvent(doc, 'mousemove', pointer._onDocumentMouseMove);\n            }\n\n            // Crosshair\n            each(shared ? kdpoints : [pick(kdpoint[1], hoverPoint)], function (point) {\n                var series = point && point.series;\n                if (series) {\n                    each(['xAxis', 'yAxis', 'colorAxis'], function (coll) {\n                        if (series[coll]) {\n                            series[coll].drawCrosshair(e, point);\n                        }\n                    });\n                }\n            });\n\n        },\n\n\n\n        /**\n         * Reset the tracking by hiding the tooltip, the hover series state and the hover point\n         *\n         * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible\n         */\n        reset: function (allowMove, delay) {\n            var pointer = this,\n                chart = pointer.chart,\n                hoverSeries = chart.hoverSeries,\n                hoverPoint = chart.hoverPoint,\n                hoverPoints = chart.hoverPoints,\n                tooltip = chart.tooltip,\n                tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;\n\n            // Narrow in allowMove\n            allowMove = allowMove && tooltip && tooltipPoints;\n\n            // Check if the points have moved outside the plot area (#1003, #4736)\n            if (allowMove) {\n                each(splat(tooltipPoints), function (point) {\n                    if (point.plotX === undefined) {\n                        allowMove = false;\n                    }\n                });\n            }\n        \n            // Just move the tooltip, #349\n            if (allowMove) {\n                tooltip.refresh(tooltipPoints);\n                if (hoverPoint) { // #2500\n                    hoverPoint.setState(hoverPoint.state, true);\n                    each(chart.axes, function (axis) {\n                        if (pick(axis.options.crosshair && axis.options.crosshair.snap, true)) {\n                            axis.drawCrosshair(null, hoverPoint);\n                        }  else {\n                            axis.hideCrosshair();\n                        }\n                    });\n\n                }\n\n            // Full reset\n            } else {\n\n                if (hoverPoint) {\n                    hoverPoint.onMouseOut();\n                }\n\n                if (hoverPoints) {\n                    each(hoverPoints, function (point) {\n                        point.setState();\n                    });\n                }\n\n                if (hoverSeries) {\n                    hoverSeries.onMouseOut();\n                }\n\n                if (tooltip) {\n                    tooltip.hide(delay);\n                }\n\n                if (pointer._onDocumentMouseMove) {\n                    removeEvent(doc, 'mousemove', pointer._onDocumentMouseMove);\n                    pointer._onDocumentMouseMove = null;\n                }\n\n                // Remove crosshairs\n                each(chart.axes, function (axis) {\n                    axis.hideCrosshair();\n                });\n\n                pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;\n\n            }\n        },\n\n        /**\n         * Scale series groups to a certain scale and translation\n         */\n        scaleGroups: function (attribs, clip) {\n\n            var chart = this.chart,\n                seriesAttribs;\n\n            // Scale each series\n            each(chart.series, function (series) {\n                seriesAttribs = attribs || series.getPlotBox(); // #1701\n                if (series.xAxis && series.xAxis.zoomEnabled) {\n                    series.group.attr(seriesAttribs);\n                    if (series.markerGroup) {\n                        series.markerGroup.attr(seriesAttribs);\n                        series.markerGroup.clip(clip ? chart.clipRect : null);\n                    }\n                    if (series.dataLabelsGroup) {\n                        series.dataLabelsGroup.attr(seriesAttribs);\n                    }\n                }\n            });\n\n            // Clip\n            chart.clipRect.attr(clip || chart.clipBox);\n        },\n\n        /**\n         * Start a drag operation\n         */\n        dragStart: function (e) {\n            var chart = this.chart;\n\n            // Record the start position\n            chart.mouseIsDown = e.type;\n            chart.cancelClick = false;\n            chart.mouseDownX = this.mouseDownX = e.chartX;\n            chart.mouseDownY = this.mouseDownY = e.chartY;\n        },\n\n        /**\n         * Perform a drag operation in response to a mousemove event while the mouse is down\n         */\n        drag: function (e) {\n\n            var chart = this.chart,\n                chartOptions = chart.options.chart,\n                chartX = e.chartX,\n                chartY = e.chartY,\n                zoomHor = this.zoomHor,\n                zoomVert = this.zoomVert,\n                plotLeft = chart.plotLeft,\n                plotTop = chart.plotTop,\n                plotWidth = chart.plotWidth,\n                plotHeight = chart.plotHeight,\n                clickedInside,\n                size,\n                selectionMarker = this.selectionMarker,\n                mouseDownX = this.mouseDownX,\n                mouseDownY = this.mouseDownY,\n                panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];\n\n            // If the device supports both touch and mouse (like IE11), and we are touch-dragging\n            // inside the plot area, don't handle the mouse event. #4339.\n            if (selectionMarker && selectionMarker.touch) {\n                return;\n            }\n\n            // If the mouse is outside the plot area, adjust to cooordinates\n            // inside to prevent the selection marker from going outside\n            if (chartX < plotLeft) {\n                chartX = plotLeft;\n            } else if (chartX > plotLeft + plotWidth) {\n                chartX = plotLeft + plotWidth;\n            }\n\n            if (chartY < plotTop) {\n                chartY = plotTop;\n            } else if (chartY > plotTop + plotHeight) {\n                chartY = plotTop + plotHeight;\n            }\n\n            // determine if the mouse has moved more than 10px\n            this.hasDragged = Math.sqrt(\n                Math.pow(mouseDownX - chartX, 2) +\n                Math.pow(mouseDownY - chartY, 2)\n            );\n\n            if (this.hasDragged > 10) {\n                clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);\n\n                // make a selection\n                if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {\n                    if (!selectionMarker) {\n                        this.selectionMarker = selectionMarker = chart.renderer.rect(\n                            plotLeft,\n                            plotTop,\n                            zoomHor ? 1 : plotWidth,\n                            zoomVert ? 1 : plotHeight,\n                            0\n                        )\n                        .attr({\n                            fill: chartOptions.selectionMarkerFill || 'rgba(69,114,167,0.25)',\n                            zIndex: 7\n                        })\n                        .add();\n                    }\n                }\n\n                // adjust the width of the selection marker\n                if (selectionMarker && zoomHor) {\n                    size = chartX - mouseDownX;\n                    selectionMarker.attr({\n                        width: mathAbs(size),\n                        x: (size > 0 ? 0 : size) + mouseDownX\n                    });\n                }\n                // adjust the height of the selection marker\n                if (selectionMarker && zoomVert) {\n                    size = chartY - mouseDownY;\n                    selectionMarker.attr({\n                        height: mathAbs(size),\n                        y: (size > 0 ? 0 : size) + mouseDownY\n                    });\n                }\n\n                // panning\n                if (clickedInside && !selectionMarker && chartOptions.panning) {\n                    chart.pan(e, chartOptions.panning);\n                }\n            }\n        },\n\n        /**\n         * On mouse up or touch end across the entire document, drop the selection.\n         */\n        drop: function (e) {\n            var pointer = this,\n                chart = this.chart,\n                hasPinched = this.hasPinched;\n\n            if (this.selectionMarker) {\n                var selectionData = {\n                        originalEvent: e, // #4890\n                        xAxis: [],\n                        yAxis: []\n                    },\n                    selectionBox = this.selectionMarker,\n                    selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,\n                    selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,\n                    selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,\n                    selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,\n                    runZoom;\n\n                // a selection has been made\n                if (this.hasDragged || hasPinched) {\n\n                    // record each axis' min and max\n                    each(chart.axes, function (axis) {\n                        if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{ xAxis: 'zoomX', yAxis: 'zoomY' }[axis.coll]])) { // #859, #3569\n                            var horiz = axis.horiz,\n                                minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0, // #1207, #3075\n                                selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),\n                                selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);\n\n                            selectionData[axis.coll].push({\n                                axis: axis,\n                                min: mathMin(selectionMin, selectionMax), // for reversed axes\n                                max: mathMax(selectionMin, selectionMax)\n                            });\n                            runZoom = true;\n                        }\n                    });\n                    if (runZoom) {\n                        fireEvent(chart, 'selection', selectionData, function (args) {\n                            chart.zoom(extend(args, hasPinched ? { animation: false } : null));\n                        });\n                    }\n\n                }\n                this.selectionMarker = this.selectionMarker.destroy();\n\n                // Reset scaling preview\n                if (hasPinched) {\n                    this.scaleGroups();\n                }\n            }\n\n            // Reset all\n            if (chart) { // it may be destroyed on mouse up - #877\n                css(chart.container, { cursor: chart._cursor });\n                chart.cancelClick = this.hasDragged > 10; // #370\n                chart.mouseIsDown = this.hasDragged = this.hasPinched = false;\n                this.pinchDown = [];\n            }\n        },\n\n        onContainerMouseDown: function (e) {\n\n            e = this.normalize(e);\n\n            // issue #295, dragging not always working in Firefox\n            if (e.preventDefault) {\n                e.preventDefault();\n            }\n\n            this.dragStart(e);\n        },\n\n\n\n        onDocumentMouseUp: function (e) {\n            if (charts[hoverChartIndex]) {\n                charts[hoverChartIndex].pointer.drop(e);\n            }\n        },\n\n        /**\n         * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.\n         * Issue #149 workaround. The mouseleave event does not always fire.\n         */\n        onDocumentMouseMove: function (e) {\n            var chart = this.chart,\n                chartPosition = this.chartPosition;\n\n            e = this.normalize(e, chartPosition);\n\n            // If we're outside, hide the tooltip\n            if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&\n                    !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {\n                this.reset();\n            }\n        },\n\n        /**\n         * When mouse leaves the container, hide the tooltip.\n         */\n        onContainerMouseLeave: function (e) {\n            var chart = charts[hoverChartIndex];\n            if (chart && (e.relatedTarget || e.toElement)) { // #4886, MS Touch end fires mouseleave but with no related target\n                chart.pointer.reset();\n                chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix\n            }\n        },\n\n        // The mousemove, touchmove and touchstart event handler\n        onContainerMouseMove: function (e) {\n\n            var chart = this.chart;\n\n            if (!defined(hoverChartIndex) || !charts[hoverChartIndex] || !charts[hoverChartIndex].mouseIsDown) {\n                hoverChartIndex = chart.index;\n            }\n\n            e = this.normalize(e);\n            e.returnValue = false; // #2251, #3224\n\n            if (chart.mouseIsDown === 'mousedown') {\n                this.drag(e);\n            }\n\n            // Show the tooltip and run mouse over events (#977)\n            if ((this.inClass(e.target, 'highcharts-tracker') ||\n                    chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {\n                this.runPointActions(e);\n            }\n        },\n\n        /**\n         * Utility to detect whether an element has, or has a parent with, a specific\n         * class name. Used on detection of tracker objects and on deciding whether\n         * hovering the tooltip should cause the active series to mouse out.\n         */\n        inClass: function (element, className) {\n            var elemClassName;\n            while (element) {\n                elemClassName = attr(element, 'class');\n                if (elemClassName) {\n                    if (elemClassName.indexOf(className) !== -1) {\n                        return true;\n                    }\n                    if (elemClassName.indexOf(PREFIX + 'container') !== -1) {\n                        return false;\n                    }\n                }\n                element = element.parentNode;\n            }\n        },\n\n        onTrackerMouseOut: function (e) {\n            var series = this.chart.hoverSeries,\n                relatedTarget = e.relatedTarget || e.toElement;\n\n            if (series && relatedTarget && !series.options.stickyTracking && // #4886\n                    !this.inClass(relatedTarget, PREFIX + 'tooltip') &&\n                    !this.inClass(relatedTarget, PREFIX + 'series-' + series.index)) { // #2499, #4465\n                series.onMouseOut();\n            }\n        },\n\n        onContainerClick: function (e) {\n            var chart = this.chart,\n                hoverPoint = chart.hoverPoint,\n                plotLeft = chart.plotLeft,\n                plotTop = chart.plotTop;\n\n            e = this.normalize(e);\n\n            if (!chart.cancelClick) {\n\n                // On tracker click, fire the series and point events. #783, #1583\n                if (hoverPoint && this.inClass(e.target, PREFIX + 'tracker')) {\n\n                    // the series click event\n                    fireEvent(hoverPoint.series, 'click', extend(e, {\n                        point: hoverPoint\n                    }));\n\n                    // the point click event\n                    if (chart.hoverPoint) { // it may be destroyed (#1844)\n                        hoverPoint.firePointEvent('click', e);\n                    }\n\n                // When clicking outside a tracker, fire a chart event\n                } else {\n                    extend(e, this.getCoordinates(e));\n\n                    // fire a click event in the chart\n                    if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {\n                        fireEvent(chart, 'click', e);\n                    }\n                }\n\n\n            }\n        },\n\n        /**\n         * Set the JS DOM events on the container and document. This method should contain\n         * a one-to-one assignment between methods and their handlers. Any advanced logic should\n         * be moved to the handler reflecting the event's name.\n         */\n        setDOMEvents: function () {\n\n            var pointer = this,\n                container = pointer.chart.container;\n\n            container.onmousedown = function (e) {\n                pointer.onContainerMouseDown(e);\n            };\n            container.onmousemove = function (e) {\n                pointer.onContainerMouseMove(e);\n            };\n            container.onclick = function (e) {\n                pointer.onContainerClick(e);\n            };\n            addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);\n            if (chartCount === 1) {\n                addEvent(doc, 'mouseup', pointer.onDocumentMouseUp);\n            }\n            if (hasTouch) {\n                container.ontouchstart = function (e) {\n                    pointer.onContainerTouchStart(e);\n                };\n                container.ontouchmove = function (e) {\n                    pointer.onContainerTouchMove(e);\n                };\n                if (chartCount === 1) {\n                    addEvent(doc, 'touchend', pointer.onDocumentTouchEnd);\n                }\n            }\n\n        },\n\n        /**\n         * Destroys the Pointer object and disconnects DOM events.\n         */\n        destroy: function () {\n            var prop;\n\n            removeEvent(this.chart.container, 'mouseleave', this.onContainerMouseLeave);\n            if (!chartCount) {\n                removeEvent(doc, 'mouseup', this.onDocumentMouseUp);\n                removeEvent(doc, 'touchend', this.onDocumentTouchEnd);\n            }\n\n            // memory and CPU leak\n            clearInterval(this.tooltipTimeout);\n\n            for (prop in this) {\n                this[prop] = null;\n            }\n        }\n    };\n\n\n    /* Support for touch devices */\n    extend(Highcharts.Pointer.prototype, {\n\n        /**\n         * Run translation operations\n         */\n        pinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {\n            if (this.zoomHor || this.pinchHor) {\n                this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n            }\n            if (this.zoomVert || this.pinchVert) {\n                this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n            }\n        },\n\n        /**\n         * Run translation operations for each direction (horizontal and vertical) independently\n         */\n        pinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {\n            var chart = this.chart,\n                xy = horiz ? 'x' : 'y',\n                XY = horiz ? 'X' : 'Y',\n                sChartXY = 'chart' + XY,\n                wh = horiz ? 'width' : 'height',\n                plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],\n                selectionWH,\n                selectionXY,\n                clipXY,\n                scale = forcedScale || 1,\n                inverted = chart.inverted,\n                bounds = chart.bounds[horiz ? 'h' : 'v'],\n                singleTouch = pinchDown.length === 1,\n                touch0Start = pinchDown[0][sChartXY],\n                touch0Now = touches[0][sChartXY],\n                touch1Start = !singleTouch && pinchDown[1][sChartXY],\n                touch1Now = !singleTouch && touches[1][sChartXY],\n                outOfBounds,\n                transformScale,\n                scaleKey,\n                setScale = function () {\n                    if (!singleTouch && mathAbs(touch0Start - touch1Start) > 20) { // Don't zoom if fingers are too close on this axis\n                        scale = forcedScale || mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start);\n                    }\n\n                    clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;\n                    selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;\n                };\n\n            // Set the scale, first pass\n            setScale();\n\n            selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not\n\n            // Out of bounds\n            if (selectionXY < bounds.min) {\n                selectionXY = bounds.min;\n                outOfBounds = true;\n            } else if (selectionXY + selectionWH > bounds.max) {\n                selectionXY = bounds.max - selectionWH;\n                outOfBounds = true;\n            }\n\n            // Is the chart dragged off its bounds, determined by dataMin and dataMax?\n            if (outOfBounds) {\n\n                // Modify the touchNow position in order to create an elastic drag movement. This indicates\n                // to the user that the chart is responsive but can't be dragged further.\n                touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);\n                if (!singleTouch) {\n                    touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);\n                }\n\n                // Set the scale, second pass to adapt to the modified touchNow positions\n                setScale();\n\n            } else {\n                lastValidTouch[xy] = [touch0Now, touch1Now];\n            }\n\n            // Set geometry for clipping, selection and transformation\n            if (!inverted) {\n                clip[xy] = clipXY - plotLeftTop;\n                clip[wh] = selectionWH;\n            }\n            scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;\n            transformScale = inverted ? 1 / scale : scale;\n\n            selectionMarker[wh] = selectionWH;\n            selectionMarker[xy] = selectionXY;\n            transform[scaleKey] = scale;\n            transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));\n        },\n\n        /**\n         * Handle touch events with two touches\n         */\n        pinch: function (e) {\n\n            var self = this,\n                chart = self.chart,\n                pinchDown = self.pinchDown,\n                touches = e.touches,\n                touchesLength = touches.length,\n                lastValidTouch = self.lastValidTouch,\n                hasZoom = self.hasZoom,\n                selectionMarker = self.selectionMarker,\n                transform = {},\n                fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, PREFIX + 'tracker') &&\n                    chart.runTrackerClick) || self.runChartClick),\n                clip = {};\n\n            // Don't initiate panning until the user has pinched. This prevents us from\n            // blocking page scrolling as users scroll down a long page (#4210).\n            if (touchesLength > 1) {\n                self.initiated = true;\n            }\n\n            // On touch devices, only proceed to trigger click if a handler is defined\n            if (hasZoom && self.initiated && !fireClickEvent) {\n                e.preventDefault();\n            }\n\n            // Normalize each touch\n            map(touches, function (e) {\n                return self.normalize(e);\n            });\n\n            // Register the touch start position\n            if (e.type === 'touchstart') {\n                each(touches, function (e, i) {\n                    pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };\n                });\n                lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];\n                lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];\n\n                // Identify the data bounds in pixels\n                each(chart.axes, function (axis) {\n                    if (axis.zoomEnabled) {\n                        var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],\n                            minPixelPadding = axis.minPixelPadding,\n                            min = axis.toPixels(pick(axis.options.min, axis.dataMin)),\n                            max = axis.toPixels(pick(axis.options.max, axis.dataMax)),\n                            absMin = mathMin(min, max),\n                            absMax = mathMax(min, max);\n\n                        // Store the bounds for use in the touchmove handler\n                        bounds.min = mathMin(axis.pos, absMin - minPixelPadding);\n                        bounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);\n                    }\n                });\n                self.res = true; // reset on next move\n\n            // Event type is touchmove, handle panning and pinching\n            } else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first\n\n\n                // Set the marker\n                if (!selectionMarker) {\n                    self.selectionMarker = selectionMarker = extend({\n                        destroy: noop,\n                        touch: true\n                    }, chart.plotBox);\n                }\n\n                self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n\n                self.hasPinched = hasZoom;\n\n                // Scale and translate the groups to provide visual feedback during pinching\n                self.scaleGroups(transform, clip);\n\n                // Optionally move the tooltip on touchmove\n                if (!hasZoom && self.followTouchMove && touchesLength === 1) {\n                    this.runPointActions(self.normalize(e));\n                } else if (self.res) {\n                    self.res = false;\n                    this.reset(false, 0);\n                }\n            }\n        },\n\n        /**\n         * General touch handler shared by touchstart and touchmove.\n         */\n        touch: function (e, start) {\n            var chart = this.chart;\n\n            hoverChartIndex = chart.index;\n\n            if (e.touches.length === 1) {\n\n                e = this.normalize(e);\n\n                if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop) && !chart.openMenu) {\n\n                    // Run mouse events and display tooltip etc\n                    if (start) {\n                        this.runPointActions(e);\n                    }\n\n                    this.pinch(e);\n\n                } else if (start) {\n                    // Hide the tooltip on touching outside the plot area (#1203)\n                    this.reset();\n                }\n\n            } else if (e.touches.length === 2) {\n                this.pinch(e);\n            }\n        },\n\n        onContainerTouchStart: function (e) {\n            this.touch(e, true);\n        },\n\n        onContainerTouchMove: function (e) {\n            this.touch(e);\n        },\n\n        onDocumentTouchEnd: function (e) {\n            if (charts[hoverChartIndex]) {\n                charts[hoverChartIndex].pointer.drop(e);\n            }\n        }\n\n    });\n    if (win.PointerEvent || win.MSPointerEvent) {\n\n        // The touches object keeps track of the points being touched at all times\n        var touches = {},\n            hasPointerEvent = !!win.PointerEvent,\n            getWebkitTouches = function () {\n                var key, fake = [];\n                fake.item = function (i) {\n                    return this[i];\n                };\n                for (key in touches) {\n                    if (touches.hasOwnProperty(key)) {\n                        fake.push({\n                            pageX: touches[key].pageX,\n                            pageY: touches[key].pageY,\n                            target: touches[key].target\n                        });\n                    }\n                }\n                return fake;\n            },\n            translateMSPointer = function (e, method, wktype, func) {\n                var p;\n                if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[hoverChartIndex]) {\n                    func(e);\n                    p = charts[hoverChartIndex].pointer;\n                    p[method]({\n                        type: wktype,\n                        target: e.currentTarget,\n                        preventDefault: noop,\n                        touches: getWebkitTouches()\n                    });\n                }\n            };\n\n        /**\n         * Extend the Pointer prototype with methods for each event handler and more\n         */\n        extend(Pointer.prototype, {\n            onContainerPointerDown: function (e) {\n                translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {\n                    touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };\n                });\n            },\n            onContainerPointerMove: function (e) {\n                translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {\n                    touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };\n                    if (!touches[e.pointerId].target) {\n                        touches[e.pointerId].target = e.currentTarget;\n                    }\n                });\n            },\n            onDocumentPointerUp: function (e) {\n                translateMSPointer(e, 'onDocumentTouchEnd', 'touchend', function (e) {\n                    delete touches[e.pointerId];\n                });\n            },\n\n            /**\n             * Add or remove the MS Pointer specific events\n             */\n            batchMSEvents: function (fn) {\n                fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);\n                fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);\n                fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);\n            }\n        });\n\n        // Disable default IE actions for pinch and such on chart element\n        wrap(Pointer.prototype, 'init', function (proceed, chart, options) {\n            proceed.call(this, chart, options);\n            if (this.hasZoom) { // #4014\n                css(chart.container, {\n                    '-ms-touch-action': NONE,\n                    'touch-action': NONE\n                });\n            }\n        });\n\n        // Add IE specific touch events to chart\n        wrap(Pointer.prototype, 'setDOMEvents', function (proceed) {\n            proceed.apply(this);\n            if (this.hasZoom || this.followTouchMove) {\n                this.batchMSEvents(addEvent);\n            }\n        });\n        // Destroy MS events also\n        wrap(Pointer.prototype, 'destroy', function (proceed) {\n            this.batchMSEvents(removeEvent);\n            proceed.call(this);\n        });\n    }\n    /**\n     * The overview of the chart's series\n     */\n    var Legend = Highcharts.Legend = function (chart, options) {\n        this.init(chart, options);\n    };\n\n    Legend.prototype = {\n\n        /**\n         * Initialize the legend\n         */\n        init: function (chart, options) {\n\n            var legend = this,\n                itemStyle = options.itemStyle,\n                padding,\n                itemMarginTop = options.itemMarginTop || 0;\n\n            this.options = options;\n\n            if (!options.enabled) {\n                return;\n            }\n\n            legend.itemStyle = itemStyle;\n            legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);\n            legend.itemMarginTop = itemMarginTop;\n            legend.padding = padding = pick(options.padding, 8);\n            legend.initialItemX = padding;\n            legend.initialItemY = padding - 5; // 5 is the number of pixels above the text\n            legend.maxItemWidth = 0;\n            legend.chart = chart;\n            legend.itemHeight = 0;\n            legend.symbolWidth = pick(options.symbolWidth, 16);\n            legend.pages = [];\n\n\n            // Render it\n            legend.render();\n\n            // move checkboxes\n            addEvent(legend.chart, 'endResize', function () {\n                legend.positionCheckboxes();\n            });\n\n        },\n\n        /**\n         * Set the colors for the legend item\n         * @param {Object} item A Series or Point instance\n         * @param {Object} visible Dimmed or colored\n         */\n        colorizeItem: function (item, visible) {\n            var legend = this,\n                options = legend.options,\n                legendItem = item.legendItem,\n                legendLine = item.legendLine,\n                legendSymbol = item.legendSymbol,\n                hiddenColor = legend.itemHiddenStyle.color,\n                textColor = visible ? options.itemStyle.color : hiddenColor,\n                symbolColor = visible ? (item.legendColor || item.color || '#CCC') : hiddenColor,\n                markerOptions = item.options && item.options.marker,\n                symbolAttr = { fill: symbolColor },\n                key,\n                val;\n\n            if (legendItem) {\n                legendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE\n            }\n            if (legendLine) {\n                legendLine.attr({ stroke: symbolColor });\n            }\n\n            if (legendSymbol) {\n\n                // Apply marker options\n                if (markerOptions && legendSymbol.isMarker) { // #585\n                    symbolAttr.stroke = symbolColor;\n                    markerOptions = item.convertAttribs(markerOptions);\n                    for (key in markerOptions) {\n                        val = markerOptions[key];\n                        if (val !== UNDEFINED) {\n                            symbolAttr[key] = val;\n                        }\n                    }\n                }\n\n                legendSymbol.attr(symbolAttr);\n            }\n        },\n\n        /**\n         * Position the legend item\n         * @param {Object} item A Series or Point instance\n         */\n        positionItem: function (item) {\n            var legend = this,\n                options = legend.options,\n                symbolPadding = options.symbolPadding,\n                ltr = !options.rtl,\n                legendItemPos = item._legendItemPos,\n                itemX = legendItemPos[0],\n                itemY = legendItemPos[1],\n                checkbox = item.checkbox,\n                legendGroup = item.legendGroup;\n\n            if (legendGroup && legendGroup.element) {\n                legendGroup.translate(\n                    ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,\n                    itemY\n                );\n            }\n\n            if (checkbox) {\n                checkbox.x = itemX;\n                checkbox.y = itemY;\n            }\n        },\n\n        /**\n         * Destroy a single legend item\n         * @param {Object} item The series or point\n         */\n        destroyItem: function (item) {\n            var checkbox = item.checkbox;\n\n            // destroy SVG elements\n            each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {\n                if (item[key]) {\n                    item[key] = item[key].destroy();\n                }\n            });\n\n            if (checkbox) {\n                discardElement(item.checkbox);\n            }\n        },\n\n        /**\n         * Destroys the legend.\n         */\n        destroy: function () {\n            var legend = this,\n                legendGroup = legend.group,\n                box = legend.box;\n\n            if (box) {\n                legend.box = box.destroy();\n            }\n\n            if (legendGroup) {\n                legend.group = legendGroup.destroy();\n            }\n        },\n\n        /**\n         * Position the checkboxes after the width is determined\n         */\n        positionCheckboxes: function (scrollOffset) {\n            var alignAttr = this.group.alignAttr,\n                translateY,\n                clipHeight = this.clipHeight || this.legendHeight,\n                titleHeight = this.titleHeight;\n\n            if (alignAttr) {\n                translateY = alignAttr.translateY;\n                each(this.allItems, function (item) {\n                    var checkbox = item.checkbox,\n                        top;\n\n                    if (checkbox) {\n                        top = translateY + titleHeight + checkbox.y + (scrollOffset || 0) + 3;\n                        css(checkbox, {\n                            left: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + PX,\n                            top: top + PX,\n                            display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : NONE\n                        });\n                    }\n                });\n            }\n        },\n\n        /**\n         * Render the legend title on top of the legend\n         */\n        renderTitle: function () {\n            var options = this.options,\n                padding = this.padding,\n                titleOptions = options.title,\n                titleHeight = 0,\n                bBox;\n\n            if (titleOptions.text) {\n                if (!this.title) {\n                    this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')\n                        .attr({ zIndex: 1 })\n                        .css(titleOptions.style)\n                        .add(this.group);\n                }\n                bBox = this.title.getBBox();\n                titleHeight = bBox.height;\n                this.offsetWidth = bBox.width; // #1717\n                this.contentGroup.attr({ translateY: titleHeight });\n            }\n            this.titleHeight = titleHeight;\n        },\n\n        /**\n         * Set the legend item text\n         */\n        setText: function (item) {\n            var options = this.options;\n            item.legendItem.attr({\n                text: options.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item)\n            });\n        },\n\n        /**\n         * Render a single specific legend item\n         * @param {Object} item A series or point\n         */\n        renderItem: function (item) {\n            var legend = this,\n                chart = legend.chart,\n                renderer = chart.renderer,\n                options = legend.options,\n                horizontal = options.layout === 'horizontal',\n                symbolWidth = legend.symbolWidth,\n                symbolPadding = options.symbolPadding,\n                itemStyle = legend.itemStyle,\n                itemHiddenStyle = legend.itemHiddenStyle,\n                padding = legend.padding,\n                itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,\n                ltr = !options.rtl,\n                itemHeight,\n                widthOption = options.width,\n                itemMarginBottom = options.itemMarginBottom || 0,\n                itemMarginTop = legend.itemMarginTop,\n                initialItemX = legend.initialItemX,\n                bBox,\n                itemWidth,\n                li = item.legendItem,\n                series = item.series && item.series.drawLegendSymbol ? item.series : item,\n                seriesOptions = series.options,\n                showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,\n                useHTML = options.useHTML;\n\n            if (!li) { // generate it once, later move it\n\n                // Generate the group box\n                // A group to hold the symbol and text. Text is to be appended in Legend class.\n                item.legendGroup = renderer.g('legend-item')\n                    .attr({ zIndex: 1 })\n                    .add(legend.scrollGroup);\n\n                // Generate the list item text and add it to the group\n                item.legendItem = li = renderer.text(\n                        '',\n                        ltr ? symbolWidth + symbolPadding : -symbolPadding,\n                        legend.baseline || 0,\n                        useHTML\n                    )\n                    .css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)\n                    .attr({\n                        align: ltr ? 'left' : 'right',\n                        zIndex: 2\n                    })\n                    .add(item.legendGroup);\n\n                // Get the baseline for the first item - the font size is equal for all\n                if (!legend.baseline) {\n                    legend.fontMetrics = renderer.fontMetrics(itemStyle.fontSize, li);\n                    legend.baseline = legend.fontMetrics.f + 3 + itemMarginTop;\n                    li.attr('y', legend.baseline);\n                }\n\n                // Draw the legend symbol inside the group box\n                series.drawLegendSymbol(legend, item);\n\n                if (legend.setItemEvents) {\n                    legend.setItemEvents(item, li, useHTML, itemStyle, itemHiddenStyle);\n                }\n\n                // add the HTML checkbox on top\n                if (showCheckbox) {\n                    legend.createCheckboxForItem(item);\n                }\n            }\n\n            // Colorize the items\n            legend.colorizeItem(item, item.visible);\n\n            // Always update the text\n            legend.setText(item);\n\n            // calculate the positions for the next line\n            bBox = li.getBBox();\n\n            itemWidth = item.checkboxOffset =\n                options.itemWidth ||\n                item.legendItemWidth ||\n                symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);\n            legend.itemHeight = itemHeight = mathRound(item.legendItemHeight || bBox.height);\n\n            // if the item exceeds the width, start a new line\n            if (horizontal && legend.itemX - initialItemX + itemWidth >\n                    (widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {\n                legend.itemX = initialItemX;\n                legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;\n                legend.lastLineHeight = 0; // reset for next line (#915, #3976)\n            }\n\n            // If the item exceeds the height, start a new column\n            /*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {\n                legend.itemY = legend.initialItemY;\n                legend.itemX += legend.maxItemWidth;\n                legend.maxItemWidth = 0;\n            }*/\n\n            // Set the edge positions\n            legend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);\n            legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;\n            legend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight); // #915\n\n            // cache the position of the newly generated or reordered items\n            item._legendItemPos = [legend.itemX, legend.itemY];\n\n            // advance\n            if (horizontal) {\n                legend.itemX += itemWidth;\n\n            } else {\n                legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;\n                legend.lastLineHeight = itemHeight;\n            }\n\n            // the width of the widest item\n            legend.offsetWidth = widthOption || mathMax(\n                (horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,\n                legend.offsetWidth\n            );\n        },\n\n        /**\n         * Get all items, which is one item per series for normal series and one item per point\n         * for pie series.\n         */\n        getAllItems: function () {\n            var allItems = [];\n            each(this.chart.series, function (series) {\n                var seriesOptions = series.options;\n\n                // Handle showInLegend. If the series is linked to another series, defaults to false.\n                if (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? UNDEFINED : false, true)) {\n                    return;\n                }\n\n                // use points or series for the legend item depending on legendType\n                allItems = allItems.concat(\n                        series.legendItems ||\n                        (seriesOptions.legendType === 'point' ?\n                                series.data :\n                                series)\n                );\n            });\n            return allItems;\n        },\n\n        /**\n         * Adjust the chart margins by reserving space for the legend on only one side\n         * of the chart. If the position is set to a corner, top or bottom is reserved\n         * for horizontal legends and left or right for vertical ones.\n         */\n        adjustMargins: function (margin, spacing) {\n            var chart = this.chart,\n                options = this.options,\n                // Use the first letter of each alignment option in order to detect the side\n                alignment = options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0); // #4189 - use charAt(x) notation instead of [x] for IE7\n\n            if (this.display && !options.floating) {\n\n                each([\n                    /(lth|ct|rth)/,\n                    /(rtv|rm|rbv)/,\n                    /(rbh|cb|lbh)/,\n                    /(lbv|lm|ltv)/\n                ], function (alignments, side) {\n                    if (alignments.test(alignment) && !defined(margin[side])) {\n                        // Now we have detected on which side of the chart we should reserve space for the legend\n                        chart[marginNames[side]] = mathMax(\n                            chart[marginNames[side]],\n                            chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] +\n                                [1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] +\n                                pick(options.margin, 12) +\n                                spacing[side]\n                        );\n                    }\n                });\n            }\n        },\n\n        /**\n         * Render the legend. This method can be called both before and after\n         * chart.render. If called after, it will only rearrange items instead\n         * of creating new ones.\n         */\n        render: function () {\n            var legend = this,\n                chart = legend.chart,\n                renderer = chart.renderer,\n                legendGroup = legend.group,\n                allItems,\n                display,\n                legendWidth,\n                legendHeight,\n                box = legend.box,\n                options = legend.options,\n                padding = legend.padding,\n                legendBorderWidth = options.borderWidth,\n                legendBackgroundColor = options.backgroundColor;\n\n            legend.itemX = legend.initialItemX;\n            legend.itemY = legend.initialItemY;\n            legend.offsetWidth = 0;\n            legend.lastItemY = 0;\n\n            if (!legendGroup) {\n                legend.group = legendGroup = renderer.g('legend')\n                    .attr({ zIndex: 7 })\n                    .add();\n                legend.contentGroup = renderer.g()\n                    .attr({ zIndex: 1 }) // above background\n                    .add(legendGroup);\n                legend.scrollGroup = renderer.g()\n                    .add(legend.contentGroup);\n            }\n\n            legend.renderTitle();\n\n            // add each series or point\n            allItems = legend.getAllItems();\n\n            // sort by legendIndex\n            stableSort(allItems, function (a, b) {\n                return ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);\n            });\n\n            // reversed legend\n            if (options.reversed) {\n                allItems.reverse();\n            }\n\n            legend.allItems = allItems;\n            legend.display = display = !!allItems.length;\n\n            // render the items\n            legend.lastLineHeight = 0;\n            each(allItems, function (item) {\n                legend.renderItem(item);\n            });\n\n            // Get the box\n            legendWidth = (options.width || legend.offsetWidth) + padding;\n            legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;\n            legendHeight = legend.handleOverflow(legendHeight);\n            legendHeight += padding;\n\n            // Draw the border and/or background\n            if (legendBorderWidth || legendBackgroundColor) {\n\n                if (!box) {\n                    legend.box = box = renderer.rect(\n                        0,\n                        0,\n                        legendWidth,\n                        legendHeight,\n                        options.borderRadius,\n                        legendBorderWidth || 0\n                    ).attr({\n                        stroke: options.borderColor,\n                        'stroke-width': legendBorderWidth || 0,\n                        fill: legendBackgroundColor || NONE\n                    })\n                    .add(legendGroup)\n                    .shadow(options.shadow);\n                    box.isNew = true;\n\n                } else if (legendWidth > 0 && legendHeight > 0) {\n                    box[box.isNew ? 'attr' : 'animate'](\n                        box.crisp({ width: legendWidth, height: legendHeight })\n                    );\n                    box.isNew = false;\n                }\n\n                // hide the border if no items\n                box[display ? 'show' : 'hide']();\n            }\n\n            legend.legendWidth = legendWidth;\n            legend.legendHeight = legendHeight;\n\n            // Now that the legend width and height are established, put the items in the\n            // final position\n            each(allItems, function (item) {\n                legend.positionItem(item);\n            });\n\n            // 1.x compatibility: positioning based on style\n            /*var props = ['left', 'right', 'top', 'bottom'],\n                prop,\n                i = 4;\n            while (i--) {\n                prop = props[i];\n                if (options.style[prop] && options.style[prop] !== 'auto') {\n                    options[i < 2 ? 'align' : 'verticalAlign'] = prop;\n                    options[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);\n                }\n            }*/\n\n            if (display) {\n                legendGroup.align(extend({\n                    width: legendWidth,\n                    height: legendHeight\n                }, options), true, 'spacingBox');\n            }\n\n            if (!chart.isResizing) {\n                this.positionCheckboxes();\n            }\n        },\n\n        /**\n         * Set up the overflow handling by adding navigation with up and down arrows below the\n         * legend.\n         */\n        handleOverflow: function (legendHeight) {\n            var legend = this,\n                chart = this.chart,\n                renderer = chart.renderer,\n                options = this.options,\n                optionsY = options.y,\n                alignTop = options.verticalAlign === 'top',\n                spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,\n                maxHeight = options.maxHeight,\n                clipHeight,\n                clipRect = this.clipRect,\n                navOptions = options.navigation,\n                animation = pick(navOptions.animation, true),\n                arrowSize = navOptions.arrowSize || 12,\n                nav = this.nav,\n                pages = this.pages,\n                padding = this.padding,\n                lastY,\n                allItems = this.allItems,\n                clipToHeight = function (height) {\n                    clipRect.attr({\n                        height: height\n                    });\n\n                    // useHTML\n                    if (legend.contentGroup.div) {\n                        legend.contentGroup.div.style.clip = 'rect(' + padding + 'px,9999px,' + (padding + height) + 'px,0)';\n                    }\n                };\n\n\n            // Adjust the height\n            if (options.layout === 'horizontal') {\n                spaceHeight /= 2;\n            }\n            if (maxHeight) {\n                spaceHeight = mathMin(spaceHeight, maxHeight);\n            }\n\n            // Reset the legend height and adjust the clipping rectangle\n            pages.length = 0;\n            if (legendHeight > spaceHeight) {\n\n                this.clipHeight = clipHeight = mathMax(spaceHeight - 20 - this.titleHeight - padding, 0);\n                this.currentPage = pick(this.currentPage, 1);\n                this.fullHeight = legendHeight;\n\n                // Fill pages with Y positions so that the top of each a legend item defines\n                // the scroll top for each page (#2098)\n                each(allItems, function (item, i) {\n                    var y = item._legendItemPos[1],\n                        h = mathRound(item.legendItem.getBBox().height),\n                        len = pages.length;\n\n                    if (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {\n                        pages.push(lastY || y);\n                        len++;\n                    }\n\n                    if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {\n                        pages.push(y);\n                    }\n                    if (y !== lastY) {\n                        lastY = y;\n                    }\n                });\n\n                // Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)\n                if (!clipRect) {\n                    clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);\n                    legend.contentGroup.clip(clipRect);\n                }\n\n                clipToHeight(clipHeight);\n\n                // Add navigation elements\n                if (!nav) {\n                    this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);\n                    this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)\n                        .on('click', function () {\n                            legend.scroll(-1, animation);\n                        })\n                        .add(nav);\n                    this.pager = renderer.text('', 15, 10)\n                        .css(navOptions.style)\n                        .add(nav);\n                    this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)\n                        .on('click', function () {\n                            legend.scroll(1, animation);\n                        })\n                        .add(nav);\n                }\n\n                // Set initial position\n                legend.scroll(0);\n\n                legendHeight = spaceHeight;\n\n            } else if (nav) {\n                clipToHeight(chart.chartHeight);\n                nav.hide();\n                this.scrollGroup.attr({\n                    translateY: 1\n                });\n                this.clipHeight = 0; // #1379\n            }\n\n            return legendHeight;\n        },\n\n        /**\n         * Scroll the legend by a number of pages\n         * @param {Object} scrollBy\n         * @param {Object} animation\n         */\n        scroll: function (scrollBy, animation) {\n            var pages = this.pages,\n                pageCount = pages.length,\n                currentPage = this.currentPage + scrollBy,\n                clipHeight = this.clipHeight,\n                navOptions = this.options.navigation,\n                activeColor = navOptions.activeColor,\n                inactiveColor = navOptions.inactiveColor,\n                pager = this.pager,\n                padding = this.padding,\n                scrollOffset;\n\n            // When resizing while looking at the last page\n            if (currentPage > pageCount) {\n                currentPage = pageCount;\n            }\n\n            if (currentPage > 0) {\n\n                if (animation !== UNDEFINED) {\n                    setAnimation(animation, this.chart);\n                }\n\n                this.nav.attr({\n                    translateX: padding,\n                    translateY: clipHeight + this.padding + 7 + this.titleHeight,\n                    visibility: VISIBLE\n                });\n                this.up.attr({\n                        fill: currentPage === 1 ? inactiveColor : activeColor\n                    })\n                    .css({\n                        cursor: currentPage === 1 ? 'default' : 'pointer'\n                    });\n                pager.attr({\n                    text: currentPage + '/' + pageCount\n                });\n                this.down.attr({\n                        x: 18 + this.pager.getBBox().width, // adjust to text width\n                        fill: currentPage === pageCount ? inactiveColor : activeColor\n                    })\n                    .css({\n                        cursor: currentPage === pageCount ? 'default' : 'pointer'\n                    });\n\n                scrollOffset = -pages[currentPage - 1] + this.initialItemY;\n\n                this.scrollGroup.animate({\n                    translateY: scrollOffset\n                });\n\n                this.currentPage = currentPage;\n                this.positionCheckboxes(scrollOffset);\n            }\n\n        }\n\n    };\n\n    /*\n     * LegendSymbolMixin\n     */\n\n    var LegendSymbolMixin = Highcharts.LegendSymbolMixin = {\n\n        /**\n         * Get the series' symbol in the legend\n         *\n         * @param {Object} legend The legend object\n         * @param {Object} item The series (this) or point\n         */\n        drawRectangle: function (legend, item) {\n            var symbolHeight = legend.options.symbolHeight || legend.fontMetrics.f;\n\n            item.legendSymbol = this.chart.renderer.rect(\n                0,\n                legend.baseline - symbolHeight + 1, // #3988\n                legend.symbolWidth,\n                symbolHeight,\n                legend.options.symbolRadius || 0\n            ).attr({\n                zIndex: 3\n            }).add(item.legendGroup);\n\n        },\n\n        /**\n         * Get the series' symbol in the legend. This method should be overridable to create custom\n         * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.\n         *\n         * @param {Object} legend The legend object\n         */\n        drawLineMarker: function (legend) {\n\n            var options = this.options,\n                markerOptions = options.marker,\n                radius,\n                legendSymbol,\n                symbolWidth = legend.symbolWidth,\n                renderer = this.chart.renderer,\n                legendItemGroup = this.legendGroup,\n                verticalCenter = legend.baseline - mathRound(legend.fontMetrics.b * 0.3),\n                attr;\n\n            // Draw the line\n            if (options.lineWidth) {\n                attr = {\n                    'stroke-width': options.lineWidth\n                };\n                if (options.dashStyle) {\n                    attr.dashstyle = options.dashStyle;\n                }\n                this.legendLine = renderer.path([\n                    M,\n                    0,\n                    verticalCenter,\n                    L,\n                    symbolWidth,\n                    verticalCenter\n                ])\n                .attr(attr)\n                .add(legendItemGroup);\n            }\n\n            // Draw the marker\n            if (markerOptions && markerOptions.enabled !== false) {\n                radius = markerOptions.radius;\n                this.legendSymbol = legendSymbol = renderer.symbol(\n                    this.symbol,\n                    (symbolWidth / 2) - radius,\n                    verticalCenter - radius,\n                    2 * radius,\n                    2 * radius,\n                    markerOptions\n                )\n                .add(legendItemGroup);\n                legendSymbol.isMarker = true;\n            }\n        }\n    };\n\n    // Workaround for #2030, horizontal legend items not displaying in IE11 Preview,\n    // and for #2580, a similar drawing flaw in Firefox 26.\n    // Explore if there's a general cause for this. The problem may be related\n    // to nested group elements, as the legend item texts are within 4 group elements.\n    if (/Trident\\/7\\.0/.test(userAgent) || isFirefox) {\n        wrap(Legend.prototype, 'positionItem', function (proceed, item) {\n            var legend = this,\n                runPositionItem = function () { // If chart destroyed in sync, this is undefined (#2030)\n                    if (item._legendItemPos) {\n                        proceed.call(legend, item);\n                    }\n                };\n\n            // Do it now, for export and to get checkbox placement\n            runPositionItem();\n\n            // Do it after to work around the core issue\n            setTimeout(runPositionItem);\n        });\n    }\n    /**\n     * The Chart class\n     * @param {String|Object} renderTo The DOM element to render to, or its id\n     * @param {Object} options\n     * @param {Function} callback Function to run when the chart has loaded\n     */\n    var Chart = Highcharts.Chart = function () {\n        this.getArgs.apply(this, arguments);\n    };\n\n    Highcharts.chart = function (a, b, c) {\n        return new Chart(a, b, c);\n    };\n\n    Chart.prototype = {\n\n        /**\n         * Hook for modules\n         */\n        callbacks: [],\n\n        /**\n         * Handle the arguments passed to the constructor\n         * @returns {Array} Arguments without renderTo\n         */\n        getArgs: function () {\n            var args = [].slice.call(arguments);\n        \n            // Remove the optional first argument, renderTo, and\n            // set it on this.\n            if (isString(args[0]) || args[0].nodeName) {\n                this.renderTo = args.shift();\n            }\n            this.init(args[0], args[1]);\n        },\n\n        /**\n         * Initialize the chart\n         */\n        init: function (userOptions, callback) {\n\n            // Handle regular options\n            var options,\n                seriesOptions = userOptions.series; // skip merging data points to increase performance\n\n            userOptions.series = null;\n            options = merge(defaultOptions, userOptions); // do the merge\n            options.series = userOptions.series = seriesOptions; // set back the series data\n            this.userOptions = userOptions;\n\n            var optionsChart = options.chart;\n\n            // Create margin & spacing array\n            this.margin = this.splashArray('margin', optionsChart);\n            this.spacing = this.splashArray('spacing', optionsChart);\n\n            var chartEvents = optionsChart.events;\n\n            //this.runChartClick = chartEvents && !!chartEvents.click;\n            this.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom\n\n            this.callback = callback;\n            this.isResizing = 0;\n            this.options = options;\n            //chartTitleOptions = UNDEFINED;\n            //chartSubtitleOptions = UNDEFINED;\n\n            this.axes = [];\n            this.series = [];\n            this.hasCartesianSeries = optionsChart.showAxes;\n            //this.axisOffset = UNDEFINED;\n            //this.maxTicks = UNDEFINED; // handle the greatest amount of ticks on grouped axes\n            //this.inverted = UNDEFINED;\n            //this.loadingShown = UNDEFINED;\n            //this.container = UNDEFINED;\n            //this.chartWidth = UNDEFINED;\n            //this.chartHeight = UNDEFINED;\n            //this.marginRight = UNDEFINED;\n            //this.marginBottom = UNDEFINED;\n            //this.containerWidth = UNDEFINED;\n            //this.containerHeight = UNDEFINED;\n            //this.oldChartWidth = UNDEFINED;\n            //this.oldChartHeight = UNDEFINED;\n\n            //this.renderTo = UNDEFINED;\n            //this.renderToClone = UNDEFINED;\n\n            //this.spacingBox = UNDEFINED\n\n            //this.legend = UNDEFINED;\n\n            // Elements\n            //this.chartBackground = UNDEFINED;\n            //this.plotBackground = UNDEFINED;\n            //this.plotBGImage = UNDEFINED;\n            //this.plotBorder = UNDEFINED;\n            //this.loadingDiv = UNDEFINED;\n            //this.loadingSpan = UNDEFINED;\n\n            var chart = this,\n                eventType;\n\n            // Add the chart to the global lookup\n            chart.index = charts.length;\n            charts.push(chart);\n            chartCount++;\n\n            // Set up auto resize\n            if (optionsChart.reflow !== false) {\n                addEvent(chart, 'load', function () {\n                    chart.initReflow();\n                });\n            }\n\n            // Chart event handlers\n            if (chartEvents) {\n                for (eventType in chartEvents) {\n                    addEvent(chart, eventType, chartEvents[eventType]);\n                }\n            }\n\n            chart.xAxis = [];\n            chart.yAxis = [];\n\n            // Expose methods and variables\n            chart.animation = useCanVG ? false : pick(optionsChart.animation, true);\n            chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;\n\n            chart.firstRender();\n        },\n\n        /**\n         * Initialize an individual series, called internally before render time\n         */\n        initSeries: function (options) {\n            var chart = this,\n                optionsChart = chart.options.chart,\n                type = options.type || optionsChart.type || optionsChart.defaultSeriesType,\n                series,\n                constr = seriesTypes[type];\n\n            // No such series type\n            if (!constr) {\n                error(17, true);\n            }\n\n            series = new constr();\n            series.init(this, options);\n            return series;\n        },\n\n        /**\n         * Check whether a given point is within the plot area\n         *\n         * @param {Number} plotX Pixel x relative to the plot area\n         * @param {Number} plotY Pixel y relative to the plot area\n         * @param {Boolean} inverted Whether the chart is inverted\n         */\n        isInsidePlot: function (plotX, plotY, inverted) {\n            var x = inverted ? plotY : plotX,\n                y = inverted ? plotX : plotY;\n\n            return x >= 0 &&\n                x <= this.plotWidth &&\n                y >= 0 &&\n                y <= this.plotHeight;\n        },\n\n        /**\n         * Redraw legend, axes or series based on updated data\n         *\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         */\n        redraw: function (animation) {\n            var chart = this,\n                axes = chart.axes,\n                series = chart.series,\n                pointer = chart.pointer,\n                legend = chart.legend,\n                redrawLegend = chart.isDirtyLegend,\n                hasStackedSeries,\n                hasDirtyStacks,\n                hasCartesianSeries = chart.hasCartesianSeries,\n                isDirtyBox = chart.isDirtyBox,\n                seriesLength = series.length,\n                i = seriesLength,\n                serie,\n                renderer = chart.renderer,\n                isHiddenChart = renderer.isHidden(),\n                afterRedraw = [];\n\n            setAnimation(animation, chart);\n\n            if (isHiddenChart) {\n                chart.cloneRenderTo();\n            }\n\n            // Adjust title layout (reflow multiline text)\n            chart.layOutTitles();\n\n            // link stacked series\n            while (i--) {\n                serie = series[i];\n\n                if (serie.options.stacking) {\n                    hasStackedSeries = true;\n\n                    if (serie.isDirty) {\n                        hasDirtyStacks = true;\n                        break;\n                    }\n                }\n            }\n            if (hasDirtyStacks) { // mark others as dirty\n                i = seriesLength;\n                while (i--) {\n                    serie = series[i];\n                    if (serie.options.stacking) {\n                        serie.isDirty = true;\n                    }\n                }\n            }\n\n            // Handle updated data in the series\n            each(series, function (serie) {\n                if (serie.isDirty) {\n                    if (serie.options.legendType === 'point') {\n                        if (serie.updateTotals) {\n                            serie.updateTotals();\n                        }\n                        redrawLegend = true;\n                    }\n                }\n            });\n\n            // handle added or removed series\n            if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed\n                // draw legend graphics\n                legend.render();\n\n                chart.isDirtyLegend = false;\n            }\n\n            // reset stacks\n            if (hasStackedSeries) {\n                chart.getStacks();\n            }\n\n\n            if (hasCartesianSeries) {\n                if (!chart.isResizing) {\n\n                    // reset maxTicks\n                    chart.maxTicks = null;\n\n                    // set axes scales\n                    each(axes, function (axis) {\n                        axis.setScale();\n                    });\n                }\n            }\n\n            chart.getMargins(); // #3098\n\n            if (hasCartesianSeries) {\n                // If one axis is dirty, all axes must be redrawn (#792, #2169)\n                each(axes, function (axis) {\n                    if (axis.isDirty) {\n                        isDirtyBox = true;\n                    }\n                });\n\n                // redraw axes\n                each(axes, function (axis) {\n\n                    // Fire 'afterSetExtremes' only if extremes are set\n                    var key = axis.min + ',' + axis.max;\n                    if (axis.extKey !== key) { // #821, #4452\n                        axis.extKey = key;\n                        afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)\n                            fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751\n                            delete axis.eventArgs;\n                        });\n                    }\n                    if (isDirtyBox || hasStackedSeries) {\n                        axis.redraw();\n                    }\n                });\n            }\n\n            // the plot areas size has changed\n            if (isDirtyBox) {\n                chart.drawChartBox();\n            }\n\n\n            // redraw affected series\n            each(series, function (serie) {\n                if (serie.isDirty && serie.visible &&\n                        (!serie.isCartesian || serie.xAxis)) { // issue #153\n                    serie.redraw();\n                }\n            });\n\n            // move tooltip or reset\n            if (pointer) {\n                pointer.reset(true);\n            }\n\n            // redraw if canvas\n            renderer.draw();\n\n            // fire the event\n            fireEvent(chart, 'redraw');\n\n            if (isHiddenChart) {\n                chart.cloneRenderTo(true);\n            }\n\n            // Fire callbacks that are put on hold until after the redraw\n            each(afterRedraw, function (callback) {\n                callback.call();\n            });\n        },\n\n        /**\n         * Get an axis, series or point object by id.\n         * @param id {String} The id as given in the configuration options\n         */\n        get: function (id) {\n            var chart = this,\n                axes = chart.axes,\n                series = chart.series;\n\n            var i,\n                j,\n                points;\n\n            // search axes\n            for (i = 0; i < axes.length; i++) {\n                if (axes[i].options.id === id) {\n                    return axes[i];\n                }\n            }\n\n            // search series\n            for (i = 0; i < series.length; i++) {\n                if (series[i].options.id === id) {\n                    return series[i];\n                }\n            }\n\n            // search points\n            for (i = 0; i < series.length; i++) {\n                points = series[i].points || [];\n                for (j = 0; j < points.length; j++) {\n                    if (points[j].id === id) {\n                        return points[j];\n                    }\n                }\n            }\n            return null;\n        },\n\n        /**\n         * Create the Axis instances based on the config options\n         */\n        getAxes: function () {\n            var chart = this,\n                options = this.options,\n                xAxisOptions = options.xAxis = splat(options.xAxis || {}),\n                yAxisOptions = options.yAxis = splat(options.yAxis || {}),\n                optionsArray;\n\n            // make sure the options are arrays and add some members\n            each(xAxisOptions, function (axis, i) {\n                axis.index = i;\n                axis.isX = true;\n            });\n\n            each(yAxisOptions, function (axis, i) {\n                axis.index = i;\n            });\n\n            // concatenate all axis options into one array\n            optionsArray = xAxisOptions.concat(yAxisOptions);\n\n            each(optionsArray, function (axisOptions) {\n                new Axis(chart, axisOptions); // eslint-disable-line no-new\n            });\n        },\n\n\n        /**\n         * Get the currently selected points from all series\n         */\n        getSelectedPoints: function () {\n            var points = [];\n            each(this.series, function (serie) {\n                points = points.concat(grep(serie.points || [], function (point) {\n                    return point.selected;\n                }));\n            });\n            return points;\n        },\n\n        /**\n         * Get the currently selected series\n         */\n        getSelectedSeries: function () {\n            return grep(this.series, function (serie) {\n                return serie.selected;\n            });\n        },\n\n        /**\n         * Show the title and subtitle of the chart\n         *\n         * @param titleOptions {Object} New title options\n         * @param subtitleOptions {Object} New subtitle options\n         *\n         */\n        setTitle: function (titleOptions, subtitleOptions, redraw) {\n            var chart = this,\n                options = chart.options,\n                chartTitleOptions,\n                chartSubtitleOptions;\n\n            chartTitleOptions = options.title = merge(options.title, titleOptions);\n            chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);\n\n            // add title and subtitle\n            each([\n                ['title', titleOptions, chartTitleOptions],\n                ['subtitle', subtitleOptions, chartSubtitleOptions]\n            ], function (arr) {\n                var name = arr[0],\n                    title = chart[name],\n                    titleOptions = arr[1],\n                    chartTitleOptions = arr[2];\n\n                if (title && titleOptions) {\n                    chart[name] = title = title.destroy(); // remove old\n                }\n\n                if (chartTitleOptions && chartTitleOptions.text && !title) {\n                    chart[name] = chart.renderer.text(\n                        chartTitleOptions.text,\n                        0,\n                        0,\n                        chartTitleOptions.useHTML\n                    )\n                    .attr({\n                        align: chartTitleOptions.align,\n                        'class': PREFIX + name,\n                        zIndex: chartTitleOptions.zIndex || 4\n                    })\n                    .css(chartTitleOptions.style)\n                    .add();\n                }\n            });\n            chart.layOutTitles(redraw);\n        },\n\n        /**\n         * Lay out the chart titles and cache the full offset height for use in getMargins\n         */\n        layOutTitles: function (redraw) {\n            var titleOffset = 0,\n                title = this.title,\n                subtitle = this.subtitle,\n                options = this.options,\n                titleOptions = options.title,\n                subtitleOptions = options.subtitle,\n                requiresDirtyBox,\n                renderer = this.renderer,\n                autoWidth = this.spacingBox.width - 44; // 44 makes room for default context button\n\n            if (title) {\n                title\n                    .css({ width: (titleOptions.width || autoWidth) + PX })\n                    .align(extend({\n                        y: renderer.fontMetrics(titleOptions.style.fontSize, title).b - 3\n                    }, titleOptions), false, 'spacingBox');\n\n                if (!titleOptions.floating && !titleOptions.verticalAlign) {\n                    titleOffset = title.getBBox().height;\n                }\n            }\n            if (subtitle) {\n                subtitle\n                    .css({ width: (subtitleOptions.width || autoWidth) + PX })\n                    .align(extend({\n                        y: titleOffset + (titleOptions.margin - 13) + renderer.fontMetrics(subtitleOptions.style.fontSize, title).b\n                    }, subtitleOptions), false, 'spacingBox');\n\n                if (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {\n                    titleOffset = mathCeil(titleOffset + subtitle.getBBox().height);\n                }\n            }\n\n            requiresDirtyBox = this.titleOffset !== titleOffset;\n            this.titleOffset = titleOffset; // used in getMargins\n\n            if (!this.isDirtyBox && requiresDirtyBox) {\n                this.isDirtyBox = requiresDirtyBox;\n                // Redraw if necessary (#2719, #2744)\n                if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {\n                    this.redraw();\n                }\n            }\n        },\n\n        /**\n         * Get chart width and height according to options and container size\n         */\n        getChartSize: function () {\n            var chart = this,\n                optionsChart = chart.options.chart,\n                widthOption = optionsChart.width,\n                heightOption = optionsChart.height,\n                renderTo = chart.renderToClone || chart.renderTo;\n\n            // Get inner width and height\n            if (!defined(widthOption)) {\n                chart.containerWidth = getStyle(renderTo, 'width');\n            }\n            if (!defined(heightOption)) {\n                chart.containerHeight = getStyle(renderTo, 'height');\n            }\n\n            chart.chartWidth = mathMax(0, widthOption || chart.containerWidth || 600); // #1393, 1460\n            chart.chartHeight = mathMax(0, pick(heightOption,\n                // the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:\n                chart.containerHeight > 19 ? chart.containerHeight : 400));\n        },\n\n        /**\n         * Create a clone of the chart's renderTo div and place it outside the viewport to allow\n         * size computation on chart.render and chart.redraw\n         */\n        cloneRenderTo: function (revert) {\n            var clone = this.renderToClone,\n                container = this.container;\n\n            // Destroy the clone and bring the container back to the real renderTo div\n            if (revert) {\n                if (clone) {\n                    this.renderTo.appendChild(container);\n                    discardElement(clone);\n                    delete this.renderToClone;\n                }\n\n            // Set up the clone\n            } else {\n                if (container && container.parentNode === this.renderTo) {\n                    this.renderTo.removeChild(container); // do not clone this\n                }\n                this.renderToClone = clone = this.renderTo.cloneNode(0);\n                css(clone, {\n                    position: ABSOLUTE,\n                    top: '-9999px',\n                    display: 'block' // #833\n                });\n                if (clone.style.setProperty) { // #2631\n                    clone.style.setProperty('display', 'block', 'important');\n                }\n                doc.body.appendChild(clone);\n                if (container) {\n                    clone.appendChild(container);\n                }\n            }\n        },\n\n        /**\n         * Get the containing element, determine the size and create the inner container\n         * div to hold the chart\n         */\n        getContainer: function () {\n            var chart = this,\n                container,\n                options = chart.options,\n                optionsChart = options.chart,\n                chartWidth,\n                chartHeight,\n                renderTo = chart.renderTo,\n                indexAttrName = 'data-highcharts-chart',\n                oldChartIndex,\n                Ren,\n                containerId = 'highcharts-' + idCounter++;\n\n            if (!renderTo) {\n                chart.renderTo = renderTo = optionsChart.renderTo;\n            }\n        \n            if (isString(renderTo)) {\n                chart.renderTo = renderTo = doc.getElementById(renderTo);\n            }\n\n            // Display an error if the renderTo is wrong\n            if (!renderTo) {\n                error(13, true);\n            }\n\n            // If the container already holds a chart, destroy it. The check for hasRendered is there\n            // because web pages that are saved to disk from the browser, will preserve the data-highcharts-chart\n            // attribute and the SVG contents, but not an interactive chart. So in this case,\n            // charts[oldChartIndex] will point to the wrong chart if any (#2609).\n            oldChartIndex = pInt(attr(renderTo, indexAttrName));\n            if (!isNaN(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {\n                charts[oldChartIndex].destroy();\n            }\n\n            // Make a reference to the chart from the div\n            attr(renderTo, indexAttrName, chart.index);\n\n            // remove previous chart\n            renderTo.innerHTML = '';\n\n            // If the container doesn't have an offsetWidth, it has or is a child of a node\n            // that has display:none. We need to temporarily move it out to a visible\n            // state to determine the size, else the legend and tooltips won't render\n            // properly. The allowClone option is used in sparklines as a micro optimization,\n            // saving about 1-2 ms each chart.\n            if (!optionsChart.skipClone && !renderTo.offsetWidth) {\n                chart.cloneRenderTo();\n            }\n\n            // get the width and height\n            chart.getChartSize();\n            chartWidth = chart.chartWidth;\n            chartHeight = chart.chartHeight;\n\n            // create the inner container\n            chart.container = container = createElement(DIV, {\n                    className: PREFIX + 'container' +\n                        (optionsChart.className ? ' ' + optionsChart.className : ''),\n                    id: containerId\n                }, extend({\n                    position: RELATIVE,\n                    overflow: HIDDEN, // needed for context menu (avoid scrollbars) and\n                        // content overflow in IE\n                    width: chartWidth + PX,\n                    height: chartHeight + PX,\n                    textAlign: 'left',\n                    lineHeight: 'normal', // #427\n                    zIndex: 0, // #1072\n                    '-webkit-tap-highlight-color': 'rgba(0,0,0,0)'\n                }, optionsChart.style),\n                chart.renderToClone || renderTo\n            );\n\n            // cache the cursor (#1650)\n            chart._cursor = container.style.cursor;\n\n            // Initialize the renderer\n            Ren = Highcharts[optionsChart.renderer] || Renderer;\n            chart.renderer = new Ren(\n                container,\n                chartWidth,\n                chartHeight,\n                optionsChart.style,\n                optionsChart.forExport,\n                options.exporting && options.exporting.allowHTML\n            );\n\n            if (useCanVG) {\n                // If we need canvg library, extend and configure the renderer\n                // to get the tracker for translating mouse events\n                chart.renderer.create(chart, container, chartWidth, chartHeight);\n            }\n            // Add a reference to the charts index\n            chart.renderer.chartIndex = chart.index;\n        },\n\n        /**\n         * Calculate margins by rendering axis labels in a preliminary position. Title,\n         * subtitle and legend have already been rendered at this stage, but will be\n         * moved into their final positions\n         */\n        getMargins: function (skipAxes) {\n            var chart = this,\n                spacing = chart.spacing,\n                margin = chart.margin,\n                titleOffset = chart.titleOffset;\n\n            chart.resetMargins();\n\n            // Adjust for title and subtitle\n            if (titleOffset && !defined(margin[0])) {\n                chart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);\n            }\n\n            // Adjust for legend\n            chart.legend.adjustMargins(margin, spacing);\n\n            // adjust for scroller\n            if (chart.extraBottomMargin) {\n                chart.marginBottom += chart.extraBottomMargin;\n            }\n            if (chart.extraTopMargin) {\n                chart.plotTop += chart.extraTopMargin;\n            }\n            if (!skipAxes) {\n                this.getAxisMargins();\n            }\n        },\n\n        getAxisMargins: function () {\n\n            var chart = this,\n                axisOffset = chart.axisOffset = [0, 0, 0, 0], // top, right, bottom, left\n                margin = chart.margin;\n\n            // pre-render axes to get labels offset width\n            if (chart.hasCartesianSeries) {\n                each(chart.axes, function (axis) {\n                    if (axis.visible) {\n                        axis.getOffset();\n                    }\n                });\n            }\n\n            // Add the axis offsets\n            each(marginNames, function (m, side) {\n                if (!defined(margin[side])) {\n                    chart[m] += axisOffset[side];\n                }\n            });\n\n            chart.setChartSize();\n\n        },\n\n        /**\n         * Resize the chart to its container if size is not explicitly set\n         */\n        reflow: function (e) {\n            var chart = this,\n                optionsChart = chart.options.chart,\n                renderTo = chart.renderTo,\n                width = optionsChart.width || getStyle(renderTo, 'width'),\n                height = optionsChart.height || getStyle(renderTo, 'height'),\n                target = e ? e.target : win;\n\n            // Width and height checks for display:none. Target is doc in IE8 and Opera,\n            // win in Firefox, Chrome and IE9.\n            if (!chart.hasUserSize && !chart.isPrinting && width && height && (target === win || target === doc)) { // #1093\n                if (width !== chart.containerWidth || height !== chart.containerHeight) {\n                    clearTimeout(chart.reflowTimeout);\n                    // When called from window.resize, e is set, else it's called directly (#2224)\n                    chart.reflowTimeout = syncTimeout(function () {\n                        if (chart.container) { // It may have been destroyed in the meantime (#1257)\n                            chart.setSize(width, height, false);\n                            chart.hasUserSize = null;\n                        }\n                    }, e ? 100 : 0);\n                }\n                chart.containerWidth = width;\n                chart.containerHeight = height;\n            }\n        },\n\n        /**\n         * Add the event handlers necessary for auto resizing\n         */\n        initReflow: function () {\n            var chart = this,\n                reflow = function (e) {\n                    chart.reflow(e);\n                };\n\n\n            addEvent(win, 'resize', reflow);\n            addEvent(chart, 'destroy', function () {\n                removeEvent(win, 'resize', reflow);\n            });\n        },\n\n        /**\n         * Resize the chart to a given width and height\n         * @param {Number} width\n         * @param {Number} height\n         * @param {Object|Boolean} animation\n         */\n        setSize: function (width, height, animation) {\n            var chart = this,\n                chartWidth,\n                chartHeight,\n                renderer = chart.renderer,\n                globalAnimation;\n\n            // Handle the isResizing counter\n            chart.isResizing += 1;\n        \n            // set the animation for the current process\n            setAnimation(animation, chart);\n\n            chart.oldChartHeight = chart.chartHeight;\n            chart.oldChartWidth = chart.chartWidth;\n            if (defined(width)) {\n                chart.chartWidth = chartWidth = mathMax(0, mathRound(width));\n                chart.hasUserSize = !!chartWidth;\n            }\n            if (defined(height)) {\n                chart.chartHeight = chartHeight = mathMax(0, mathRound(height));\n            }\n\n            // Resize the container with the global animation applied if enabled (#2503)\n            globalAnimation = renderer.globalAnimation;\n            (globalAnimation ? animate : css)(chart.container, {\n                width: chartWidth + PX,\n                height: chartHeight + PX\n            }, globalAnimation);\n\n            chart.setChartSize(true);\n            renderer.setSize(chartWidth, chartHeight, animation);\n\n            // handle axes\n            chart.maxTicks = null;\n            each(chart.axes, function (axis) {\n                axis.isDirty = true;\n                axis.setScale();\n            });\n\n            // make sure non-cartesian series are also handled\n            each(chart.series, function (serie) {\n                serie.isDirty = true;\n            });\n\n            chart.isDirtyLegend = true; // force legend redraw\n            chart.isDirtyBox = true; // force redraw of plot and chart border\n\n            chart.layOutTitles(); // #2857\n            chart.getMargins();\n\n            chart.redraw(animation);\n\n\n            chart.oldChartHeight = null;\n            fireEvent(chart, 'resize');\n\n            // Fire endResize and set isResizing back. If animation is disabled, fire without delay\n            globalAnimation = renderer.globalAnimation; // Reassign it before using it, it may have changed since the top of this function.\n            syncTimeout(function () {\n                if (chart) {\n                    fireEvent(chart, 'endResize', null, function () {\n                        chart.isResizing -= 1;\n                    });\n                }\n            }, globalAnimation === false ? 0 : ((globalAnimation && globalAnimation.duration) || 500));\n        },\n\n        /**\n         * Set the public chart properties. This is done before and after the pre-render\n         * to determine margin sizes\n         */\n        setChartSize: function (skipAxes) {\n            var chart = this,\n                inverted = chart.inverted,\n                renderer = chart.renderer,\n                chartWidth = chart.chartWidth,\n                chartHeight = chart.chartHeight,\n                optionsChart = chart.options.chart,\n                spacing = chart.spacing,\n                clipOffset = chart.clipOffset,\n                clipX,\n                clipY,\n                plotLeft,\n                plotTop,\n                plotWidth,\n                plotHeight,\n                plotBorderWidth;\n\n            chart.plotLeft = plotLeft = mathRound(chart.plotLeft);\n            chart.plotTop = plotTop = mathRound(chart.plotTop);\n            chart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));\n            chart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));\n\n            chart.plotSizeX = inverted ? plotHeight : plotWidth;\n            chart.plotSizeY = inverted ? plotWidth : plotHeight;\n\n            chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;\n\n            // Set boxes used for alignment\n            chart.spacingBox = renderer.spacingBox = {\n                x: spacing[3],\n                y: spacing[0],\n                width: chartWidth - spacing[3] - spacing[1],\n                height: chartHeight - spacing[0] - spacing[2]\n            };\n            chart.plotBox = renderer.plotBox = {\n                x: plotLeft,\n                y: plotTop,\n                width: plotWidth,\n                height: plotHeight\n            };\n\n            plotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);\n            clipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);\n            clipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);\n            chart.clipBox = {\n                x: clipX,\n                y: clipY,\n                width: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX),\n                height: mathMax(0, mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY))\n            };\n\n            if (!skipAxes) {\n                each(chart.axes, function (axis) {\n                    axis.setAxisSize();\n                    axis.setAxisTranslation();\n                });\n            }\n        },\n\n        /**\n         * Initial margins before auto size margins are applied\n         */\n        resetMargins: function () {\n            var chart = this;\n\n            each(marginNames, function (m, side) {\n                chart[m] = pick(chart.margin[side], chart.spacing[side]);\n            });\n            chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left\n            chart.clipOffset = [0, 0, 0, 0];\n        },\n\n        /**\n         * Draw the borders and backgrounds for chart and plot area\n         */\n        drawChartBox: function () {\n            var chart = this,\n                optionsChart = chart.options.chart,\n                renderer = chart.renderer,\n                chartWidth = chart.chartWidth,\n                chartHeight = chart.chartHeight,\n                chartBackground = chart.chartBackground,\n                plotBackground = chart.plotBackground,\n                plotBorder = chart.plotBorder,\n                plotBGImage = chart.plotBGImage,\n                chartBorderWidth = optionsChart.borderWidth || 0,\n                chartBackgroundColor = optionsChart.backgroundColor,\n                plotBackgroundColor = optionsChart.plotBackgroundColor,\n                plotBackgroundImage = optionsChart.plotBackgroundImage,\n                plotBorderWidth = optionsChart.plotBorderWidth || 0,\n                mgn,\n                bgAttr,\n                plotLeft = chart.plotLeft,\n                plotTop = chart.plotTop,\n                plotWidth = chart.plotWidth,\n                plotHeight = chart.plotHeight,\n                plotBox = chart.plotBox,\n                clipRect = chart.clipRect,\n                clipBox = chart.clipBox;\n\n            // Chart area\n            mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);\n\n            if (chartBorderWidth || chartBackgroundColor) {\n                if (!chartBackground) {\n\n                    bgAttr = {\n                        fill: chartBackgroundColor || NONE\n                    };\n                    if (chartBorderWidth) { // #980\n                        bgAttr.stroke = optionsChart.borderColor;\n                        bgAttr['stroke-width'] = chartBorderWidth;\n                    }\n                    chart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,\n                            optionsChart.borderRadius, chartBorderWidth)\n                        .attr(bgAttr)\n                        .addClass(PREFIX + 'background')\n                        .add()\n                        .shadow(optionsChart.shadow);\n\n                } else { // resize\n                    chartBackground.animate(\n                        chartBackground.crisp({ width: chartWidth - mgn, height: chartHeight - mgn })\n                    );\n                }\n            }\n\n\n            // Plot background\n            if (plotBackgroundColor) {\n                if (!plotBackground) {\n                    chart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)\n                        .attr({\n                            fill: plotBackgroundColor\n                        })\n                        .add()\n                        .shadow(optionsChart.plotShadow);\n                } else {\n                    plotBackground.animate(plotBox);\n                }\n            }\n            if (plotBackgroundImage) {\n                if (!plotBGImage) {\n                    chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)\n                        .add();\n                } else {\n                    plotBGImage.animate(plotBox);\n                }\n            }\n\n            // Plot clip\n            if (!clipRect) {\n                chart.clipRect = renderer.clipRect(clipBox);\n            } else {\n                clipRect.animate({\n                    width: clipBox.width,\n                    height: clipBox.height\n                });\n            }\n\n            // Plot area border\n            if (plotBorderWidth) {\n                if (!plotBorder) {\n                    chart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth)\n                        .attr({\n                            stroke: optionsChart.plotBorderColor,\n                            'stroke-width': plotBorderWidth,\n                            fill: NONE,\n                            zIndex: 1\n                        })\n                        .add();\n                } else {\n                    plotBorder.strokeWidth = -plotBorderWidth;\n                    plotBorder.animate(\n                        plotBorder.crisp({ x: plotLeft, y: plotTop, width: plotWidth, height: plotHeight }) //#3282 plotBorder should be negative\n                    );\n                }\n            }\n\n            // reset\n            chart.isDirtyBox = false;\n        },\n\n        /**\n         * Detect whether a certain chart property is needed based on inspecting its options\n         * and series. This mainly applies to the chart.invert property, and in extensions to\n         * the chart.angular and chart.polar properties.\n         */\n        propFromSeries: function () {\n            var chart = this,\n                optionsChart = chart.options.chart,\n                klass,\n                seriesOptions = chart.options.series,\n                i,\n                value;\n\n\n            each(['inverted', 'angular', 'polar'], function (key) {\n\n                // The default series type's class\n                klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];\n\n                // Get the value from available chart-wide properties\n                value = (\n                    chart[key] || // 1. it is set before\n                    optionsChart[key] || // 2. it is set in the options\n                    (klass && klass.prototype[key]) // 3. it's default series class requires it\n                );\n\n                // 4. Check if any the chart's series require it\n                i = seriesOptions && seriesOptions.length;\n                while (!value && i--) {\n                    klass = seriesTypes[seriesOptions[i].type];\n                    if (klass && klass.prototype[key]) {\n                        value = true;\n                    }\n                }\n\n                // Set the chart property\n                chart[key] = value;\n            });\n\n        },\n\n        /**\n         * Link two or more series together. This is done initially from Chart.render,\n         * and after Chart.addSeries and Series.remove.\n         */\n        linkSeries: function () {\n            var chart = this,\n                chartSeries = chart.series;\n\n            // Reset links\n            each(chartSeries, function (series) {\n                series.linkedSeries.length = 0;\n            });\n\n            // Apply new links\n            each(chartSeries, function (series) {\n                var linkedTo = series.options.linkedTo;\n                if (isString(linkedTo)) {\n                    if (linkedTo === ':previous') {\n                        linkedTo = chart.series[series.index - 1];\n                    } else {\n                        linkedTo = chart.get(linkedTo);\n                    }\n                    if (linkedTo) {\n                        linkedTo.linkedSeries.push(series);\n                        series.linkedParent = linkedTo;\n                        series.visible = pick(series.options.visible, linkedTo.options.visible, series.visible); // #3879\n                    }\n                }\n            });\n        },\n\n        /**\n         * Render series for the chart\n         */\n        renderSeries: function () {\n            each(this.series, function (serie) {\n                serie.translate();\n                serie.render();\n            });\n        },\n\n        /**\n         * Render labels for the chart\n         */\n        renderLabels: function () {\n            var chart = this,\n                labels = chart.options.labels;\n            if (labels.items) {\n                each(labels.items, function (label) {\n                    var style = extend(labels.style, label.style),\n                        x = pInt(style.left) + chart.plotLeft,\n                        y = pInt(style.top) + chart.plotTop + 12;\n\n                    // delete to prevent rewriting in IE\n                    delete style.left;\n                    delete style.top;\n\n                    chart.renderer.text(\n                        label.html,\n                        x,\n                        y\n                    )\n                    .attr({ zIndex: 2 })\n                    .css(style)\n                    .add();\n\n                });\n            }\n        },\n\n        /**\n         * Render all graphics for the chart\n         */\n        render: function () {\n            var chart = this,\n                axes = chart.axes,\n                renderer = chart.renderer,\n                options = chart.options,\n                tempWidth,\n                tempHeight,\n                redoHorizontal,\n                redoVertical;\n\n            // Title\n            chart.setTitle();\n\n\n            // Legend\n            chart.legend = new Legend(chart, options.legend);\n\n            // Get stacks\n            if (chart.getStacks) {\n                chart.getStacks();\n            }\n\n            // Get chart margins\n            chart.getMargins(true);\n            chart.setChartSize();\n\n            // Record preliminary dimensions for later comparison\n            tempWidth = chart.plotWidth;\n            tempHeight = chart.plotHeight = chart.plotHeight - 21; // 21 is the most common correction for X axis labels\n\n            // Get margins by pre-rendering axes\n            each(axes, function (axis) {\n                axis.setScale();\n            });\n            chart.getAxisMargins();\n\n            // If the plot area size has changed significantly, calculate tick positions again\n            redoHorizontal = tempWidth / chart.plotWidth > 1.1;\n            redoVertical = tempHeight / chart.plotHeight > 1.05; // Height is more sensitive\n\n            if (redoHorizontal || redoVertical) {\n\n                chart.maxTicks = null; // reset for second pass\n                each(axes, function (axis) {\n                    if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {\n                        axis.setTickInterval(true); // update to reflect the new margins\n                    }\n                });\n                chart.getMargins(); // second pass to check for new labels\n            }\n\n            // Draw the borders and backgrounds\n            chart.drawChartBox();\n\n\n            // Axes\n            if (chart.hasCartesianSeries) {\n                each(axes, function (axis) {\n                    if (axis.visible) {\n                        axis.render();\n                    }\n                });\n            }\n\n            // The series\n            if (!chart.seriesGroup) {\n                chart.seriesGroup = renderer.g('series-group')\n                    .attr({ zIndex: 3 })\n                    .add();\n            }\n            chart.renderSeries();\n\n            // Labels\n            chart.renderLabels();\n\n            // Credits\n            chart.showCredits(options.credits);\n\n            // Set flag\n            chart.hasRendered = true;\n\n        },\n\n        /**\n         * Show chart credits based on config options\n         */\n        showCredits: function (credits) {\n            if (credits.enabled && !this.credits) {\n                this.credits = this.renderer.text(\n                    credits.text,\n                    0,\n                    0\n                )\n                .on('click', function () {\n                    if (credits.href) {\n                        win.location.href = credits.href;\n                    }\n                })\n                .attr({\n                    align: credits.position.align,\n                    zIndex: 8\n                })\n                .css(credits.style)\n                .add()\n                .align(credits.position);\n            }\n        },\n\n        /**\n         * Clean up memory usage\n         */\n        destroy: function () {\n            var chart = this,\n                axes = chart.axes,\n                series = chart.series,\n                container = chart.container,\n                i,\n                parentNode = container && container.parentNode;\n\n            // fire the chart.destoy event\n            fireEvent(chart, 'destroy');\n\n            // Delete the chart from charts lookup array\n            charts[chart.index] = UNDEFINED;\n            chartCount--;\n            chart.renderTo.removeAttribute('data-highcharts-chart');\n\n            // remove events\n            removeEvent(chart);\n\n            // ==== Destroy collections:\n            // Destroy axes\n            i = axes.length;\n            while (i--) {\n                axes[i] = axes[i].destroy();\n            }\n\n            // Destroy each series\n            i = series.length;\n            while (i--) {\n                series[i] = series[i].destroy();\n            }\n\n            // ==== Destroy chart properties:\n            each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage',\n                    'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'scroller',\n                    'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {\n                var prop = chart[name];\n\n                if (prop && prop.destroy) {\n                    chart[name] = prop.destroy();\n                }\n            });\n\n            // remove container and all SVG\n            if (container) { // can break in IE when destroyed before finished loading\n                container.innerHTML = '';\n                removeEvent(container);\n                if (parentNode) {\n                    discardElement(container);\n                }\n\n            }\n\n            // clean it all up\n            for (i in chart) {\n                delete chart[i];\n            }\n\n        },\n\n\n        /**\n         * VML namespaces can't be added until after complete. Listening\n         * for Perini's doScroll hack is not enough.\n         */\n        isReadyToRender: function () {\n            var chart = this;\n\n            // Note: win == win.top is required\n            if ((!hasSVG && (win == win.top && doc.readyState !== 'complete')) || (useCanVG && !win.canvg)) { // eslint-disable-line eqeqeq\n                if (useCanVG) {\n                    // Delay rendering until canvg library is downloaded and ready\n                    CanVGController.push(function () {\n                        chart.firstRender();\n                    }, chart.options.global.canvasToolsURL);\n                } else {\n                    doc.attachEvent('onreadystatechange', function () {\n                        doc.detachEvent('onreadystatechange', chart.firstRender);\n                        if (doc.readyState === 'complete') {\n                            chart.firstRender();\n                        }\n                    });\n                }\n                return false;\n            }\n            return true;\n        },\n\n        /**\n         * Prepare for first rendering after all data are loaded\n         */\n        firstRender: function () {\n            var chart = this,\n                options = chart.options;\n\n            // Check whether the chart is ready to render\n            if (!chart.isReadyToRender()) {\n                return;\n            }\n\n            // Create the container\n            chart.getContainer();\n\n            // Run an early event after the container and renderer are established\n            fireEvent(chart, 'init');\n\n\n            chart.resetMargins();\n            chart.setChartSize();\n\n            // Set the common chart properties (mainly invert) from the given series\n            chart.propFromSeries();\n\n            // get axes\n            chart.getAxes();\n\n            // Initialize the series\n            each(options.series || [], function (serieOptions) {\n                chart.initSeries(serieOptions);\n            });\n\n            chart.linkSeries();\n\n            // Run an event after axes and series are initialized, but before render. At this stage,\n            // the series data is indexed and cached in the xData and yData arrays, so we can access\n            // those before rendering. Used in Highstock.\n            fireEvent(chart, 'beforeRender');\n\n            // depends on inverted and on margins being set\n            if (Highcharts.Pointer) {\n                chart.pointer = new Pointer(chart, options);\n            }\n\n            chart.render();\n\n            // add canvas\n            chart.renderer.draw();\n        \n            // Fire the load event if there are no external images\n            if (!chart.renderer.imgCount) {\n                chart.onload();\n            }\n\n            // If the chart was rendered outside the top container, put it back in (#3679)\n            chart.cloneRenderTo(true);\n\n        },\n\n        /** \n         * On chart load\n         */\n        onload: function () {\n            var chart = this;\n\n            // Run callbacks\n            each([this.callback].concat(this.callbacks), function (fn) {\n                if (fn && chart.index !== undefined) { // Chart destroyed in its own callback (#3600)\n                    fn.apply(chart, [chart]);\n                }\n            });\n\n            // Fire the load event if there are no external images\n            if (!chart.renderer.imgCount) {\n                fireEvent(chart, 'load');\n            }\n        },\n\n        /**\n        * Creates arrays for spacing and margin from given options.\n        */\n        splashArray: function (target, options) {\n            var oVar = options[target],\n                tArray = isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];\n\n            return [pick(options[target + 'Top'], tArray[0]),\n                    pick(options[target + 'Right'], tArray[1]),\n                    pick(options[target + 'Bottom'], tArray[2]),\n                    pick(options[target + 'Left'], tArray[3])];\n        }\n    }; // end Chart\n\n    var CenteredSeriesMixin = Highcharts.CenteredSeriesMixin = {\n        /**\n         * Get the center of the pie based on the size and center options relative to the\n         * plot area. Borrowed by the polar and gauge series types.\n         */\n        getCenter: function () {\n\n            var options = this.options,\n                chart = this.chart,\n                slicingRoom = 2 * (options.slicedOffset || 0),\n                handleSlicingRoom,\n                plotWidth = chart.plotWidth - 2 * slicingRoom,\n                plotHeight = chart.plotHeight - 2 * slicingRoom,\n                centerOption = options.center,\n                positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],\n                smallestSize = mathMin(plotWidth, plotHeight),\n                i,\n                value;\n\n            for (i = 0; i < 4; ++i) {\n                value = positions[i];\n                handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));\n\n                // i == 0: centerX, relative to width\n                // i == 1: centerY, relative to height\n                // i == 2: size, relative to smallestSize\n                // i == 3: innerSize, relative to size\n                positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) +\n                    (handleSlicingRoom ? slicingRoom : 0);\n\n            }\n            // innerSize cannot be larger than size (#3632)\n            if (positions[3] > positions[2]) {\n                positions[3] = positions[2];\n            }\n            return positions;\n        }\n    };\n\n    /**\n     * The Point object and prototype. Inheritable and used as base for PiePoint\n     */\n    var Point = function () {};\n    Point.prototype = {\n\n        /**\n         * Initialize the point\n         * @param {Object} series The series object containing this point\n         * @param {Object} options The data in either number, array or object format\n         */\n        init: function (series, options, x) {\n\n            var point = this,\n                colors;\n            point.series = series;\n            point.color = series.color; // #3445\n            point.applyOptions(options, x);\n            point.pointAttr = {};\n\n            if (series.options.colorByPoint) {\n                colors = series.options.colors || series.chart.options.colors;\n                point.color = point.color || colors[series.colorCounter++];\n                // loop back to zero\n                if (series.colorCounter === colors.length) {\n                    series.colorCounter = 0;\n                }\n            }\n\n            series.chart.pointCount++;\n            return point;\n        },\n        /**\n         * Apply the options containing the x and y data and possible some extra properties.\n         * This is called on point init or from point.update.\n         *\n         * @param {Object} options\n         */\n        applyOptions: function (options, x) {\n            var point = this,\n                series = point.series,\n                pointValKey = series.options.pointValKey || series.pointValKey;\n\n            options = Point.prototype.optionsToObject.call(this, options);\n\n            // copy options directly to point\n            extend(point, options);\n            point.options = point.options ? extend(point.options, options) : options;\n\n            // For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.\n            if (pointValKey) {\n                point.y = point[pointValKey];\n            }\n            point.isNull = point.y === null;\n\n            // If no x is set by now, get auto incremented value. All points must have an\n            // x value, however the y value can be null to create a gap in the series\n            if (typeof point.x !== 'number' && series) {\n                point.x = x === undefined ? series.autoIncrement() : x;\n            }\n\n            return point;\n        },\n\n        /**\n         * Transform number or array configs into objects\n         */\n        optionsToObject: function (options) {\n            var ret = {},\n                series = this.series,\n                keys = series.options.keys,\n                pointArrayMap = keys || series.pointArrayMap || ['y'],\n                valueCount = pointArrayMap.length,\n                firstItemType,\n                i = 0,\n                j = 0;\n\n            if (typeof options === 'number' || options === null) {\n                ret[pointArrayMap[0]] = options;\n\n            } else if (isArray(options)) {\n                // with leading x value\n                if (!keys && options.length > valueCount) {\n                    firstItemType = typeof options[0];\n                    if (firstItemType === 'string') {\n                        ret.name = options[0];\n                    } else if (firstItemType === 'number') {\n                        ret.x = options[0];\n                    }\n                    i++;\n                }\n                while (j < valueCount) {\n                    if (!keys || options[i] !== undefined) { // Skip undefined positions for keys\n                        ret[pointArrayMap[j]] = options[i];\n                    }\n                    i++;\n                    j++;\n                }\n            } else if (typeof options === 'object') {\n                ret = options;\n\n                // This is the fastest way to detect if there are individual point dataLabels that need\n                // to be considered in drawDataLabels. These can only occur in object configs.\n                if (options.dataLabels) {\n                    series._hasPointLabels = true;\n                }\n\n                // Same approach as above for markers\n                if (options.marker) {\n                    series._hasPointMarkers = true;\n                }\n            }\n            return ret;\n        },\n\n        /**\n         * Destroy a point to clear memory. Its reference still stays in series.data.\n         */\n        destroy: function () {\n            var point = this,\n                series = point.series,\n                chart = series.chart,\n                hoverPoints = chart.hoverPoints,\n                prop;\n\n            chart.pointCount--;\n\n            if (hoverPoints) {\n                point.setState();\n                erase(hoverPoints, point);\n                if (!hoverPoints.length) {\n                    chart.hoverPoints = null;\n                }\n\n            }\n            if (point === chart.hoverPoint) {\n                point.onMouseOut();\n            }\n\n            // remove all events\n            if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive\n                removeEvent(point);\n                point.destroyElements();\n            }\n\n            if (point.legendItem) { // pies have legend items\n                chart.legend.destroyItem(point);\n            }\n\n            for (prop in point) {\n                point[prop] = null;\n            }\n\n\n        },\n\n        /**\n         * Destroy SVG elements associated with the point\n         */\n        destroyElements: function () {\n            var point = this,\n                props = ['graphic', 'dataLabel', 'dataLabelUpper', 'connector', 'shadowGroup'],\n                prop,\n                i = 6;\n            while (i--) {\n                prop = props[i];\n                if (point[prop]) {\n                    point[prop] = point[prop].destroy();\n                }\n            }\n        },\n\n        /**\n         * Return the configuration hash needed for the data label and tooltip formatters\n         */\n        getLabelConfig: function () {\n            return {\n                x: this.category,\n                y: this.y,\n                color: this.color,\n                key: this.name || this.category,\n                series: this.series,\n                point: this,\n                percentage: this.percentage,\n                total: this.total || this.stackTotal\n            };\n        },\n\n        /**\n         * Extendable method for formatting each point's tooltip line\n         *\n         * @return {String} A string to be concatenated in to the common tooltip text\n         */\n        tooltipFormatter: function (pointFormat) {\n\n            // Insert options for valueDecimals, valuePrefix, and valueSuffix\n            var series = this.series,\n                seriesTooltipOptions = series.tooltipOptions,\n                valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),\n                valuePrefix = seriesTooltipOptions.valuePrefix || '',\n                valueSuffix = seriesTooltipOptions.valueSuffix || '';\n\n            // Loop over the point array map and replace unformatted values with sprintf formatting markup\n            each(series.pointArrayMap || ['y'], function (key) {\n                key = '{point.' + key; // without the closing bracket\n                if (valuePrefix || valueSuffix) {\n                    pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);\n                }\n                pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');\n            });\n\n            return format(pointFormat, {\n                point: this,\n                series: this.series\n            });\n        },\n\n        /**\n         * Fire an event on the Point object.\n         * @param {String} eventType\n         * @param {Object} eventArgs Additional event arguments\n         * @param {Function} defaultFunction Default event handler\n         */\n        firePointEvent: function (eventType, eventArgs, defaultFunction) {\n            var point = this,\n                series = this.series,\n                seriesOptions = series.options;\n\n            // load event handlers on demand to save time on mouseover/out\n            if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {\n                this.importEvents();\n            }\n\n            // add default handler if in selection mode\n            if (eventType === 'click' && seriesOptions.allowPointSelect) {\n                defaultFunction = function (event) {\n                    // Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera\n                    if (point.select) { // Could be destroyed by prior event handlers (#2911)\n                        point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);\n                    }\n                };\n            }\n\n            fireEvent(this, eventType, eventArgs, defaultFunction);\n        },\n        visible: true\n    };/**\n     * @classDescription The base function which all other series types inherit from. The data in the series is stored\n     * in various arrays.\n     *\n     * - First, series.options.data contains all the original config options for\n     * each point whether added by options or methods like series.addPoint.\n     * - Next, series.data contains those values converted to points, but in case the series data length\n     * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It\n     * only contains the points that have been created on demand.\n     * - Then there's series.points that contains all currently visible point objects. In case of cropping,\n     * the cropped-away points are not part of this array. The series.points array starts at series.cropStart\n     * compared to series.data and series.options.data. If however the series data is grouped, these can't\n     * be correlated one to one.\n     * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.\n     * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.\n     *\n     * @param {Object} chart\n     * @param {Object} options\n     */\n    var Series = Highcharts.Series = function () {};\n\n    Series.prototype = {\n\n        isCartesian: true,\n        type: 'line',\n        pointClass: Point,\n        sorted: true, // requires the data to be sorted\n        requireSorting: true,\n        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n            stroke: 'lineColor',\n            'stroke-width': 'lineWidth',\n            fill: 'fillColor',\n            r: 'radius'\n        },\n        directTouch: false,\n        axisTypes: ['xAxis', 'yAxis'],\n        colorCounter: 0,\n        parallelArrays: ['x', 'y'], // each point's x and y values are stored in this.xData and this.yData\n        init: function (chart, options) {\n            var series = this,\n                eventType,\n                events,\n                chartSeries = chart.series,\n                sortByIndex = function (a, b) {\n                    return pick(a.options.index, a._i) - pick(b.options.index, b._i);\n                };\n\n            series.chart = chart;\n            series.options = options = series.setOptions(options); // merge with plotOptions\n            series.linkedSeries = [];\n\n            // bind the axes\n            series.bindAxes();\n\n            // set some variables\n            extend(series, {\n                name: options.name,\n                state: NORMAL_STATE,\n                pointAttr: {},\n                visible: options.visible !== false, // true by default\n                selected: options.selected === true // false by default\n            });\n\n            // special\n            if (useCanVG) {\n                options.animation = false;\n            }\n\n            // register event listeners\n            events = options.events;\n            for (eventType in events) {\n                addEvent(series, eventType, events[eventType]);\n            }\n            if (\n                (events && events.click) ||\n                (options.point && options.point.events && options.point.events.click) ||\n                options.allowPointSelect\n            ) {\n                chart.runTrackerClick = true;\n            }\n\n            series.getColor();\n            series.getSymbol();\n\n            // Set the data\n            each(series.parallelArrays, function (key) {\n                series[key + 'Data'] = [];\n            });\n            series.setData(options.data, false);\n\n            // Mark cartesian\n            if (series.isCartesian) {\n                chart.hasCartesianSeries = true;\n            }\n\n            // Register it in the chart\n            chartSeries.push(series);\n            series._i = chartSeries.length - 1;\n\n            // Sort series according to index option (#248, #1123, #2456)\n            stableSort(chartSeries, sortByIndex);\n            if (this.yAxis) {\n                stableSort(this.yAxis.series, sortByIndex);\n            }\n\n            each(chartSeries, function (series, i) {\n                series.index = i;\n                series.name = series.name || 'Series ' + (i + 1);\n            });\n\n        },\n\n        /**\n         * Set the xAxis and yAxis properties of cartesian series, and register the series\n         * in the axis.series array\n         */\n        bindAxes: function () {\n            var series = this,\n                seriesOptions = series.options,\n                chart = series.chart,\n                axisOptions;\n\n            each(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis\n\n                each(chart[AXIS], function (axis) { // loop through the chart's axis objects\n                    axisOptions = axis.options;\n\n                    // apply if the series xAxis or yAxis option mathches the number of the\n                    // axis, or if undefined, use the first axis\n                    if ((seriesOptions[AXIS] === axisOptions.index) ||\n                            (seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id) ||\n                            (seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {\n\n                        // register this series in the axis.series lookup\n                        axis.series.push(series);\n\n                        // set this series.xAxis or series.yAxis reference\n                        series[AXIS] = axis;\n\n                        // mark dirty for redraw\n                        axis.isDirty = true;\n                    }\n                });\n\n                // The series needs an X and an Y axis\n                if (!series[AXIS] && series.optionalAxis !== AXIS) {\n                    error(18, true);\n                }\n\n            });\n        },\n\n        /**\n         * For simple series types like line and column, the data values are held in arrays like\n         * xData and yData for quick lookup to find extremes and more. For multidimensional series\n         * like bubble and map, this can be extended with arrays like zData and valueData by\n         * adding to the series.parallelArrays array.\n         */\n        updateParallelArrays: function (point, i) {\n            var series = point.series,\n                args = arguments,\n                fn = typeof i === 'number' ?\n                    // Insert the value in the given position\n                    function (key) {\n                        var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];\n                        series[key + 'Data'][i] = val;\n                    } :\n                    // Apply the method specified in i with the following arguments as arguments\n                    function (key) {\n                        Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));\n                    };\n\n            each(series.parallelArrays, fn);\n        },\n\n        /**\n         * Return an auto incremented x value based on the pointStart and pointInterval options.\n         * This is only used if an x value is not given for the point that calls autoIncrement.\n         */\n        autoIncrement: function () {\n\n            var options = this.options,\n                xIncrement = this.xIncrement,\n                date,\n                pointInterval,\n                pointIntervalUnit = options.pointIntervalUnit;\n\n            xIncrement = pick(xIncrement, options.pointStart, 0);\n\n            this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);\n\n            // Added code for pointInterval strings\n            if (pointIntervalUnit === 'month' || pointIntervalUnit === 'year') {\n                date = new Date(xIncrement);\n                date = (pointIntervalUnit === 'month') ?\n                    +date[setMonth](date[getMonth]() + pointInterval) :\n                    +date[setFullYear](date[getFullYear]() + pointInterval);\n                pointInterval = date - xIncrement;\n            }\n\n            this.xIncrement = xIncrement + pointInterval;\n            return xIncrement;\n        },\n    \n        /**\n         * Set the series options by merging from the options tree\n         * @param {Object} itemOptions\n         */\n        setOptions: function (itemOptions) {\n            var chart = this.chart,\n                chartOptions = chart.options,\n                plotOptions = chartOptions.plotOptions,\n                userOptions = chart.userOptions || {},\n                userPlotOptions = userOptions.plotOptions || {},\n                typeOptions = plotOptions[this.type],\n                options,\n                zones;\n\n            this.userOptions = itemOptions;\n\n            // General series options take precedence over type options because otherwise, default\n            // type options like column.animation would be overwritten by the general option.\n            // But issues have been raised here (#3881), and the solution may be to distinguish\n            // between default option and userOptions like in the tooltip below.\n            options = merge(\n                typeOptions,\n                plotOptions.series,\n                itemOptions\n            );\n\n            // The tooltip options are merged between global and series specific options\n            this.tooltipOptions = merge(\n                defaultOptions.tooltip,\n                defaultOptions.plotOptions[this.type].tooltip,\n                userOptions.tooltip,\n                userPlotOptions.series && userPlotOptions.series.tooltip,\n                userPlotOptions[this.type] && userPlotOptions[this.type].tooltip,\n                itemOptions.tooltip\n            );\n\n            // Delete marker object if not allowed (#1125)\n            if (typeOptions.marker === null) {\n                delete options.marker;\n            }\n\n            // Handle color zones\n            this.zoneAxis = options.zoneAxis;\n            zones = this.zones = (options.zones || []).slice();\n            if ((options.negativeColor || options.negativeFillColor) && !options.zones) {\n                zones.push({\n                    value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,\n                    color: options.negativeColor,\n                    fillColor: options.negativeFillColor\n                });\n            }\n            if (zones.length) { // Push one extra zone for the rest\n                if (defined(zones[zones.length - 1].value)) {\n                    zones.push({\n                        color: this.color,\n                        fillColor: this.fillColor\n                    });\n                }\n            }\n            return options;\n        },\n\n        getCyclic: function (prop, value, defaults) {\n            var i,\n                userOptions = this.userOptions,\n                indexName = '_' + prop + 'Index',\n                counterName = prop + 'Counter';\n\n            if (!value) {\n                if (defined(userOptions[indexName])) { // after Series.update()\n                    i = userOptions[indexName];\n                } else {\n                    userOptions[indexName] = i = this.chart[counterName] % defaults.length;\n                    this.chart[counterName] += 1;\n                }\n                value = defaults[i];\n            }\n            this[prop] = value;\n        },\n\n        /**\n         * Get the series' color\n         */\n        getColor: function () {\n            if (this.options.colorByPoint) {\n                this.options.color = null; // #4359, selected slice got series.color even when colorByPoint was set.\n            } else {\n                this.getCyclic('color', this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);\n            }\n        },\n        /**\n         * Get the series' symbol\n         */\n        getSymbol: function () {\n            var seriesMarkerOption = this.options.marker;\n\n            this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);\n\n            // don't substract radius in image symbols (#604)\n            if (/^url/.test(this.symbol)) {\n                seriesMarkerOption.radius = 0;\n            }\n        },\n\n        drawLegendSymbol: LegendSymbolMixin.drawLineMarker,\n\n        /**\n         * Replace the series data with a new set of data\n         * @param {Object} data\n         * @param {Object} redraw\n         */\n        setData: function (data, redraw, animation, updatePoints) {\n            var series = this,\n                oldData = series.points,\n                oldDataLength = (oldData && oldData.length) || 0,\n                dataLength,\n                options = series.options,\n                chart = series.chart,\n                firstPoint = null,\n                xAxis = series.xAxis,\n                hasCategories = xAxis && !!xAxis.categories,\n                i,\n                turboThreshold = options.turboThreshold,\n                pt,\n                xData = this.xData,\n                yData = this.yData,\n                pointArrayMap = series.pointArrayMap,\n                valueCount = pointArrayMap && pointArrayMap.length;\n\n            data = data || [];\n            dataLength = data.length;\n            redraw = pick(redraw, true);\n\n            // If the point count is the same as is was, just run Point.update which is\n            // cheaper, allows animation, and keeps references to points.\n            if (updatePoints !== false && dataLength && oldDataLength === dataLength && !series.cropped && !series.hasGroupedData && series.visible) {\n                each(data, function (point, i) {\n                    // .update doesn't exist on a linked, hidden series (#3709)\n                    if (oldData[i].update && point !== options.data[i]) {\n                        oldData[i].update(point, false, null, false);\n                    }\n                });\n\n            } else {\n\n                // Reset properties\n                series.xIncrement = null;\n\n                series.colorCounter = 0; // for series with colorByPoint (#1547)\n\n                // Update parallel arrays\n                each(this.parallelArrays, function (key) {\n                    series[key + 'Data'].length = 0;\n                });\n\n                // In turbo mode, only one- or twodimensional arrays of numbers are allowed. The\n                // first value is tested, and we assume that all the rest are defined the same\n                // way. Although the 'for' loops are similar, they are repeated inside each\n                // if-else conditional for max performance.\n                if (turboThreshold && dataLength > turboThreshold) {\n\n                    // find the first non-null point\n                    i = 0;\n                    while (firstPoint === null && i < dataLength) {\n                        firstPoint = data[i];\n                        i++;\n                    }\n\n\n                    if (isNumber(firstPoint)) { // assume all points are numbers\n                        var x = pick(options.pointStart, 0),\n                            pointInterval = pick(options.pointInterval, 1);\n\n                        for (i = 0; i < dataLength; i++) {\n                            xData[i] = x;\n                            yData[i] = data[i];\n                            x += pointInterval;\n                        }\n                        series.xIncrement = x;\n                    } else if (isArray(firstPoint)) { // assume all points are arrays\n                        if (valueCount) { // [x, low, high] or [x, o, h, l, c]\n                            for (i = 0; i < dataLength; i++) {\n                                pt = data[i];\n                                xData[i] = pt[0];\n                                yData[i] = pt.slice(1, valueCount + 1);\n                            }\n                        } else { // [x, y]\n                            for (i = 0; i < dataLength; i++) {\n                                pt = data[i];\n                                xData[i] = pt[0];\n                                yData[i] = pt[1];\n                            }\n                        }\n                    } else {\n                        error(12); // Highcharts expects configs to be numbers or arrays in turbo mode\n                    }\n                } else {\n                    for (i = 0; i < dataLength; i++) {\n                        if (data[i] !== UNDEFINED) { // stray commas in oldIE\n                            pt = { series: series };\n                            series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);\n                            series.updateParallelArrays(pt, i);\n                            if (hasCategories && defined(pt.name)) { // #4401\n                                xAxis.names[pt.x] = pt.name; // #2046\n                            }\n                        }\n                    }\n                }\n\n                // Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON\n                if (isString(yData[0])) {\n                    error(14, true);\n                }\n\n                series.data = [];\n                series.options.data = series.userOptions.data = data;\n\n                // destroy old points\n                i = oldDataLength;\n                while (i--) {\n                    if (oldData[i] && oldData[i].destroy) {\n                        oldData[i].destroy();\n                    }\n                }\n\n                // reset minRange (#878)\n                if (xAxis) {\n                    xAxis.minRange = xAxis.userMinRange;\n                }\n\n                // redraw\n                series.isDirty = series.isDirtyData = chart.isDirtyBox = true;\n                animation = false;\n            }\n\n            // Typically for pie series, points need to be processed and generated\n            // prior to rendering the legend\n            if (options.legendType === 'point') {\n                this.processData();\n                this.generatePoints();\n            }\n\n            if (redraw) {\n                chart.redraw(animation);\n            }\n        },\n\n        /**\n         * Process the data by cropping away unused data points if the series is longer\n         * than the crop threshold. This saves computing time for lage series.\n         */\n        processData: function (force) {\n            var series = this,\n                processedXData = series.xData, // copied during slice operation below\n                processedYData = series.yData,\n                dataLength = processedXData.length,\n                croppedData,\n                cropStart = 0,\n                cropped,\n                distance,\n                closestPointRange,\n                xAxis = series.xAxis,\n                i, // loop variable\n                options = series.options,\n                cropThreshold = options.cropThreshold,\n                getExtremesFromAll = series.getExtremesFromAll || options.getExtremesFromAll, // #4599\n                isCartesian = series.isCartesian,\n                xExtremes,\n                val2lin = xAxis && xAxis.val2lin,\n                isLog = xAxis && xAxis.isLog,\n                min,\n                max;\n\n            // If the series data or axes haven't changed, don't go through this. Return false to pass\n            // the message on to override methods like in data grouping.\n            if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {\n                return false;\n            }\n\n            if (xAxis) {\n                xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)\n                min = xExtremes.min;\n                max = xExtremes.max;\n            }\n\n            // optionally filter out points outside the plot area\n            if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {\n\n                // it's outside current extremes\n                if (processedXData[dataLength - 1] < min || processedXData[0] > max) {\n                    processedXData = [];\n                    processedYData = [];\n\n                // only crop if it's actually spilling out\n                } else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {\n                    croppedData = this.cropData(series.xData, series.yData, min, max);\n                    processedXData = croppedData.xData;\n                    processedYData = croppedData.yData;\n                    cropStart = croppedData.start;\n                    cropped = true;\n                }\n            }\n\n\n            // Find the closest distance between processed points\n            i = processedXData.length || 1;\n            while (--i) {\n                distance = isLog ?\n                    val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) :\n                    processedXData[i] - processedXData[i - 1];\n\n                if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {\n                    closestPointRange = distance;\n\n                // Unsorted data is not supported by the line tooltip, as well as data grouping and\n                // navigation in Stock charts (#725) and width calculation of columns (#1900)\n                } else if (distance < 0 && series.requireSorting) {\n                    error(15);\n                }\n            }\n\n            // Record the properties\n            series.cropped = cropped; // undefined or true\n            series.cropStart = cropStart;\n            series.processedXData = processedXData;\n            series.processedYData = processedYData;\n\n            series.closestPointRange = closestPointRange;\n\n        },\n\n        /**\n         * Iterate over xData and crop values between min and max. Returns object containing crop start/end\n         * cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range\n         */\n        cropData: function (xData, yData, min, max) {\n            var dataLength = xData.length,\n                cropStart = 0,\n                cropEnd = dataLength,\n                cropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside\n                i,\n                j;\n\n            // iterate up to find slice start\n            for (i = 0; i < dataLength; i++) {\n                if (xData[i] >= min) {\n                    cropStart = mathMax(0, i - cropShoulder);\n                    break;\n                }\n            }\n\n            // proceed to find slice end\n            for (j = i; j < dataLength; j++) {\n                if (xData[j] > max) {\n                    cropEnd = j + cropShoulder;\n                    break;\n                }\n            }\n\n            return {\n                xData: xData.slice(cropStart, cropEnd),\n                yData: yData.slice(cropStart, cropEnd),\n                start: cropStart,\n                end: cropEnd\n            };\n        },\n\n\n        /**\n         * Generate the data point after the data has been processed by cropping away\n         * unused points and optionally grouped in Highcharts Stock.\n         */\n        generatePoints: function () {\n            var series = this,\n                options = series.options,\n                dataOptions = options.data,\n                data = series.data,\n                dataLength,\n                processedXData = series.processedXData,\n                processedYData = series.processedYData,\n                pointClass = series.pointClass,\n                processedDataLength = processedXData.length,\n                cropStart = series.cropStart || 0,\n                cursor,\n                hasGroupedData = series.hasGroupedData,\n                point,\n                points = [],\n                i;\n\n            if (!data && !hasGroupedData) {\n                var arr = [];\n                arr.length = dataOptions.length;\n                data = series.data = arr;\n            }\n\n            for (i = 0; i < processedDataLength; i++) {\n                cursor = cropStart + i;\n                if (!hasGroupedData) {\n                    if (data[cursor]) {\n                        point = data[cursor];\n                    } else if (dataOptions[cursor] !== UNDEFINED) { // #970\n                        data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);\n                    }\n                    points[i] = point;\n                } else {\n                    // splat the y data in case of ohlc data array\n                    points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));\n                }\n                points[i].index = cursor; // For faster access in Point.update\n            }\n\n            // Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when\n            // swithching view from non-grouped data to grouped data (#637)\n            if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {\n                for (i = 0; i < dataLength; i++) {\n                    if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points\n                        i += processedDataLength;\n                    }\n                    if (data[i]) {\n                        data[i].destroyElements();\n                        data[i].plotX = UNDEFINED; // #1003\n                    }\n                }\n            }\n\n            series.data = data;\n            series.points = points;\n        },\n\n        /**\n         * Calculate Y extremes for visible data\n         */\n        getExtremes: function (yData) {\n            var xAxis = this.xAxis,\n                yAxis = this.yAxis,\n                xData = this.processedXData,\n                yDataLength,\n                activeYData = [],\n                activeCounter = 0,\n                xExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis\n                xMin = xExtremes.min,\n                xMax = xExtremes.max,\n                validValue,\n                withinRange,\n                x,\n                y,\n                i,\n                j;\n\n            yData = yData || this.stackedYData || this.processedYData;\n            yDataLength = yData.length;\n\n            for (i = 0; i < yDataLength; i++) {\n\n                x = xData[i];\n                y = yData[i];\n\n                // For points within the visible range, including the first point outside the\n                // visible range, consider y extremes\n                validValue = y !== null && y !== UNDEFINED && (!yAxis.isLog || (y.length || y > 0));\n                withinRange = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped ||\n                    ((xData[i + 1] || x) >= xMin &&    (xData[i - 1] || x) <= xMax);\n\n                if (validValue && withinRange) {\n\n                    j = y.length;\n                    if (j) { // array, like ohlc or range data\n                        while (j--) {\n                            if (y[j] !== null) {\n                                activeYData[activeCounter++] = y[j];\n                            }\n                        }\n                    } else {\n                        activeYData[activeCounter++] = y;\n                    }\n                }\n            }\n            this.dataMin = arrayMin(activeYData);\n            this.dataMax = arrayMax(activeYData);\n        },\n\n        /**\n         * Translate data points from raw data values to chart specific positioning data\n         * needed later in drawPoints, drawGraph and drawTracker.\n         */\n        translate: function () {\n            if (!this.processedXData) { // hidden series\n                this.processData();\n            }\n            this.generatePoints();\n            var series = this,\n                options = series.options,\n                stacking = options.stacking,\n                xAxis = series.xAxis,\n                categories = xAxis.categories,\n                yAxis = series.yAxis,\n                points = series.points,\n                dataLength = points.length,\n                hasModifyValue = !!series.modifyValue,\n                i,\n                pointPlacement = options.pointPlacement,\n                dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),\n                threshold = options.threshold,\n                stackThreshold = options.startFromThreshold ? threshold : 0,\n                plotX,\n                plotY,\n                lastPlotX,\n                stackIndicator,\n                closestPointRangePx = Number.MAX_VALUE;\n\n            // Translate each point\n            for (i = 0; i < dataLength; i++) {\n                var point = points[i],\n                    xValue = point.x,\n                    yValue = point.y,\n                    yBottom = point.low,\n                    stack = stacking && yAxis.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? '-' : '') + series.stackKey],\n                    pointStack,\n                    stackValues;\n\n                // Discard disallowed y values for log axes (#3434)\n                if (yAxis.isLog && yValue !== null && yValue <= 0) {\n                    point.y = yValue = null;\n                    error(10);\n                }\n\n                // Get the plotX translation\n                point.plotX = plotX = mathMin(mathMax(-1e5, xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags')), 1e5); // #3923\n\n\n                // Calculate the bottom y value for stacked series\n                if (stacking && series.visible && !point.isNull && stack && stack[xValue]) {\n                    stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);\n                    pointStack = stack[xValue];\n                    stackValues = pointStack.points[stackIndicator.key];\n                    yBottom = stackValues[0];\n                    yValue = stackValues[1];\n\n                    if (yBottom === stackThreshold) {\n                        yBottom = pick(threshold, yAxis.min);\n                    }\n                    if (yAxis.isLog && yBottom <= 0) { // #1200, #1232\n                        yBottom = null;\n                    }\n\n                    point.total = point.stackTotal = pointStack.total;\n                    point.percentage = pointStack.total && (point.y / pointStack.total * 100);\n                    point.stackY = yValue;\n\n                    // Place the stack label\n                    pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);\n\n                }\n\n                // Set translated yBottom or remove it\n                point.yBottom = defined(yBottom) ?\n                    yAxis.translate(yBottom, 0, 1, 0, 1) :\n                    null;\n\n                // general hook, used for Highstock compare mode\n                if (hasModifyValue) {\n                    yValue = series.modifyValue(yValue, point);\n                }\n\n                // Set the the plotY value, reset it for redraws\n                point.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?\n                    mathMin(mathMax(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201\n                    UNDEFINED;\n                point.isInside = plotY !== UNDEFINED && plotY >= 0 && plotY <= yAxis.len && // #3519\n                    plotX >= 0 && plotX <= xAxis.len;\n\n\n                // Set client related positions for mouse tracking\n                point.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : plotX; // #1514\n\n                point.negative = point.y < (threshold || 0);\n\n                // some API data\n                point.category = categories && categories[point.x] !== UNDEFINED ?\n                    categories[point.x] : point.x;\n\n                // Determine auto enabling of markers (#3635)\n                if (i) {\n                    closestPointRangePx = mathMin(closestPointRangePx, mathAbs(plotX - lastPlotX));\n                }\n                lastPlotX = plotX;\n\n            }\n            series.closestPointRangePx = closestPointRangePx;\n        },\n\n        /**\n         * Return the series points with null points filtered out\n         */\n        getValidPoints: function (points) {\n            return grep(points || this.points, function (point) {\n                return !point.isNull;\n            });\n        },\n\n        /**\n         * Set the clipping for the series. For animated series it is called twice, first to initiate\n         * animating the clip then the second time without the animation to set the final clip.\n         */\n        setClip: function (animation) {\n            var chart = this.chart,\n                options = this.options,\n                renderer = chart.renderer,\n                inverted = chart.inverted,\n                seriesClipBox = this.clipBox,\n                clipBox = seriesClipBox || chart.clipBox,\n                sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height, options.xAxis, options.yAxis].join(','), // #4526\n                clipRect = chart[sharedClipKey],\n                markerClipRect = chart[sharedClipKey + 'm'];\n\n            // If a clipping rectangle with the same properties is currently present in the chart, use that.\n            if (!clipRect) {\n\n                // When animation is set, prepare the initial positions\n                if (animation) {\n                    clipBox.width = 0;\n\n                    chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(\n                        -99, // include the width of the first marker\n                        inverted ? -chart.plotLeft : -chart.plotTop,\n                        99,\n                        inverted ? chart.chartWidth : chart.chartHeight\n                    );\n                }\n                chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);\n\n            }\n            if (animation) {\n                clipRect.count += 1;\n            }\n\n            if (options.clip !== false) {\n                this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);\n                this.markerGroup.clip(markerClipRect);\n                this.sharedClipKey = sharedClipKey;\n            }\n\n            // Remove the shared clipping rectangle when all series are shown\n            if (!animation) {\n                clipRect.count -= 1;\n                if (clipRect.count <= 0 && sharedClipKey && chart[sharedClipKey]) {\n                    if (!seriesClipBox) {\n                        chart[sharedClipKey] = chart[sharedClipKey].destroy();\n                    }\n                    if (chart[sharedClipKey + 'm']) {\n                        chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();\n                    }\n                }\n            }\n        },\n\n        /**\n         * Animate in the series\n         */\n        animate: function (init) {\n            var series = this,\n                chart = series.chart,\n                clipRect,\n                animation = series.options.animation,\n                sharedClipKey;\n\n            // Animation option is set to true\n            if (animation && !isObject(animation)) {\n                animation = defaultPlotOptions[series.type].animation;\n            }\n\n            // Initialize the animation. Set up the clipping rectangle.\n            if (init) {\n\n                series.setClip(animation);\n\n            // Run the animation\n            } else {\n                sharedClipKey = this.sharedClipKey;\n                clipRect = chart[sharedClipKey];\n                if (clipRect) {\n                    clipRect.animate({\n                        width: chart.plotSizeX\n                    }, animation);\n                }\n                if (chart[sharedClipKey + 'm']) {\n                    chart[sharedClipKey + 'm'].animate({\n                        width: chart.plotSizeX + 99\n                    }, animation);\n                }\n\n                // Delete this function to allow it only once\n                series.animate = null;\n\n            }\n        },\n\n        /**\n         * This runs after animation to land on the final plot clipping\n         */\n        afterAnimate: function () {\n            this.setClip();\n            fireEvent(this, 'afterAnimate');\n        },\n\n        /**\n         * Draw the markers\n         */\n        drawPoints: function () {\n            var series = this,\n                pointAttr,\n                points = series.points,\n                chart = series.chart,\n                plotX,\n                plotY,\n                i,\n                point,\n                radius,\n                symbol,\n                isImage,\n                graphic,\n                options = series.options,\n                seriesMarkerOptions = options.marker,\n                seriesPointAttr = series.pointAttr[''],\n                pointMarkerOptions,\n                hasPointMarker,\n                enabled,\n                isInside,\n                markerGroup = series.markerGroup,\n                xAxis = series.xAxis,\n                globallyEnabled = pick(\n                    seriesMarkerOptions.enabled,\n                    xAxis.isRadial,\n                    series.closestPointRangePx > 2 * seriesMarkerOptions.radius\n                );\n\n            if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {\n\n                i = points.length;\n                while (i--) {\n                    point = points[i];\n                    plotX = mathFloor(point.plotX); // #1843\n                    plotY = point.plotY;\n                    graphic = point.graphic;\n                    pointMarkerOptions = point.marker || {};\n                    hasPointMarker = !!point.marker;\n                    enabled = (globallyEnabled && pointMarkerOptions.enabled === UNDEFINED) || pointMarkerOptions.enabled;\n                    isInside = point.isInside;\n\n                    // only draw the point if y is defined\n                    if (enabled && plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {\n\n                        // shortcuts\n                        pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || seriesPointAttr;\n                        radius = pointAttr.r;\n                        symbol = pick(pointMarkerOptions.symbol, series.symbol);\n                        isImage = symbol.indexOf('url') === 0;\n\n                        if (graphic) { // update\n                            graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled\n                                .attr(pointAttr) // #4759\n                                .animate(extend({\n                                    x: plotX - radius,\n                                    y: plotY - radius\n                                }, graphic.symbolName ? { // don't apply to image symbols #507\n                                    width: 2 * radius,\n                                    height: 2 * radius\n                                } : {}));\n                        } else if (isInside && (radius > 0 || isImage)) {\n                            point.graphic = graphic = chart.renderer.symbol(\n                                symbol,\n                                plotX - radius,\n                                plotY - radius,\n                                2 * radius,\n                                2 * radius,\n                                hasPointMarker ? pointMarkerOptions : seriesMarkerOptions\n                            )\n                            .attr(pointAttr)\n                            .add(markerGroup);\n                        }\n\n                    } else if (graphic) {\n                        point.graphic = graphic.destroy(); // #1269\n                    }\n                }\n            }\n\n        },\n\n        /**\n         * Convert state properties from API naming conventions to SVG attributes\n         *\n         * @param {Object} options API options object\n         * @param {Object} base1 SVG attribute object to inherit from\n         * @param {Object} base2 Second level SVG attribute object to inherit from\n         */\n        convertAttribs: function (options, base1, base2, base3) {\n            var conversion = this.pointAttrToOptions,\n                attr,\n                option,\n                obj = {};\n\n            options = options || {};\n            base1 = base1 || {};\n            base2 = base2 || {};\n            base3 = base3 || {};\n\n            for (attr in conversion) {\n                option = conversion[attr];\n                obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);\n            }\n            return obj;\n        },\n\n        /**\n         * Get the state attributes. Each series type has its own set of attributes\n         * that are allowed to change on a point's state change. Series wide attributes are stored for\n         * all series, and additionally point specific attributes are stored for all\n         * points with individual marker options. If such options are not defined for the point,\n         * a reference to the series wide attributes is stored in point.pointAttr.\n         */\n        getAttribs: function () {\n            var series = this,\n                seriesOptions = series.options,\n                normalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions,\n                stateOptions = normalOptions.states,\n                stateOptionsHover = stateOptions[HOVER_STATE],\n                pointStateOptionsHover,\n                seriesColor = series.color,\n                seriesNegativeColor = series.options.negativeColor,\n                normalDefaults = {\n                    stroke: seriesColor,\n                    fill: seriesColor\n                },\n                points = series.points || [], // #927\n                i,\n                j,\n                threshold,\n                point,\n                seriesPointAttr = [],\n                pointAttr,\n                pointAttrToOptions = series.pointAttrToOptions,\n                hasPointSpecificOptions = series.hasPointSpecificOptions,\n                defaultLineColor = normalOptions.lineColor,\n                defaultFillColor = normalOptions.fillColor,\n                turboThreshold = seriesOptions.turboThreshold,\n                zones = series.zones,\n                zoneAxis = series.zoneAxis || 'y',\n                attr,\n                key;\n\n            // series type specific modifications\n            if (seriesOptions.marker) { // line, spline, area, areaspline, scatter\n\n                // if no hover radius is given, default to normal radius + 2\n                stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + stateOptionsHover.radiusPlus;\n                stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + stateOptionsHover.lineWidthPlus;\n\n            } else { // column, bar, pie\n\n                // if no hover color is given, brighten the normal color\n                stateOptionsHover.color = stateOptionsHover.color ||\n                    Color(stateOptionsHover.color || seriesColor)\n                        .brighten(stateOptionsHover.brightness).get();\n\n                // if no hover negativeColor is given, brighten the normal negativeColor\n                stateOptionsHover.negativeColor = stateOptionsHover.negativeColor ||\n                    Color(stateOptionsHover.negativeColor || seriesNegativeColor)\n                        .brighten(stateOptionsHover.brightness).get();\n            }\n\n            // general point attributes for the series normal state\n            seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);\n\n            // HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius\n            each([HOVER_STATE, SELECT_STATE], function (state) {\n                seriesPointAttr[state] =\n                        series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);\n            });\n\n            // set it\n            series.pointAttr = seriesPointAttr;\n\n\n            // Generate the point-specific attribute collections if specific point\n            // options are given. If not, create a referance to the series wide point\n            // attributes\n            i = points.length;\n            if (!turboThreshold || i < turboThreshold || hasPointSpecificOptions) {\n                while (i--) {\n                    point = points[i];\n                    normalOptions = (point.options && point.options.marker) || point.options;\n                    if (normalOptions && normalOptions.enabled === false) {\n                        normalOptions.radius = 0;\n                    }\n\n                    if (zones.length) {\n                        j = 0;\n                        threshold = zones[j];\n                        while (point[zoneAxis] >= threshold.value) {\n                            threshold = zones[++j];\n                        }\n\n                        point.color = point.fillColor = pick(threshold.color, series.color); // #3636, #4267, #4430 - inherit color from series, when color is undefined\n\n                    }\n\n                    hasPointSpecificOptions = seriesOptions.colorByPoint || point.color; // #868\n\n                    // check if the point has specific visual options\n                    if (point.options) {\n                        for (key in pointAttrToOptions) {\n                            if (defined(normalOptions[pointAttrToOptions[key]])) {\n                                hasPointSpecificOptions = true;\n                            }\n                        }\n                    }\n\n                    // a specific marker config object is defined for the individual point:\n                    // create it's own attribute collection\n                    if (hasPointSpecificOptions) {\n                        normalOptions = normalOptions || {};\n                        pointAttr = [];\n                        stateOptions = normalOptions.states || {}; // reassign for individual point\n                        pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};\n\n                        // Handle colors for column and pies\n                        if (!seriesOptions.marker || (point.negative && !pointStateOptionsHover.fillColor && !stateOptionsHover.fillColor)) { // column, bar, point or negative threshold for series with markers (#3636)\n                            // If no hover color is given, brighten the normal color. #1619, #2579\n                            pointStateOptionsHover[series.pointAttrToOptions.fill] = pointStateOptionsHover.color || (!point.options.color && stateOptionsHover[(point.negative && seriesNegativeColor ? 'negativeColor' : 'color')]) ||\n                                Color(point.color)\n                                    .brighten(pointStateOptionsHover.brightness || stateOptionsHover.brightness)\n                                    .get();\n                        }\n\n                        // normal point state inherits series wide normal state\n                        attr = { color: point.color }; // #868\n                        if (!defaultFillColor) { // Individual point color or negative color markers (#2219)\n                            attr.fillColor = point.color;\n                        }\n                        if (!defaultLineColor) {\n                            attr.lineColor = point.color; // Bubbles take point color, line markers use white\n                        }\n                        // Color is explicitly set to null or undefined (#1288, #4068)\n                        if (normalOptions.hasOwnProperty('color') && !normalOptions.color) {\n                            delete normalOptions.color;\n                        }\n                        pointAttr[NORMAL_STATE] = series.convertAttribs(extend(attr, normalOptions), seriesPointAttr[NORMAL_STATE]);\n\n                        // inherit from point normal and series hover\n                        pointAttr[HOVER_STATE] = series.convertAttribs(\n                            stateOptions[HOVER_STATE],\n                            seriesPointAttr[HOVER_STATE],\n                            pointAttr[NORMAL_STATE]\n                        );\n\n                        // inherit from point normal and series hover\n                        pointAttr[SELECT_STATE] = series.convertAttribs(\n                            stateOptions[SELECT_STATE],\n                            seriesPointAttr[SELECT_STATE],\n                            pointAttr[NORMAL_STATE]\n                        );\n\n\n                    // no marker config object is created: copy a reference to the series-wide\n                    // attribute collection\n                    } else {\n                        pointAttr = seriesPointAttr;\n                    }\n\n                    point.pointAttr = pointAttr;\n                }\n            }\n        },\n\n        /**\n         * Clear DOM objects and free up memory\n         */\n        destroy: function () {\n            var series = this,\n                chart = series.chart,\n                issue134 = /AppleWebKit\\/533/.test(userAgent),\n                destroy,\n                i,\n                data = series.data || [],\n                point,\n                prop,\n                axis;\n\n            // add event hook\n            fireEvent(series, 'destroy');\n\n            // remove all events\n            removeEvent(series);\n\n            // erase from axes\n            each(series.axisTypes || [], function (AXIS) {\n                axis = series[AXIS];\n                if (axis) {\n                    erase(axis.series, series);\n                    axis.isDirty = axis.forceRedraw = true;\n                }\n            });\n\n            // remove legend items\n            if (series.legendItem) {\n                series.chart.legend.destroyItem(series);\n            }\n\n            // destroy all points with their elements\n            i = data.length;\n            while (i--) {\n                point = data[i];\n                if (point && point.destroy) {\n                    point.destroy();\n                }\n            }\n            series.points = null;\n\n            // Clear the animation timeout if we are destroying the series during initial animation\n            clearTimeout(series.animationTimeout);\n\n            // Destroy all SVGElements associated to the series\n            for (prop in series) {\n                if (series[prop] instanceof SVGElement && !series[prop].survive) { // Survive provides a hook for not destroying\n\n                    // issue 134 workaround\n                    destroy = issue134 && prop === 'group' ?\n                        'hide' :\n                        'destroy';\n\n                    series[prop][destroy]();\n                }\n            }\n\n            // remove from hoverSeries\n            if (chart.hoverSeries === series) {\n                chart.hoverSeries = null;\n            }\n            erase(chart.series, series);\n\n            // clear all members\n            for (prop in series) {\n                delete series[prop];\n            }\n        },\n\n        /**\n         * Get the graph path\n         */\n        getGraphPath: function (points, nullsAsZeroes, connectCliffs) {\n            var series = this,\n                options = series.options,\n                step = options.step,\n                reversed,\n                graphPath = [],\n                gap;\n\n            points = points || series.points;\n\n            // Bottom of a stack is reversed\n            reversed = points.reversed;\n            if (reversed) {\n                points.reverse();\n            }\n            // Reverse the steps (#5004)\n            step = { right: 1, center: 2 }[step] || (step && 3);\n            if (step && reversed) {\n                step = 4 - step;\n            }\n\n            // Remove invalid points, especially in spline (#5015)\n            if (options.connectNulls && !nullsAsZeroes && !connectCliffs) {\n                points = this.getValidPoints(points);\n            }\n\n            // Build the line\n            each(points, function (point, i) {\n\n                var plotX = point.plotX,\n                    plotY = point.plotY,\n                    lastPoint = points[i - 1],                \n                    pathToPoint; // the path to this point from the previous\n\n                if ((point.leftCliff || (lastPoint && lastPoint.rightCliff)) && !connectCliffs) {\n                    gap = true; // ... and continue\n                }\n\n                // Line series, nullsAsZeroes is not handled\n                if (point.isNull && !defined(nullsAsZeroes) && i > 0) {\n                    gap = !options.connectNulls;\n\n                // Area series, nullsAsZeroes is set\n                } else if (point.isNull && !nullsAsZeroes) {\n                    gap = true;\n\n                } else {\n\n                    if (i === 0 || gap) {\n                        pathToPoint = [M, point.plotX, point.plotY];\n                \n                    } else if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object\n                    \n                        pathToPoint = series.getPointSpline(points, point, i);\n\n                    } else if (step) {\n\n                        if (step === 1) { // right\n                            pathToPoint = [\n                                L,\n                                lastPoint.plotX,\n                                plotY\n                            ];\n                        \n                        } else if (step === 2) { // center\n                            pathToPoint = [\n                                L,\n                                (lastPoint.plotX + plotX) / 2,\n                                lastPoint.plotY,\n                                L,\n                                (lastPoint.plotX + plotX) / 2,\n                                plotY\n                            ];\n                        \n                        } else {\n                            pathToPoint = [\n                                L,\n                                plotX,\n                                lastPoint.plotY\n                            ];\n                        }\n                        pathToPoint.push(L, plotX, plotY);\n\n                    } else {\n                        // normal line to next point\n                        pathToPoint = [\n                            L,\n                            plotX,\n                            plotY\n                        ];\n                    }\n\n\n                    graphPath.push.apply(graphPath, pathToPoint);\n                    gap = false;\n                }\n            });\n\n            series.graphPath = graphPath;\n\n            return graphPath;\n\n        },\n\n        /**\n         * Draw the actual graph\n         */\n        drawGraph: function () {\n            var series = this,\n                options = this.options,\n                props = [['graph', options.lineColor || this.color, options.dashStyle]],\n                lineWidth = options.lineWidth,\n                roundCap = options.linecap !== 'square',\n                graphPath = (this.gappedPath || this.getGraphPath).call(this),\n                fillColor = (this.fillGraph && this.color) || NONE, // polygon series use filled graph\n                zones = this.zones;\n\n            each(zones, function (threshold, i) {\n                props.push(['zoneGraph' + i, threshold.color || series.color, threshold.dashStyle || options.dashStyle]);\n            });\n\n            // Draw the graph\n            each(props, function (prop, i) {\n                var graphKey = prop[0],\n                    graph = series[graphKey],\n                    attribs;\n\n                if (graph) {\n                    graph.animate({ d: graphPath });\n\n                } else if ((lineWidth || fillColor) && graphPath.length) { // #1487\n                    attribs = {\n                        stroke: prop[1],\n                        'stroke-width': lineWidth,\n                        fill: fillColor,\n                        zIndex: 1 // #1069\n                    };\n                    if (prop[2]) {\n                        attribs.dashstyle = prop[2];\n                    } else if (roundCap) {\n                        attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';\n                    }\n\n                    series[graphKey] = series.chart.renderer.path(graphPath)\n                        .attr(attribs)\n                        .add(series.group)\n                        .shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932\n                }\n            });\n        },\n\n        /**\n         * Clip the graphs into the positive and negative coloured graphs\n         */\n        applyZones: function () {\n            var series = this,\n                chart = this.chart,\n                renderer = chart.renderer,\n                zones = this.zones,\n                translatedFrom,\n                translatedTo,\n                clips = this.clips || [],\n                clipAttr,\n                graph = this.graph,\n                area = this.area,\n                chartSizeMax = mathMax(chart.chartWidth, chart.chartHeight),\n                axis = this[(this.zoneAxis || 'y') + 'Axis'],\n                extremes,\n                reversed = axis.reversed,\n                inverted = chart.inverted,\n                horiz = axis.horiz,\n                pxRange,\n                pxPosMin,\n                pxPosMax,\n                ignoreZones = false;\n\n            if (zones.length && (graph || area) && axis.min !== UNDEFINED) {\n                // The use of the Color Threshold assumes there are no gaps\n                // so it is safe to hide the original graph and area\n                if (graph) {\n                    graph.hide();\n                }\n                if (area) {\n                    area.hide();\n                }\n\n                // Create the clips\n                extremes = axis.getExtremes();\n                each(zones, function (threshold, i) {\n\n                    translatedFrom = reversed ?\n                        (horiz ? chart.plotWidth : 0) :\n                        (horiz ? 0 : axis.toPixels(extremes.min));\n                    translatedFrom = mathMin(mathMax(pick(translatedTo, translatedFrom), 0), chartSizeMax);\n                    translatedTo = mathMin(mathMax(mathRound(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);\n\n                    if (ignoreZones) {\n                        translatedFrom = translatedTo = axis.toPixels(extremes.max);\n                    }\n\n                    pxRange = Math.abs(translatedFrom - translatedTo);\n                    pxPosMin = mathMin(translatedFrom, translatedTo);\n                    pxPosMax = mathMax(translatedFrom, translatedTo);\n                    if (axis.isXAxis) {\n                        clipAttr = {\n                            x: inverted ? pxPosMax : pxPosMin,\n                            y: 0,\n                            width: pxRange,\n                            height: chartSizeMax\n                        };\n                        if (!horiz) {\n                            clipAttr.x = chart.plotHeight - clipAttr.x;\n                        }\n                    } else {\n                        clipAttr = {\n                            x: 0,\n                            y: inverted ? pxPosMax : pxPosMin,\n                            width: chartSizeMax,\n                            height: pxRange\n                        };\n                        if (horiz) {\n                            clipAttr.y = chart.plotWidth - clipAttr.y;\n                        }\n                    }\n\n                    /// VML SUPPPORT\n                    if (chart.inverted && renderer.isVML) {\n                        if (axis.isXAxis) {\n                            clipAttr = {\n                                x: 0,\n                                y: reversed ? pxPosMin : pxPosMax,\n                                height: clipAttr.width,\n                                width: chart.chartWidth\n                            };\n                        } else {\n                            clipAttr = {\n                                x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,\n                                y: 0,\n                                width: clipAttr.height,\n                                height: chart.chartHeight\n                            };\n                        }\n                    }\n                    /// END OF VML SUPPORT\n\n                    if (clips[i]) {\n                        clips[i].animate(clipAttr);\n                    } else {\n                        clips[i] = renderer.clipRect(clipAttr);\n\n                        if (graph) {\n                            series['zoneGraph' + i].clip(clips[i]);\n                        }\n\n                        if (area) {\n                            series['zoneArea' + i].clip(clips[i]);\n                        }\n                    }\n                    // if this zone extends out of the axis, ignore the others\n                    ignoreZones = threshold.value > extremes.max;\n                });\n                this.clips = clips;\n            }\n        },\n\n        /**\n         * Initialize and perform group inversion on series.group and series.markerGroup\n         */\n        invertGroups: function () {\n            var series = this,\n                chart = series.chart;\n\n            // Pie, go away (#1736)\n            if (!series.xAxis) {\n                return;\n            }\n\n            // A fixed size is needed for inversion to work\n            function setInvert() {\n                var size = {\n                    width: series.yAxis.len,\n                    height: series.xAxis.len\n                };\n\n                each(['group', 'markerGroup'], function (groupName) {\n                    if (series[groupName]) {\n                        series[groupName].attr(size).invert();\n                    }\n                });\n            }\n\n            addEvent(chart, 'resize', setInvert); // do it on resize\n            addEvent(series, 'destroy', function () {\n                removeEvent(chart, 'resize', setInvert);\n            });\n\n            // Do it now\n            setInvert(); // do it now\n\n            // On subsequent render and redraw, just do setInvert without setting up events again\n            series.invertGroups = setInvert;\n        },\n\n        /**\n         * General abstraction for creating plot groups like series.group, series.dataLabelsGroup and\n         * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.\n         */\n        plotGroup: function (prop, name, visibility, zIndex, parent) {\n            var group = this[prop],\n                isNew = !group;\n\n            // Generate it on first call\n            if (isNew) {\n                this[prop] = group = this.chart.renderer.g(name)\n                    .attr({\n                        zIndex: zIndex || 0.1 // IE8 needs this\n                    })\n                    .add(parent);\n\n                group.addClass('highcharts-series-' + this.index);\n            }\n\n            // Place it on first and subsequent (redraw) calls\n            group.attr({ visibility: visibility })[isNew ? 'attr' : 'animate'](this.getPlotBox());\n            return group;\n        },\n\n        /**\n         * Get the translation and scale for the plot area of this series\n         */\n        getPlotBox: function () {\n            var chart = this.chart,\n                xAxis = this.xAxis,\n                yAxis = this.yAxis;\n\n            // Swap axes for inverted (#2339)\n            if (chart.inverted) {\n                xAxis = yAxis;\n                yAxis = this.xAxis;\n            }\n            return {\n                translateX: xAxis ? xAxis.left : chart.plotLeft,\n                translateY: yAxis ? yAxis.top : chart.plotTop,\n                scaleX: 1, // #1623\n                scaleY: 1\n            };\n        },\n\n        /**\n         * Render the graph and markers\n         */\n        render: function () {\n            var series = this,\n                chart = series.chart,\n                group,\n                options = series.options,\n                animation = options.animation,\n                // Animation doesn't work in IE8 quirks when the group div is hidden,\n                // and looks bad in other oldIE\n                animDuration = (animation && !!series.animate && chart.renderer.isSVG && pick(animation.duration, 500)) || 0,\n                visibility = series.visible ? 'inherit' : 'hidden', // #2597\n                zIndex = options.zIndex,\n                hasRendered = series.hasRendered,\n                chartSeriesGroup = chart.seriesGroup;\n\n            // the group\n            group = series.plotGroup(\n                'group',\n                'series',\n                visibility,\n                zIndex,\n                chartSeriesGroup\n            );\n\n            series.markerGroup = series.plotGroup(\n                'markerGroup',\n                'markers',\n                visibility,\n                zIndex,\n                chartSeriesGroup\n            );\n\n            // initiate the animation\n            if (animDuration) {\n                series.animate(true);\n            }\n\n            // cache attributes for shapes\n            series.getAttribs();\n\n            // SVGRenderer needs to know this before drawing elements (#1089, #1795)\n            group.inverted = series.isCartesian ? chart.inverted : false;\n\n            // draw the graph if any\n            if (series.drawGraph) {\n                series.drawGraph();\n                series.applyZones();\n            }\n\n            each(series.points, function (point) {\n                if (point.redraw) {\n                    point.redraw();\n                }\n            });\n\n            // draw the data labels (inn pies they go before the points)\n            if (series.drawDataLabels) {\n                series.drawDataLabels();\n            }\n\n            // draw the points\n            if (series.visible) {\n                series.drawPoints();\n            }\n\n\n            // draw the mouse tracking area\n            if (series.drawTracker && series.options.enableMouseTracking !== false) {\n                series.drawTracker();\n            }\n\n            // Handle inverted series and tracker groups\n            if (chart.inverted) {\n                series.invertGroups();\n            }\n\n            // Initial clipping, must be defined after inverting groups for VML. Applies to columns etc. (#3839).\n            if (options.clip !== false && !series.sharedClipKey && !hasRendered) {\n                group.clip(chart.clipRect);\n            }\n\n            // Run the animation\n            if (animDuration) {\n                series.animate();\n            }\n\n            // Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option\n            // which should be available to the user).\n            if (!hasRendered) {\n                series.animationTimeout = syncTimeout(function () {\n                    series.afterAnimate();\n                }, animDuration);\n            }\n\n            series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see\n            // (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see\n            series.hasRendered = true;\n        },\n\n        /**\n         * Redraw the series after an update in the axes.\n         */\n        redraw: function () {\n            var series = this,\n                chart = series.chart,\n                wasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after\n                wasDirty = series.isDirty,\n                group = series.group,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis;\n\n            // reposition on resize\n            if (group) {\n                if (chart.inverted) {\n                    group.attr({\n                        width: chart.plotWidth,\n                        height: chart.plotHeight\n                    });\n                }\n\n                group.animate({\n                    translateX: pick(xAxis && xAxis.left, chart.plotLeft),\n                    translateY: pick(yAxis && yAxis.top, chart.plotTop)\n                });\n            }\n\n            series.translate();\n            series.render();\n            if (wasDirtyData) {\n                fireEvent(series, 'updatedData');\n            }\n            if (wasDirty || wasDirtyData) {            // #3945 recalculate the kdtree when dirty\n                delete this.kdTree; // #3868 recalculate the kdtree with dirty data\n            }\n        },\n\n        /**\n         * KD Tree && PointSearching Implementation\n         */\n\n        kdDimensions: 1,\n        kdAxisArray: ['clientX', 'plotY'],\n\n        searchPoint: function (e, compareX) {\n            var series = this,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                inverted = series.chart.inverted;\n\n            return this.searchKDTree({\n                clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,\n                plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos\n            }, compareX);\n        },\n\n        buildKDTree: function () {\n            var series = this,\n                dimensions = series.kdDimensions;\n\n            // Internal function\n            function _kdtree(points, depth, dimensions) {\n                var axis, median, length = points && points.length;\n\n                if (length) {\n\n                    // alternate between the axis\n                    axis = series.kdAxisArray[depth % dimensions];\n\n                    // sort point array\n                    points.sort(function (a, b) {\n                        return a[axis] - b[axis];\n                    });\n\n                    median = Math.floor(length / 2);\n\n                    // build and return nod\n                    return {\n                        point: points[median],\n                        left: _kdtree(points.slice(0, median), depth + 1, dimensions),\n                        right: _kdtree(points.slice(median + 1), depth + 1, dimensions)\n                    };\n\n                }\n            }\n\n            // Start the recursive build process with a clone of the points array and null points filtered out (#3873)\n            function startRecursive() {\n                series.kdTree = _kdtree(series.getValidPoints(), dimensions, dimensions);\n            }\n            delete series.kdTree;\n\n            // For testing tooltips, don't build async\n            syncTimeout(startRecursive, series.options.kdNow ? 0 : 1);\n        },\n\n        searchKDTree: function (point, compareX) {\n            var series = this,\n                kdX = this.kdAxisArray[0],\n                kdY = this.kdAxisArray[1],\n                kdComparer = compareX ? 'distX' : 'dist';\n\n            // Set the one and two dimensional distance on the point object\n            function setDistance(p1, p2) {\n                var x = (defined(p1[kdX]) && defined(p2[kdX])) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,\n                    y = (defined(p1[kdY]) && defined(p2[kdY])) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,\n                    r = (x || 0) + (y || 0);\n\n                p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;\n                p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;\n            }\n            function _search(search, tree, depth, dimensions) {\n                var point = tree.point,\n                    axis = series.kdAxisArray[depth % dimensions],\n                    tdist,\n                    sideA,\n                    sideB,\n                    ret = point,\n                    nPoint1,\n                    nPoint2;\n\n                setDistance(search, point);\n\n                // Pick side based on distance to splitting point\n                tdist = search[axis] - point[axis];\n                sideA = tdist < 0 ? 'left' : 'right';\n                sideB = tdist < 0 ? 'right' : 'left';\n\n                // End of tree\n                if (tree[sideA]) {\n                    nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);\n\n                    ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);\n                }\n                if (tree[sideB]) {\n                    // compare distance to current best to splitting point to decide wether to check side B or not\n                    if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {\n                        nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);\n                        ret = (nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret);\n                    }\n                }\n\n                return ret;\n            }\n\n            if (!this.kdTree) {\n                this.buildKDTree();\n            }\n\n            if (this.kdTree) {\n                return _search(point,\n                    this.kdTree, this.kdDimensions, this.kdDimensions);\n            }\n        }\n\n    }; // end Series prototype\n\n    /**\n     * The class for stack items\n     */\n    function StackItem(axis, options, isNegative, x, stackOption) {\n\n        var inverted = axis.chart.inverted;\n\n        this.axis = axis;\n\n        // Tells if the stack is negative\n        this.isNegative = isNegative;\n\n        // Save the options to be able to style the label\n        this.options = options;\n\n        // Save the x value to be able to position the label later\n        this.x = x;\n\n        // Initialize total value\n        this.total = null;\n\n        // This will keep each points' extremes stored by series.index and point index\n        this.points = {};\n\n        // Save the stack option on the series configuration object, and whether to treat it as percent\n        this.stack = stackOption;\n        this.leftCliff = 0;\n        this.rightCliff = 0;\n\n        // The align options and text align varies on whether the stack is negative and\n        // if the chart is inverted or not.\n        // First test the user supplied value, then use the dynamic.\n        this.alignOptions = {\n            align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),\n            verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),\n            y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),\n            x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)\n        };\n\n        this.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');\n    }\n\n    StackItem.prototype = {\n        destroy: function () {\n            destroyObjectProperties(this, this.axis);\n        },\n\n        /**\n         * Renders the stack total label and adds it to the stack label group.\n         */\n        render: function (group) {\n            var options = this.options,\n                formatOption = options.format,\n                str = formatOption ?\n                    format(formatOption, this) :\n                    options.formatter.call(this);  // format the text in the label\n\n            // Change the text to reflect the new total and set visibility to hidden in case the serie is hidden\n            if (this.label) {\n                this.label.attr({ text: str, visibility: 'hidden' });\n            // Create new label\n            } else {\n                this.label =\n                    this.axis.chart.renderer.text(str, null, null, options.useHTML)        // dummy positions, actual position updated with setOffset method in columnseries\n                        .css(options.style)                // apply style\n                        .attr({\n                            align: this.textAlign,                // fix the text-anchor\n                            rotation: options.rotation,    // rotation\n                            visibility: HIDDEN                    // hidden until setOffset is called\n                        })\n                        .add(group);                            // add to the labels-group\n            }\n        },\n\n        /**\n         * Sets the offset that the stack has from the x value and repositions the label.\n         */\n        setOffset: function (xOffset, xWidth) {\n            var stackItem = this,\n                axis = stackItem.axis,\n                chart = axis.chart,\n                inverted = chart.inverted,\n                reversed = axis.reversed,\n                neg = (this.isNegative && !reversed) || (!this.isNegative && reversed), // #4056\n                y = axis.translate(axis.usePercentage ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates\n                yZero = axis.translate(0),                        // stack origin\n                h = mathAbs(y - yZero),                            // stack height\n                x = chart.xAxis[0].translate(this.x) + xOffset,    // stack x position\n                plotHeight = chart.plotHeight,\n                stackBox = {    // this is the box for the complete stack\n                    x: inverted ? (neg ? y : y - h) : x,\n                    y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),\n                    width: inverted ? h : xWidth,\n                    height: inverted ? xWidth : h\n                },\n                label = this.label,\n                alignAttr;\n\n            if (label) {\n                label.align(this.alignOptions, null, stackBox);    // align the label to the box\n\n                // Set visibility (#678)\n                alignAttr = label.alignAttr;\n                label[this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? 'show' : 'hide'](true);\n            }\n        }\n    };\n\n    /**\n     * Generate stacks for each series and calculate stacks total values\n     */\n    Chart.prototype.getStacks = function () {\n        var chart = this;\n\n        // reset stacks for each yAxis\n        each(chart.yAxis, function (axis) {\n            if (axis.stacks && axis.hasVisibleSeries) {\n                axis.oldStacks = axis.stacks;\n            }\n        });\n\n        each(chart.series, function (series) {\n            if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {\n                series.stackKey = series.type + pick(series.options.stack, '');\n            }\n        });\n    };\n\n\n    // Stacking methods defined on the Axis prototype\n\n    /**\n     * Build the stacks from top down\n     */\n    Axis.prototype.buildStacks = function () {\n        var axisSeries = this.series,\n            series,\n            reversedStacks = pick(this.options.reversedStacks, true),\n            len = axisSeries.length,\n            i;\n        if (!this.isXAxis) {\n            this.usePercentage = false;\n            i = len;\n            while (i--) {\n                axisSeries[reversedStacks ? i : len - i - 1].setStackedPoints();\n            }\n\n            i = len;\n            while (i--) {\n                series = axisSeries[reversedStacks ? i : len - i - 1];\n                if (series.setStackCliffs) {\n                    series.setStackCliffs();\n                }\n            }\n            // Loop up again to compute percent stack\n            if (this.usePercentage) {\n                for (i = 0; i < len; i++) {\n                    axisSeries[i].setPercentStacks();\n                }\n            }\n        }\n    };\n\n    Axis.prototype.renderStackTotals = function () {\n        var axis = this,\n            chart = axis.chart,\n            renderer = chart.renderer,\n            stacks = axis.stacks,\n            stackKey,\n            oneStack,\n            stackCategory,\n            stackTotalGroup = axis.stackTotalGroup;\n\n        // Create a separate group for the stack total labels\n        if (!stackTotalGroup) {\n            axis.stackTotalGroup = stackTotalGroup =\n                renderer.g('stack-labels')\n                    .attr({\n                        visibility: VISIBLE,\n                        zIndex: 6\n                    })\n                    .add();\n        }\n\n        // plotLeft/Top will change when y axis gets wider so we need to translate the\n        // stackTotalGroup at every render call. See bug #506 and #516\n        stackTotalGroup.translate(chart.plotLeft, chart.plotTop);\n\n        // Render each stack total\n        for (stackKey in stacks) {\n            oneStack = stacks[stackKey];\n            for (stackCategory in oneStack) {\n                oneStack[stackCategory].render(stackTotalGroup);\n            }\n        }\n    };\n\n    /**\n     * Set all the stacks to initial states and destroy unused ones.\n     */\n    Axis.prototype.resetStacks = function () {\n        var stacks = this.stacks,\n            type,\n            i;\n        if (!this.isXAxis) {\n            for (type in stacks) {\n                for (i in stacks[type]) {\n\n                    // Clean up memory after point deletion (#1044, #4320)\n                    if (stacks[type][i].touched < this.stacksTouched) {\n                        stacks[type][i].destroy();\n                        delete stacks[type][i];\n\n                    // Reset stacks\n                    } else {\n                        stacks[type][i].total = null;\n                        stacks[type][i].cum = 0;\n                    }\n                }\n            }\n        }\n    };\n\n    Axis.prototype.cleanStacks = function () {\n        var stacks, type, i;\n\n        if (!this.isXAxis) {\n            if (this.oldStacks) {\n                stacks = this.stacks = this.oldStacks;\n            }\n\n            // reset stacks\n            for (type in stacks) {\n                for (i in stacks[type]) {\n                    stacks[type][i].cum = stacks[type][i].total;\n                }\n            }\n        }\n    };\n\n\n    // Stacking methods defnied for Series prototype\n\n    /**\n     * Adds series' points value to corresponding stack\n     */\n    Series.prototype.setStackedPoints = function () {\n        if (!this.options.stacking || (this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false)) {\n            return;\n        }\n\n        var series = this,\n            xData = series.processedXData,\n            yData = series.processedYData,\n            stackedYData = [],\n            yDataLength = yData.length,\n            seriesOptions = series.options,\n            threshold = seriesOptions.threshold,\n            stackThreshold = seriesOptions.startFromThreshold ? threshold : 0,\n            stackOption = seriesOptions.stack,\n            stacking = seriesOptions.stacking,\n            stackKey = series.stackKey,\n            negKey = '-' + stackKey,\n            negStacks = series.negStacks,\n            yAxis = series.yAxis,\n            stacks = yAxis.stacks,\n            oldStacks = yAxis.oldStacks,\n            stackIndicator,\n            isNegative,\n            stack,\n            other,\n            key,\n            pointKey,\n            i,\n            x,\n            y;\n\n\n        yAxis.stacksTouched += 1;\n\n        // loop over the non-null y values and read them into a local array\n        for (i = 0; i < yDataLength; i++) {\n            x = xData[i];\n            y = yData[i];\n            stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);\n            pointKey = stackIndicator.key;\n            // Read stacked values into a stack based on the x value,\n            // the sign of y and the stack key. Stacking is also handled for null values (#739)\n            isNegative = negStacks && y < (stackThreshold ? 0 : threshold);\n            key = isNegative ? negKey : stackKey;\n\n            // Create empty object for this stack if it doesn't exist yet\n            if (!stacks[key]) {\n                stacks[key] = {};\n            }\n\n            // Initialize StackItem for this x\n            if (!stacks[key][x]) {\n                if (oldStacks[key] && oldStacks[key][x]) {\n                    stacks[key][x] = oldStacks[key][x];\n                    stacks[key][x].total = null;\n                } else {\n                    stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);\n                }\n            }\n\n            // If the StackItem doesn't exist, create it first\n            stack = stacks[key][x];\n            if (y !== null) {\n                stack.points[pointKey] = stack.points[series.index] = [pick(stack.cum, stackThreshold)];\n                stack.touched = yAxis.stacksTouched;\n        \n\n                // In area charts, if there are multiple points on the same X value, let the \n                // area fill the full span of those points\n                if (stackIndicator.index > 0 && series.singleStacks === false) {\n                    stack.points[pointKey][0] = stack.points[series.index + ',' + x + ',0'][0];\n                }\n            }\n\n            // Add value to the stack total\n            if (stacking === 'percent') {\n\n                // Percent stacked column, totals are the same for the positive and negative stacks\n                other = isNegative ? stackKey : negKey;\n                if (negStacks && stacks[other] && stacks[other][x]) {\n                    other = stacks[other][x];\n                    stack.total = other.total = mathMax(other.total, stack.total) + mathAbs(y) || 0;\n\n                // Percent stacked areas\n                } else {\n                    stack.total = correctFloat(stack.total + (mathAbs(y) || 0));\n                }\n            } else {\n                stack.total = correctFloat(stack.total + (y || 0));\n            }\n\n            stack.cum = pick(stack.cum, stackThreshold) + (y || 0);\n\n            if (y !== null) {\n                stack.points[pointKey].push(stack.cum);\n            }\n            stackedYData[i] = stack.cum;\n\n        }\n\n        if (stacking === 'percent') {\n            yAxis.usePercentage = true;\n        }\n\n        this.stackedYData = stackedYData; // To be used in getExtremes\n\n        // Reset old stacks\n        yAxis.oldStacks = {};\n    };\n\n    /**\n     * Iterate over all stacks and compute the absolute values to percent\n     */\n    Series.prototype.setPercentStacks = function () {\n        var series = this,\n            stackKey = series.stackKey,\n            stacks = series.yAxis.stacks,\n            processedXData = series.processedXData,\n            stackIndicator;\n\n        each([stackKey, '-' + stackKey], function (key) {\n            var i = processedXData.length,\n                x,\n                stack,\n                pointExtremes,\n                totalFactor;\n\n            while (i--) {\n                x = processedXData[i];\n                stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);\n                stack = stacks[key] && stacks[key][x];\n                pointExtremes = stack && stack.points[stackIndicator.key];\n                if (pointExtremes) {\n                    totalFactor = stack.total ? 100 / stack.total : 0;\n                    pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor); // Y bottom value\n                    pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor); // Y value\n                    series.stackedYData[i] = pointExtremes[1];\n                }\n            }\n        });\n    };\n\n    /**\n    * Get stack indicator, according to it's x-value, to determine points with the same x-value\n    */\n    Series.prototype.getStackIndicator = function (stackIndicator, x, index) {\n        if (!defined(stackIndicator) || stackIndicator.x !== x) {\n            stackIndicator = {\n                x: x,\n                index: 0\n            };\n        } else {\n            stackIndicator.index++;\n        }\n\n        stackIndicator.key = [index, x, stackIndicator.index].join(',');\n\n        return stackIndicator;\n    };\n\n    // Extend the Chart prototype for dynamic methods\n    extend(Chart.prototype, {\n\n        /**\n         * Add a series dynamically after  time\n         *\n         * @param {Object} options The config options\n         * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         *\n         * @return {Object} series The newly created series object\n         */\n        addSeries: function (options, redraw, animation) {\n            var series,\n                chart = this;\n\n            if (options) {\n                redraw = pick(redraw, true); // defaults to true\n\n                fireEvent(chart, 'addSeries', { options: options }, function () {\n                    series = chart.initSeries(options);\n\n                    chart.isDirtyLegend = true; // the series array is out of sync with the display\n                    chart.linkSeries();\n                    if (redraw) {\n                        chart.redraw(animation);\n                    }\n                });\n            }\n\n            return series;\n        },\n\n        /**\n         * Add an axis to the chart\n         * @param {Object} options The axis option\n         * @param {Boolean} isX Whether it is an X axis or a value axis\n         */\n        addAxis: function (options, isX, redraw, animation) {\n            var key = isX ? 'xAxis' : 'yAxis',\n                chartOptions = this.options;\n\n            new Axis(this, merge(options, { // eslint-disable-line no-new\n                index: this[key].length,\n                isX: isX\n            }));\n\n            // Push the new axis options to the chart options\n            chartOptions[key] = splat(chartOptions[key] || {});\n            chartOptions[key].push(options);\n\n            if (pick(redraw, true)) {\n                this.redraw(animation);\n            }\n        },\n\n        /**\n         * Dim the chart and show a loading text or symbol\n         * @param {String} str An optional text to show in the loading label instead of the default one\n         */\n        showLoading: function (str) {\n            var chart = this,\n                options = chart.options,\n                loadingDiv = chart.loadingDiv,\n                loadingOptions = options.loading,\n                setLoadingSize = function () {\n                    if (loadingDiv) {\n                        css(loadingDiv, {\n                            left: chart.plotLeft + PX,\n                            top: chart.plotTop + PX,\n                            width: chart.plotWidth + PX,\n                            height: chart.plotHeight + PX\n                        });\n                    }\n                };\n\n            // create the layer at the first call\n            if (!loadingDiv) {\n                chart.loadingDiv = loadingDiv = createElement(DIV, {\n                    className: PREFIX + 'loading'\n                }, extend(loadingOptions.style, {\n                    zIndex: 10,\n                    display: NONE\n                }), chart.container);\n\n                chart.loadingSpan = createElement(\n                    'span',\n                    null,\n                    loadingOptions.labelStyle,\n                    loadingDiv\n                );\n                addEvent(chart, 'redraw', setLoadingSize); // #1080\n            }\n\n            // update text\n            chart.loadingSpan.innerHTML = str || options.lang.loading;\n\n            // show it\n            if (!chart.loadingShown) {\n                css(loadingDiv, {\n                    opacity: 0,\n                    display: ''\n                });\n                animate(loadingDiv, {\n                    opacity: loadingOptions.style.opacity\n                }, {\n                    duration: loadingOptions.showDuration || 0\n                });\n                chart.loadingShown = true;\n            }\n            setLoadingSize();\n        },\n\n        /**\n         * Hide the loading layer\n         */\n        hideLoading: function () {\n            var options = this.options,\n                loadingDiv = this.loadingDiv;\n\n            if (loadingDiv) {\n                animate(loadingDiv, {\n                    opacity: 0\n                }, {\n                    duration: options.loading.hideDuration || 100,\n                    complete: function () {\n                        css(loadingDiv, { display: NONE });\n                    }\n                });\n            }\n            this.loadingShown = false;\n        }\n    });\n\n    // extend the Point prototype for dynamic methods\n    extend(Point.prototype, {\n        /**\n         * Update the point with new options (typically x/y data) and optionally redraw the series.\n         *\n         * @param {Object} options Point options as defined in the series.data array\n         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         *\n         */\n        update: function (options, redraw, animation, runEvent) {\n            var point = this,\n                series = point.series,\n                graphic = point.graphic,\n                i,\n                chart = series.chart,\n                seriesOptions = series.options,\n                names = series.xAxis && series.xAxis.names;\n\n            redraw = pick(redraw, true);\n\n            function update() {\n\n                point.applyOptions(options);\n\n                // Update visuals\n                if (point.y === null && graphic) { // #4146\n                    point.graphic = graphic.destroy();\n                }\n                if (isObject(options) && !isArray(options)) {\n                    // Defer the actual redraw until getAttribs has been called (#3260)\n                    point.redraw = function () {\n                        if (graphic && graphic.element) {\n                            if (options && options.marker && options.marker.symbol) {\n                                point.graphic = graphic.destroy();\n                            }\n                        }\n                        if (options && options.dataLabels && point.dataLabel) { // #2468\n                            point.dataLabel = point.dataLabel.destroy();\n                        }\n                        point.redraw = null;\n                    };\n                }\n\n                // record changes in the parallel arrays\n                i = point.index;\n                series.updateParallelArrays(point, i);\n                if (names && point.name) {\n                    names[point.x] = point.name;\n                }\n\n                // Record the options to options.data. If there is an object from before,\n                // use point options, otherwise use raw options. (#4701)\n                seriesOptions.data[i] = isObject(seriesOptions.data[i]) ? point.options : options;\n\n                // redraw\n                series.isDirty = series.isDirtyData = true;\n                if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320\n                    chart.isDirtyBox = true;\n                }\n\n                if (seriesOptions.legendType === 'point') { // #1831, #1885\n                    chart.isDirtyLegend = true;\n                }\n                if (redraw) {\n                    chart.redraw(animation);\n                }\n            }\n\n            // Fire the event with a default handler of doing the update\n            if (runEvent === false) { // When called from setData\n                update();\n            } else {\n                point.firePointEvent('update', { options: options }, update);\n            }\n        },\n\n        /**\n         * Remove a point and optionally redraw the series and if necessary the axes\n         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         */\n        remove: function (redraw, animation) {\n            this.series.removePoint(inArray(this, this.series.data), redraw, animation);\n        }\n    });\n\n    // Extend the series prototype for dynamic methods\n    extend(Series.prototype, {\n        /**\n         * Add a point dynamically after chart load time\n         * @param {Object} options Point options as given in series.data\n         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n         * @param {Boolean} shift If shift is true, a point is shifted off the start\n         *    of the series as one is appended to the end.\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         */\n        addPoint: function (options, redraw, shift, animation) {\n            var series = this,\n                seriesOptions = series.options,\n                data = series.data,\n                graph = series.graph,\n                area = series.area,\n                chart = series.chart,\n                names = series.xAxis && series.xAxis.names,\n                currentShift = (graph && graph.shift) || 0,\n                shiftShapes = ['graph', 'area'],\n                dataOptions = seriesOptions.data,\n                point,\n                isInTheMiddle,\n                xData = series.xData,\n                i,\n                x;\n\n            setAnimation(animation, chart);\n\n            // Make graph animate sideways\n            if (shift) {\n                i = series.zones.length;\n                while (i--) {\n                    shiftShapes.push('zoneGraph' + i, 'zoneArea' + i);\n                }\n                each(shiftShapes, function (shape) {\n                    if (series[shape]) {\n                        series[shape].shift = currentShift + (seriesOptions.step ? 2 : 1);\n                    }\n                });\n            }\n            if (area) {\n                area.isArea = true; // needed in animation, both with and without shift\n            }\n\n            // Optional redraw, defaults to true\n            redraw = pick(redraw, true);\n\n            // Get options and push the point to xData, yData and series.options. In series.generatePoints\n            // the Point instance will be created on demand and pushed to the series.data array.\n            point = { series: series };\n            series.pointClass.prototype.applyOptions.apply(point, [options]);\n            x = point.x;\n\n            // Get the insertion point\n            i = xData.length;\n            if (series.requireSorting && x < xData[i - 1]) {\n                isInTheMiddle = true;\n                while (i && xData[i - 1] > x) {\n                    i--;\n                }\n            }\n\n            series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item\n            series.updateParallelArrays(point, i); // update it\n\n            if (names && point.name) {\n                names[x] = point.name;\n            }\n            dataOptions.splice(i, 0, options);\n\n            if (isInTheMiddle) {\n                series.data.splice(i, 0, null);\n                series.processData();\n            }\n\n            // Generate points to be added to the legend (#1329)\n            if (seriesOptions.legendType === 'point') {\n                series.generatePoints();\n            }\n\n            // Shift the first point off the parallel arrays\n            if (shift) {\n                if (data[0] && data[0].remove) {\n                    data[0].remove(false);\n                } else {\n                    data.shift();\n                    series.updateParallelArrays(point, 'shift');\n\n                    dataOptions.shift();\n                }\n            }\n\n            // redraw\n            series.isDirty = true;\n            series.isDirtyData = true;\n            if (redraw) {\n                series.getAttribs(); // #1937\n                chart.redraw();\n            }\n        },\n\n        /**\n         * Remove a point (rendered or not), by index\n         */\n        removePoint: function (i, redraw, animation) {\n\n            var series = this,\n                data = series.data,\n                point = data[i],\n                points = series.points,\n                chart = series.chart,\n                remove = function () {\n\n                    if (points && points.length === data.length) { // #4935\n                        points.splice(i, 1);\n                    }\n                    data.splice(i, 1);\n                    series.options.data.splice(i, 1);\n                    series.updateParallelArrays(point || { series: series }, 'splice', i, 1);\n\n                    if (point) {\n                        point.destroy();\n                    }\n\n                    // redraw\n                    series.isDirty = true;\n                    series.isDirtyData = true;\n                    if (redraw) {\n                        chart.redraw();\n                    }\n                };\n\n            setAnimation(animation, chart);\n            redraw = pick(redraw, true);\n\n            // Fire the event with a default handler of removing the point\n            if (point) {\n                point.firePointEvent('remove', null, remove);\n            } else {\n                remove();\n            }\n        },\n\n        /**\n         * Remove a series and optionally redraw the chart\n         *\n         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         */\n        remove: function (redraw, animation) {\n            var series = this,\n                chart = series.chart;\n\n            // Fire the event with a default handler of removing the point\n            fireEvent(series, 'remove', null, function () {\n\n                // Destroy elements\n                series.destroy();\n\n                // Redraw\n                chart.isDirtyLegend = chart.isDirtyBox = true;\n                chart.linkSeries();\n\n                if (pick(redraw, true)) {\n                    chart.redraw(animation);\n                }\n            });\n        },\n\n        /**\n         * Update the series with a new set of options\n         */\n        update: function (newOptions, redraw) {\n            var series = this,\n                chart = this.chart,\n                // must use user options when changing type because this.options is merged\n                // in with type specific plotOptions\n                oldOptions = this.userOptions,\n                oldType = this.type,\n                proto = seriesTypes[oldType].prototype,\n                preserve = ['group', 'markerGroup', 'dataLabelsGroup'],\n                n;\n\n            // If we're changing type or zIndex, create new groups (#3380, #3404)\n            if ((newOptions.type && newOptions.type !== oldType) || newOptions.zIndex !== undefined) {\n                preserve.length = 0;\n            }\n\n            // Make sure groups are not destroyed (#3094)\n            each(preserve, function (prop) {\n                preserve[prop] = series[prop];\n                delete series[prop];\n            });\n\n            // Do the merge, with some forced options\n            newOptions = merge(oldOptions, {\n                animation: false,\n                index: this.index,\n                pointStart: this.xData[0] // when updating after addPoint\n            }, { data: this.options.data }, newOptions);\n\n            // Destroy the series and delete all properties. Reinsert all methods\n            // and properties from the new type prototype (#2270, #3719)\n            this.remove(false);\n            for (n in proto) {\n                this[n] = UNDEFINED;\n            }\n            extend(this, seriesTypes[newOptions.type || oldType].prototype);\n\n            // Re-register groups (#3094)\n            each(preserve, function (prop) {\n                series[prop] = preserve[prop];\n            });\n\n            this.init(chart, newOptions);\n            chart.linkSeries(); // Links are lost in this.remove (#3028)\n            if (pick(redraw, true)) {\n                chart.redraw(false);\n            }\n        }\n    });\n\n    // Extend the Axis.prototype for dynamic methods\n    extend(Axis.prototype, {\n\n        /**\n         * Update the axis with a new options structure\n         */\n        update: function (newOptions, redraw) {\n            var chart = this.chart;\n\n            newOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);\n\n            this.destroy(true);\n            this._addedPlotLB = this.chart._labelPanes = UNDEFINED; // #1611, #2887, #4314\n\n            this.init(chart, extend(newOptions, { events: UNDEFINED }));\n\n            chart.isDirtyBox = true;\n            if (pick(redraw, true)) {\n                chart.redraw();\n            }\n        },\n\n        /**\n         * Remove the axis from the chart\n         */\n        remove: function (redraw) {\n            var chart = this.chart,\n                key = this.coll, // xAxis or yAxis\n                axisSeries = this.series,\n                i = axisSeries.length;\n\n            // Remove associated series (#2687)\n            while (i--) {\n                if (axisSeries[i]) {\n                    axisSeries[i].remove(false);\n                }\n            }\n\n            // Remove the axis\n            erase(chart.axes, this);\n            erase(chart[key], this);\n            chart.options[key].splice(this.options.index, 1);\n            each(chart[key], function (axis, i) { // Re-index, #1706\n                axis.options.index = i;\n            });\n            this.destroy();\n            chart.isDirtyBox = true;\n\n            if (pick(redraw, true)) {\n                chart.redraw();\n            }\n        },\n\n        /**\n         * Update the axis title by options\n         */\n        setTitle: function (newTitleOptions, redraw) {\n            this.update({ title: newTitleOptions }, redraw);\n        },\n\n        /**\n         * Set new axis categories and optionally redraw\n         * @param {Array} categories\n         * @param {Boolean} redraw\n         */\n        setCategories: function (categories, redraw) {\n            this.update({ categories: categories }, redraw);\n        }\n\n    });\n\n\n    /**\n     * LineSeries object\n     */\n    var LineSeries = extendClass(Series);\n    seriesTypes.line = LineSeries;\n\n    /**\n     * Set the default options for area\n     */\n    defaultPlotOptions.area = merge(defaultSeriesOptions, {\n        softThreshold: false,\n        threshold: 0\n        // trackByArea: false,\n        // lineColor: null, // overrides color, but lets fillColor be unaltered\n        // fillOpacity: 0.75,\n        // fillColor: null\n    });\n\n    /**\n     * AreaSeries object\n     */\n    var AreaSeries = extendClass(Series, {\n        type: 'area',\n        singleStacks: false,\n        /** \n         * Return an array of stacked points, where null and missing points are replaced by \n         * dummy points in order for gaps to be drawn correctly in stacks.\n         */\n        getStackPoints: function () {\n            var series = this,\n                segment = [],\n                keys = [],\n                xAxis = this.xAxis,\n                yAxis = this.yAxis,\n                stack = yAxis.stacks[this.stackKey],\n                pointMap = {},\n                points = this.points,\n                seriesIndex = series.index,\n                yAxisSeries = yAxis.series,\n                seriesLength = yAxisSeries.length,\n                visibleSeries,\n                upOrDown = pick(yAxis.options.reversedStacks, true) ? 1 : -1,\n                i,\n                x;\n\n            if (this.options.stacking) {\n                // Create a map where we can quickly look up the points by their X value.\n                for (i = 0; i < points.length; i++) {\n                    pointMap[points[i].x] = points[i];\n                }\n\n                // Sort the keys (#1651)\n                for (x in stack) {\n                    if (stack[x].total !== null) { // nulled after switching between grouping and not (#1651, #2336)\n                        keys.push(+x);\n                    }\n                }\n                keys.sort(function (a, b) {\n                    return a - b;\n                });\n\n                visibleSeries = map(yAxisSeries, function () {\n                    return this.visible;\n                });\n\n                each(keys, function (x, idx) {\n                    var y = 0,\n                        stackPoint,\n                        stackedValues;\n\n                    if (pointMap[x] && !pointMap[x].isNull) {\n                        segment.push(pointMap[x]);\n\n                        // Find left and right cliff. -1 goes left, 1 goes right.\n                        each([-1, 1], function (direction) {\n                            var nullName = direction === 1 ? 'rightNull' : 'leftNull',\n                                cliffName = direction === 1 ? 'rightCliff' : 'leftCliff',\n                                cliff = 0,\n                                otherStack = stack[keys[idx + direction]];\n\n                            // If there is a stack next to this one, to the left or to the right...\n                            if (otherStack) {\n                                i = seriesIndex;\n                                while (i >= 0 && i < seriesLength) { // Can go either up or down, depending on reversedStacks\n                                    stackPoint = otherStack.points[i];\n                                    if (!stackPoint) {\n                                        // If the next point in this series is missing, mark the point\n                                        // with point.leftNull or point.rightNull = true.\n                                        if (i === seriesIndex) {\n                                            pointMap[x][nullName] = true;\n\n                                        // If there are missing points in the next stack in any of the \n                                        // series below this one, we need to substract the missing values\n                                        // and add a hiatus to the left or right.\n                                        } else if (visibleSeries[i]) {\n                                            stackedValues = stack[x].points[i];\n                                            if (stackedValues) {\n                                                cliff -= stackedValues[1] - stackedValues[0];\n                                            }\n                                        }\n                                    }\n                                    // When reversedStacks is true, loop up, else loop down\n                                    i += upOrDown; \n                                }                \n                            }\n                            pointMap[x][cliffName] = cliff;\n                        });\n\n\n                    // There is no point for this X value in this series, so we \n                    // insert a dummy point in order for the areas to be drawn\n                    // correctly.\n                    } else {\n\n                        // Loop down the stack to find the series below this one that has\n                        // a value (#1991)\n                        i = seriesIndex;\n                        while (i >= 0 && i < seriesLength) {\n                            stackPoint = stack[x].points[i];\n                            if (stackPoint) {\n                                y = stackPoint[1];\n                                break;\n                            }\n                            // When reversedStacks is true, loop up, else loop down\n                            i += upOrDown;\n                        }\n\n                        y = yAxis.toPixels(y, true);\n                        segment.push({ \n                            isNull: true,\n                            plotX: xAxis.toPixels(x, true),\n                            plotY: y,\n                            yBottom: y\n                        });\n                    }\n                });\n\n            } \n\n            return segment;\n        },\n\n        getGraphPath: function (points) {\n            var getGraphPath = Series.prototype.getGraphPath,\n                graphPath,\n                options = this.options,\n                stacking = options.stacking,\n                yAxis = this.yAxis,\n                topPath,\n                //topPoints = [],\n                bottomPath,\n                bottomPoints = [],\n                graphPoints = [],\n                seriesIndex = this.index,\n                i,\n                areaPath,\n                plotX,\n                stacks = yAxis.stacks[this.stackKey],\n                threshold = options.threshold,\n                translatedThreshold = yAxis.getThreshold(options.threshold),\n                isNull,\n                yBottom,\n                connectNulls = options.connectNulls || stacking === 'percent',\n                /**\n                 * To display null points in underlying stacked series, this series graph must be \n                 * broken, and the area also fall down to fill the gap left by the null point. #2069\n                 */\n                addDummyPoints = function (i, otherI, side) {\n                    var point = points[i],\n                        stackedValues = stacking && stacks[point.x].points[seriesIndex],\n                        nullVal = point[side + 'Null'] || 0,\n                        cliffVal = point[side + 'Cliff'] || 0,\n                        top,\n                        bottom,\n                        isNull = true;\n\n                    if (cliffVal || nullVal) {\n\n                        top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;\n                        bottom = stackedValues[0] + cliffVal;\n                        isNull = !!nullVal;\n                \n                    } else if (!stacking && points[otherI] && points[otherI].isNull) {\n                        top = bottom = threshold;\n                    }\n\n                    // Add to the top and bottom line of the area\n                    if (top !== undefined) {\n                        graphPoints.push({\n                            plotX: plotX,\n                            plotY: top === null ? translatedThreshold : yAxis.toPixels(top, true),\n                            isNull: isNull\n                        });\n                        bottomPoints.push({\n                            plotX: plotX,\n                            plotY: bottom === null ? translatedThreshold : yAxis.toPixels(bottom, true)\n                        });\n                    }\n                };\n\n            // Find what points to use\n            points = points || this.points;\n\n        \n            // Fill in missing points\n            if (stacking) {\n                points = this.getStackPoints();\n            }\n\n            for (i = 0; i < points.length; i++) {\n                isNull = points[i].isNull;\n                plotX = pick(points[i].rectPlotX, points[i].plotX);\n                yBottom = pick(points[i].yBottom, translatedThreshold);\n\n                if (!isNull || connectNulls) {\n\n                    if (!connectNulls) {\n                        addDummyPoints(i, i - 1, 'left');\n                    }\n\n                    if (!(isNull && !stacking && connectNulls)) { // Skip null point when stacking is false and connectNulls true\n                        graphPoints.push(points[i]);\n                        bottomPoints.push({\n                            x: i,\n                            plotX: plotX,\n                            plotY: yBottom\n                        });\n                    }\n\n                    if (!connectNulls) {\n                        addDummyPoints(i, i + 1, 'right');\n                    }\n                }\n            }\n\n            topPath = getGraphPath.call(this, graphPoints, true, true);\n        \n            bottomPoints.reversed = true;\n            bottomPath = getGraphPath.call(this, bottomPoints, true, true);\n            if (bottomPath.length) {\n                bottomPath[0] = L;\n            }\n\n            areaPath = topPath.concat(bottomPath);\n            graphPath = getGraphPath.call(this, graphPoints, false, connectNulls); // TODO: don't set leftCliff and rightCliff when connectNulls?\n\n            this.areaPath = areaPath;\n            return graphPath;\n        },\n\n        /**\n         * Draw the graph and the underlying area. This method calls the Series base\n         * function and adds the area. The areaPath is calculated in the getSegmentPath\n         * method called from Series.prototype.drawGraph.\n         */\n        drawGraph: function () {\n\n            // Define or reset areaPath\n            this.areaPath = [];\n\n            // Call the base method\n            Series.prototype.drawGraph.apply(this);\n\n            // Define local variables\n            var series = this,\n                areaPath = this.areaPath,\n                options = this.options,\n                zones = this.zones,\n                props = [['area', this.color, options.fillColor]]; // area name, main color, fill color\n\n            each(zones, function (threshold, i) {\n                props.push(['zoneArea' + i, threshold.color || series.color, threshold.fillColor || options.fillColor]);\n            });\n            each(props, function (prop) {\n                var areaKey = prop[0],\n                    area = series[areaKey],\n                    attr;\n\n                // Create or update the area\n                if (area) { // update\n                    area.animate({ d: areaPath });\n\n                } else { // create\n                    attr = {\n                        fill: prop[2] || prop[1],\n                        zIndex: 0 // #1069\n                    };\n                    if (!prop[2]) {\n                        attr['fill-opacity'] = pick(options.fillOpacity, 0.75);\n                    }\n                    series[areaKey] = series.chart.renderer.path(areaPath)\n                        .attr(attr)\n                        .add(series.group);\n                }\n            });\n        },\n\n        drawLegendSymbol: LegendSymbolMixin.drawRectangle\n    });\n\n    seriesTypes.area = AreaSeries;\n    /**\n     * Set the default options for spline\n     */\n    defaultPlotOptions.spline = merge(defaultSeriesOptions);\n\n    /**\n     * SplineSeries object\n     */\n    var SplineSeries = extendClass(Series, {\n        type: 'spline',\n\n        /**\n         * Get the spline segment from a given point's previous neighbour to the given point\n         */\n        getPointSpline: function (points, point, i) {\n            var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc\n                denom = smoothing + 1,\n                plotX = point.plotX,\n                plotY = point.plotY,\n                lastPoint = points[i - 1],\n                nextPoint = points[i + 1],\n                leftContX,\n                leftContY,\n                rightContX,\n                rightContY,\n                ret;\n\n            // Find control points\n            if (lastPoint && !lastPoint.isNull && nextPoint && !nextPoint.isNull) {\n                var lastX = lastPoint.plotX,\n                    lastY = lastPoint.plotY,\n                    nextX = nextPoint.plotX,\n                    nextY = nextPoint.plotY,\n                    correction = 0;\n\n                leftContX = (smoothing * plotX + lastX) / denom;\n                leftContY = (smoothing * plotY + lastY) / denom;\n                rightContX = (smoothing * plotX + nextX) / denom;\n                rightContY = (smoothing * plotY + nextY) / denom;\n\n                // Have the two control points make a straight line through main point\n                if (rightContX !== leftContX) { // #5016, division by zero\n                    correction = ((rightContY - leftContY) * (rightContX - plotX)) /\n                        (rightContX - leftContX) + plotY - rightContY;\n                }\n\n                leftContY += correction;\n                rightContY += correction;\n\n                // to prevent false extremes, check that control points are between\n                // neighbouring points' y values\n                if (leftContY > lastY && leftContY > plotY) {\n                    leftContY = mathMax(lastY, plotY);\n                    rightContY = 2 * plotY - leftContY; // mirror of left control point\n                } else if (leftContY < lastY && leftContY < plotY) {\n                    leftContY = mathMin(lastY, plotY);\n                    rightContY = 2 * plotY - leftContY;\n                }\n                if (rightContY > nextY && rightContY > plotY) {\n                    rightContY = mathMax(nextY, plotY);\n                    leftContY = 2 * plotY - rightContY;\n                } else if (rightContY < nextY && rightContY < plotY) {\n                    rightContY = mathMin(nextY, plotY);\n                    leftContY = 2 * plotY - rightContY;\n                }\n\n                // record for drawing in next point\n                point.rightContX = rightContX;\n                point.rightContY = rightContY;\n\n            \n            }\n\n            // Visualize control points for debugging\n            /*\n            if (leftContX) {\n                this.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)\n                    .attr({\n                        stroke: 'red',\n                        'stroke-width': 1,\n                        fill: 'none'\n                    })\n                    .add();\n                this.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,\n                    'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n                    .attr({\n                        stroke: 'red',\n                        'stroke-width': 1\n                    })\n                    .add();\n                this.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)\n                    .attr({\n                        stroke: 'green',\n                        'stroke-width': 1,\n                        fill: 'none'\n                    })\n                    .add();\n                this.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,\n                    'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n                    .attr({\n                        stroke: 'green',\n                        'stroke-width': 1\n                    })\n                    .add();\n            }\n            // */\n            ret = [\n                'C',\n                pick(lastPoint.rightContX, lastPoint.plotX),\n                pick(lastPoint.rightContY, lastPoint.plotY),\n                pick(leftContX, plotX),\n                pick(leftContY, plotY),\n                plotX,\n                plotY\n            ];\n            lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later\n            return ret;\n        }\n    });\n    seriesTypes.spline = SplineSeries;\n\n    /**\n     * Set the default options for areaspline\n     */\n    defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);\n\n    /**\n     * AreaSplineSeries object\n     */\n    var areaProto = AreaSeries.prototype,\n        AreaSplineSeries = extendClass(SplineSeries, {\n            type: 'areaspline',\n            getStackPoints: areaProto.getStackPoints,\n            getGraphPath: areaProto.getGraphPath,\n            setStackCliffs: areaProto.setStackCliffs,\n            drawGraph: areaProto.drawGraph,\n            drawLegendSymbol: LegendSymbolMixin.drawRectangle\n        });\n\n    seriesTypes.areaspline = AreaSplineSeries;\n\n    /**\n     * Set the default options for column\n     */\n    defaultPlotOptions.column = merge(defaultSeriesOptions, {\n        borderColor: '#FFFFFF',\n        //borderWidth: 1,\n        borderRadius: 0,\n        //colorByPoint: undefined,\n        groupPadding: 0.2,\n        //grouping: true,\n        marker: null, // point options are specified in the base options\n        pointPadding: 0.1,\n        //pointWidth: null,\n        minPointLength: 0,\n        cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes\n        pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories\n        states: {\n            hover: {\n                brightness: 0.1,\n                shadow: false,\n                halo: false\n            },\n            select: {\n                color: '#C0C0C0',\n                borderColor: '#000000',\n                shadow: false\n            }\n        },\n        dataLabels: {\n            align: null, // auto\n            verticalAlign: null, // auto\n            y: null\n        },\n        softThreshold: false,\n        startFromThreshold: true, // false doesn't work well: http://jsfiddle.net/highcharts/hz8fopan/14/\n        stickyTracking: false,\n        tooltip: {\n            distance: 6\n        },\n        threshold: 0\n    });\n\n    /**\n     * ColumnSeries object\n     */\n    var ColumnSeries = extendClass(Series, {\n        type: 'column',\n        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n            stroke: 'borderColor',\n            fill: 'color',\n            r: 'borderRadius'\n        },\n        cropShoulder: 0,\n        directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.\n        trackerGroups: ['group', 'dataLabelsGroup'],\n        negStacks: true, // use separate negative stacks, unlike area stacks where a negative\n            // point is substracted from previous (#1910)\n\n        /**\n         * Initialize the series\n         */\n        init: function () {\n            Series.prototype.init.apply(this, arguments);\n\n            var series = this,\n                chart = series.chart;\n\n            // if the series is added dynamically, force redraw of other\n            // series affected by a new column\n            if (chart.hasRendered) {\n                each(chart.series, function (otherSeries) {\n                    if (otherSeries.type === series.type) {\n                        otherSeries.isDirty = true;\n                    }\n                });\n            }\n        },\n\n        /**\n         * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,\n         * pointWidth etc.\n         */\n        getColumnMetrics: function () {\n\n            var series = this,\n                options = series.options,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                reversedXAxis = xAxis.reversed,\n                stackKey,\n                stackGroups = {},\n                columnCount = 0;\n\n            // Get the total number of column type series.\n            // This is called on every series. Consider moving this logic to a\n            // chart.orderStacks() function and call it on init, addSeries and removeSeries\n            if (options.grouping === false) {\n                columnCount = 1;\n            } else {\n                each(series.chart.series, function (otherSeries) {\n                    var otherOptions = otherSeries.options,\n                        otherYAxis = otherSeries.yAxis,\n                        columnIndex;\n                    if (otherSeries.type === series.type && otherSeries.visible &&\n                            yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {  // #642, #2086\n                        if (otherOptions.stacking) {\n                            stackKey = otherSeries.stackKey;\n                            if (stackGroups[stackKey] === UNDEFINED) {\n                                stackGroups[stackKey] = columnCount++;\n                            }\n                            columnIndex = stackGroups[stackKey];\n                        } else if (otherOptions.grouping !== false) { // #1162\n                            columnIndex = columnCount++;\n                        }\n                        otherSeries.columnIndex = columnIndex;\n                    }\n                });\n            }\n\n            var categoryWidth = mathMin(\n                    mathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610\n                    xAxis.len // #1535\n                ),\n                groupPadding = categoryWidth * options.groupPadding,\n                groupWidth = categoryWidth - 2 * groupPadding,\n                pointOffsetWidth = groupWidth / columnCount,\n                pointWidth = mathMin(\n                    options.maxPointWidth || xAxis.len,\n                    pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))\n                ),\n                pointPadding = (pointOffsetWidth - pointWidth) / 2,\n                colIndex = (series.columnIndex || 0) + (reversedXAxis ? 1 : 0), // #1251, #3737\n                pointXOffset = pointPadding + (groupPadding + colIndex *\n                    pointOffsetWidth - (categoryWidth / 2)) *\n                    (reversedXAxis ? -1 : 1);\n\n            // Save it for reading in linked series (Error bars particularly)\n            series.columnMetrics = {\n                width: pointWidth,\n                offset: pointXOffset\n            };\n            return series.columnMetrics;\n\n        },\n\n        /**\n         * Make the columns crisp. The edges are rounded to the nearest full pixel.\n         */\n        crispCol: function (x, y, w, h) {\n            var chart = this.chart,\n                borderWidth = this.borderWidth,\n                xCrisp = -(borderWidth % 2 ? 0.5 : 0),\n                yCrisp = borderWidth % 2 ? 0.5 : 1,\n                right,\n                bottom,\n                fromTop;\n\n            if (chart.inverted && chart.renderer.isVML) {\n                yCrisp += 1;\n            }\n\n            // Horizontal. We need to first compute the exact right edge, then round it\n            // and compute the width from there.\n            right = Math.round(x + w) + xCrisp;\n            x = Math.round(x) + xCrisp;\n            w = right - x;\n\n            // Vertical\n            bottom = Math.round(y + h) + yCrisp;\n            fromTop = mathAbs(y) <= 0.5 && bottom > 0.5; // #4504, #4656\n            y = Math.round(y) + yCrisp;\n            h = bottom - y;\n\n            // Top edges are exceptions\n            if (fromTop) {\n                y -= 1;\n                h += 1;\n            }\n\n            return {\n                x: x,\n                y: y,\n                width: w,\n                height: h\n            };\n        },\n\n        /**\n         * Translate each point to the plot area coordinate system and find shape positions\n         */\n        translate: function () {\n            var series = this,\n                chart = series.chart,\n                options = series.options,\n                borderWidth = series.borderWidth = pick(\n                    options.borderWidth,\n                    series.closestPointRange * series.xAxis.transA < 2 ? 0 : 1 // #3635\n                ),\n                yAxis = series.yAxis,\n                threshold = options.threshold,\n                translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),\n                minPointLength = pick(options.minPointLength, 5),\n                metrics = series.getColumnMetrics(),\n                pointWidth = metrics.width,\n                seriesBarW = series.barW = mathMax(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width\n                pointXOffset = series.pointXOffset = metrics.offset;\n\n            if (chart.inverted) {\n                translatedThreshold -= 0.5; // #3355\n            }\n\n            // When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual\n            // columns to have individual sizes. When pointPadding is greater, we strive for equal-width\n            // columns (#2694).\n            if (options.pointPadding) {\n                seriesBarW = mathCeil(seriesBarW);\n            }\n\n            Series.prototype.translate.apply(series);\n\n            // Record the new values\n            each(series.points, function (point) {\n                var yBottom = mathMin(pick(point.yBottom, translatedThreshold), 9e4), // #3575\n                    safeDistance = 999 + mathAbs(yBottom),\n                    plotY = mathMin(mathMax(-safeDistance, point.plotY), yAxis.len + safeDistance), // Don't draw too far outside plot area (#1303, #2241, #4264)\n                    barX = point.plotX + pointXOffset,\n                    barW = seriesBarW,\n                    barY = mathMin(plotY, yBottom),\n                    up,\n                    barH = mathMax(plotY, yBottom) - barY;\n\n                // Handle options.minPointLength\n                if (mathAbs(barH) < minPointLength) {\n                    if (minPointLength) {\n                        barH = minPointLength;\n                        up = (!yAxis.reversed && !point.negative) || (yAxis.reversed && point.negative);\n                        barY = mathAbs(barY - translatedThreshold) > minPointLength ? // stacked\n                                yBottom - minPointLength : // keep position\n                                translatedThreshold - (up ? minPointLength : 0); // #1485, #4051\n                    }\n                }\n\n                // Cache for access in polar\n                point.barX = barX;\n                point.pointWidth = pointWidth;\n\n                // Fix the tooltip on center of grouped columns (#1216, #424, #3648)\n                point.tooltipPos = chart.inverted ?\n                    [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] :\n                    [barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];\n\n                // Register shape type and arguments to be used in drawPoints\n                point.shapeType = 'rect';\n                point.shapeArgs = series.crispCol(barX, barY, barW, barH);\n            });\n\n        },\n\n        getSymbol: noop,\n\n        /**\n         * Use a solid rectangle like the area series types\n         */\n        drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n\n        /**\n         * Columns have no graph\n         */\n        drawGraph: noop,\n\n        /**\n         * Draw the columns. For bars, the series.group is rotated, so the same coordinates\n         * apply for columns and bars. This method is inherited by scatter series.\n         *\n         */\n        drawPoints: function () {\n            var series = this,\n                chart = this.chart,\n                options = series.options,\n                renderer = chart.renderer,\n                animationLimit = options.animationLimit || 250,\n                shapeArgs,\n                pointAttr;\n\n            // draw the columns\n            each(series.points, function (point) {\n                var plotY = point.plotY,\n                    graphic = point.graphic,\n                    borderAttr;\n\n                if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {\n                    shapeArgs = point.shapeArgs;\n\n                    borderAttr = defined(series.borderWidth) ? {\n                        'stroke-width': series.borderWidth\n                    } : {};\n\n                    pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || series.pointAttr[NORMAL_STATE];\n\n                    if (graphic) { // update\n                        stop(graphic);\n                        graphic.attr(borderAttr).attr(pointAttr)[chart.pointCount < animationLimit ? 'animate' : 'attr'](merge(shapeArgs)); // #4267\n\n                    } else {\n                        point.graphic = graphic = renderer[point.shapeType](shapeArgs)\n                            .attr(borderAttr)\n                            .attr(pointAttr)\n                            .add(point.group || series.group)\n                            .shadow(options.shadow, null, options.stacking && !options.borderRadius);\n                    }\n\n                } else if (graphic) {\n                    point.graphic = graphic.destroy(); // #1269\n                }\n            });\n        },\n\n        /**\n         * Animate the column heights one by one from zero\n         * @param {Boolean} init Whether to initialize the animation or run it\n         */\n        animate: function (init) {\n            var series = this,\n                yAxis = this.yAxis,\n                options = series.options,\n                inverted = this.chart.inverted,\n                attr = {},\n                translatedThreshold;\n\n            if (hasSVG) { // VML is too slow anyway\n                if (init) {\n                    attr.scaleY = 0.001;\n                    translatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));\n                    if (inverted) {\n                        attr.translateX = translatedThreshold - yAxis.len;\n                    } else {\n                        attr.translateY = translatedThreshold;\n                    }\n                    series.group.attr(attr);\n\n                } else { // run the animation\n\n                    attr.scaleY = 1;\n                    attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;\n                    series.group.animate(attr, series.options.animation);\n\n                    // delete this function to allow it only once\n                    series.animate = null;\n                }\n            }\n        },\n\n        /**\n         * Remove this series from the chart\n         */\n        remove: function () {\n            var series = this,\n                chart = series.chart;\n\n            // column and bar series affects other series of the same type\n            // as they are either stacked or grouped\n            if (chart.hasRendered) {\n                each(chart.series, function (otherSeries) {\n                    if (otherSeries.type === series.type) {\n                        otherSeries.isDirty = true;\n                    }\n                });\n            }\n\n            Series.prototype.remove.apply(series, arguments);\n        }\n    });\n    seriesTypes.column = ColumnSeries;\n    /**\n     * Set the default options for bar\n     */\n    defaultPlotOptions.bar = merge(defaultPlotOptions.column);\n    /**\n     * The Bar series class\n     */\n    var BarSeries = extendClass(ColumnSeries, {\n        type: 'bar',\n        inverted: true\n    });\n    seriesTypes.bar = BarSeries;\n\n    /**\n     * Set the default options for scatter\n     */\n    defaultPlotOptions.scatter = merge(defaultSeriesOptions, {\n        lineWidth: 0,\n        marker: {\n            enabled: true // Overrides auto-enabling in line series (#3647)\n        },\n        tooltip: {\n            headerFormat: '<span style=\"color:{point.color}\">\\u25CF</span> <span style=\"font-size: 10px;\"> {series.name}</span><br/>',\n            pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'\n        }\n    });\n\n    /**\n     * The scatter series class\n     */\n    var ScatterSeries = extendClass(Series, {\n        type: 'scatter',\n        sorted: false,\n        requireSorting: false,\n        noSharedTooltip: true,\n        trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],\n        takeOrdinalPosition: false, // #2342\n        kdDimensions: 2,\n        drawGraph: function () {\n            if (this.options.lineWidth) {\n                Series.prototype.drawGraph.call(this);\n            }\n        }\n    });\n\n    seriesTypes.scatter = ScatterSeries;\n\n    /**\n     * Set the default options for pie\n     */\n    defaultPlotOptions.pie = merge(defaultSeriesOptions, {\n        borderColor: '#FFFFFF',\n        borderWidth: 1,\n        center: [null, null],\n        clip: false,\n        colorByPoint: true, // always true for pies\n        dataLabels: {\n            // align: null,\n            // connectorWidth: 1,\n            // connectorColor: point.color,\n            // connectorPadding: 5,\n            distance: 30,\n            enabled: true,\n            formatter: function () { // #2945\n                return this.y === null ? undefined : this.point.name;\n            },\n            // softConnector: true,\n            x: 0\n            // y: 0\n        },\n        ignoreHiddenPoint: true,\n        //innerSize: 0,\n        legendType: 'point',\n        marker: null, // point options are specified in the base options\n        size: null,\n        showInLegend: false,\n        slicedOffset: 10,\n        states: {\n            hover: {\n                brightness: 0.1,\n                shadow: false\n            }\n        },\n        stickyTracking: false,\n        tooltip: {\n            followPointer: true\n        }\n    });\n\n    /**\n     * Extended point object for pies\n     */\n    var PiePoint = extendClass(Point, {\n        /**\n         * Initiate the pie slice\n         */\n        init: function () {\n\n            Point.prototype.init.apply(this, arguments);\n\n            var point = this,\n                toggleSlice;\n\n            point.name = pick(point.name, 'Slice');\n\n            // add event listener for select\n            toggleSlice = function (e) {\n                point.slice(e.type === 'select');\n            };\n            addEvent(point, 'select', toggleSlice);\n            addEvent(point, 'unselect', toggleSlice);\n\n            return point;\n        },\n\n        /**\n         * Toggle the visibility of the pie slice\n         * @param {Boolean} vis Whether to show the slice or not. If undefined, the\n         *    visibility is toggled\n         */\n        setVisible: function (vis, redraw) {\n            var point = this,\n                series = point.series,\n                chart = series.chart,\n                ignoreHiddenPoint = series.options.ignoreHiddenPoint;\n\n            redraw = pick(redraw, ignoreHiddenPoint);\n\n            if (vis !== point.visible) {\n\n                // If called without an argument, toggle visibility\n                point.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;\n                series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data\n\n                // Show and hide associated elements. This is performed regardless of redraw or not,\n                // because chart.redraw only handles full series.\n                each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {\n                    if (point[key]) {\n                        point[key][vis ? 'show' : 'hide'](true);\n                    }\n                });\n\n                if (point.legendItem) {\n                    chart.legend.colorizeItem(point, vis);\n                }\n\n                // #4170, hide halo after hiding point\n                if (!vis && point.state === 'hover') {\n                    point.setState('');\n                }\n\n                // Handle ignore hidden slices\n                if (ignoreHiddenPoint) {\n                    series.isDirty = true;\n                }\n\n                if (redraw) {\n                    chart.redraw();\n                }\n            }\n        },\n\n        /**\n         * Set or toggle whether the slice is cut out from the pie\n         * @param {Boolean} sliced When undefined, the slice state is toggled\n         * @param {Boolean} redraw Whether to redraw the chart. True by default.\n         */\n        slice: function (sliced, redraw, animation) {\n            var point = this,\n                series = point.series,\n                chart = series.chart,\n                translation;\n\n            setAnimation(animation, chart);\n\n            // redraw is true by default\n            redraw = pick(redraw, true);\n\n            // if called without an argument, toggle\n            point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;\n            series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data\n\n            translation = sliced ? point.slicedTranslation : {\n                translateX: 0,\n                translateY: 0\n            };\n\n            point.graphic.animate(translation);\n\n            if (point.shadowGroup) {\n                point.shadowGroup.animate(translation);\n            }\n\n        },\n\n        haloPath: function (size) {\n            var shapeArgs = this.shapeArgs,\n                chart = this.series.chart;\n\n            return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(chart.plotLeft + shapeArgs.x, chart.plotTop + shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {\n                innerR: this.shapeArgs.r,\n                start: shapeArgs.start,\n                end: shapeArgs.end\n            });\n        }\n    });\n\n    /**\n     * The Pie series class\n     */\n    var PieSeries = {\n        type: 'pie',\n        isCartesian: false,\n        pointClass: PiePoint,\n        requireSorting: false,\n        directTouch: true,\n        noSharedTooltip: true,\n        trackerGroups: ['group', 'dataLabelsGroup'],\n        axisTypes: [],\n        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n            stroke: 'borderColor',\n            'stroke-width': 'borderWidth',\n            fill: 'color'\n        },\n\n        /**\n         * Animate the pies in\n         */\n        animate: function (init) {\n            var series = this,\n                points = series.points,\n                startAngleRad = series.startAngleRad;\n\n            if (!init) {\n                each(points, function (point) {\n                    var graphic = point.graphic,\n                        args = point.shapeArgs;\n\n                    if (graphic) {\n                        // start values\n                        graphic.attr({\n                            r: point.startR || (series.center[3] / 2), // animate from inner radius (#779)\n                            start: startAngleRad,\n                            end: startAngleRad\n                        });\n\n                        // animate\n                        graphic.animate({\n                            r: args.r,\n                            start: args.start,\n                            end: args.end\n                        }, series.options.animation);\n                    }\n                });\n\n                // delete this function to allow it only once\n                series.animate = null;\n            }\n        },\n\n        /**\n         * Recompute total chart sum and update percentages of points.\n         */\n        updateTotals: function () {\n            var i,\n                total = 0,\n                points = this.points,\n                len = points.length,\n                point,\n                ignoreHiddenPoint = this.options.ignoreHiddenPoint;\n\n            // Get the total sum\n            for (i = 0; i < len; i++) {\n                point = points[i];\n                total += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;\n            }\n            this.total = total;\n\n            // Set each point's properties\n            for (i = 0; i < len; i++) {\n                point = points[i];\n                point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;\n                point.total = total;\n            }\n        },\n\n        /**\n         * Extend the generatePoints method by adding total and percentage properties to each point\n         */\n        generatePoints: function () {\n            Series.prototype.generatePoints.call(this);\n            this.updateTotals();\n        },\n\n        /**\n         * Do translation for pie slices\n         */\n        translate: function (positions) {\n            this.generatePoints();\n\n            var series = this,\n                cumulative = 0,\n                precision = 1000, // issue #172\n                options = series.options,\n                slicedOffset = options.slicedOffset,\n                connectorOffset = slicedOffset + options.borderWidth,\n                start,\n                end,\n                angle,\n                startAngle = options.startAngle || 0,\n                startAngleRad = series.startAngleRad = mathPI / 180 * (startAngle - 90),\n                endAngleRad = series.endAngleRad = mathPI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),\n                circ = endAngleRad - startAngleRad, //2 * mathPI,\n                points = series.points,\n                radiusX, // the x component of the radius vector for a given point\n                radiusY,\n                labelDistance = options.dataLabels.distance,\n                ignoreHiddenPoint = options.ignoreHiddenPoint,\n                i,\n                len = points.length,\n                point;\n\n            // Get positions - either an integer or a percentage string must be given.\n            // If positions are passed as a parameter, we're in a recursive loop for adjusting\n            // space for data labels.\n            if (!positions) {\n                series.center = positions = series.getCenter();\n            }\n\n            // utility for getting the x value from a given y, used for anticollision logic in data labels\n            series.getX = function (y, left) {\n\n                angle = math.asin(mathMin((y - positions[1]) / (positions[2] / 2 + labelDistance), 1));\n\n                return positions[0] +\n                    (left ? -1 : 1) *\n                    (mathCos(angle) * (positions[2] / 2 + labelDistance));\n            };\n\n            // Calculate the geometry for each point\n            for (i = 0; i < len; i++) {\n\n                point = points[i];\n\n                // set start and end angle\n                start = startAngleRad + (cumulative * circ);\n                if (!ignoreHiddenPoint || point.visible) {\n                    cumulative += point.percentage / 100;\n                }\n                end = startAngleRad + (cumulative * circ);\n\n                // set the shape\n                point.shapeType = 'arc';\n                point.shapeArgs = {\n                    x: positions[0],\n                    y: positions[1],\n                    r: positions[2] / 2,\n                    innerR: positions[3] / 2,\n                    start: mathRound(start * precision) / precision,\n                    end: mathRound(end * precision) / precision\n                };\n\n                // The angle must stay within -90 and 270 (#2645)\n                angle = (end + start) / 2;\n                if (angle > 1.5 * mathPI) {\n                    angle -= 2 * mathPI;\n                } else if (angle < -mathPI / 2) {\n                    angle += 2 * mathPI;\n                }\n\n                // Center for the sliced out slice\n                point.slicedTranslation = {\n                    translateX: mathRound(mathCos(angle) * slicedOffset),\n                    translateY: mathRound(mathSin(angle) * slicedOffset)\n                };\n\n                // set the anchor point for tooltips\n                radiusX = mathCos(angle) * positions[2] / 2;\n                radiusY = mathSin(angle) * positions[2] / 2;\n                point.tooltipPos = [\n                    positions[0] + radiusX * 0.7,\n                    positions[1] + radiusY * 0.7\n                ];\n\n                point.half = angle < -mathPI / 2 || angle > mathPI / 2 ? 1 : 0;\n                point.angle = angle;\n\n                // set the anchor point for data labels\n                connectorOffset = mathMin(connectorOffset, labelDistance / 2); // #1678\n                point.labelPos = [\n                    positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector\n                    positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a\n                    positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie\n                    positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a\n                    positions[0] + radiusX, // landing point for connector\n                    positions[1] + radiusY, // a/a\n                    labelDistance < 0 ? // alignment\n                        'center' :\n                        point.half ? 'right' : 'left', // alignment\n                    angle // center angle\n                ];\n\n            }\n        },\n\n        drawGraph: null,\n\n        /**\n         * Draw the data points\n         */\n        drawPoints: function () {\n            var series = this,\n                chart = series.chart,\n                renderer = chart.renderer,\n                groupTranslation,\n                //center,\n                graphic,\n                //group,\n                shadow = series.options.shadow,\n                shadowGroup,\n                pointAttr,\n                shapeArgs,\n                attr;\n\n            if (shadow && !series.shadowGroup) {\n                series.shadowGroup = renderer.g('shadow')\n                    .add(series.group);\n            }\n\n            // draw the slices\n            each(series.points, function (point) {\n                if (point.y !== null) {\n                    graphic = point.graphic;\n                    shapeArgs = point.shapeArgs;\n                    shadowGroup = point.shadowGroup;\n                    pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];\n                    if (!pointAttr.stroke) {\n                        pointAttr.stroke = pointAttr.fill;\n                    }\n\n                    // put the shadow behind all points\n                    if (shadow && !shadowGroup) {\n                        shadowGroup = point.shadowGroup = renderer.g('shadow')\n                            .add(series.shadowGroup);\n                    }\n\n                    // if the point is sliced, use special translation, else use plot area traslation\n                    groupTranslation = point.sliced ? point.slicedTranslation : {\n                        translateX: 0,\n                        translateY: 0\n                    };\n\n                    //group.translate(groupTranslation[0], groupTranslation[1]);\n                    if (shadowGroup) {\n                        shadowGroup.attr(groupTranslation);\n                    }\n\n                    // draw the slice\n                    if (graphic) {\n                        graphic\n                            .setRadialReference(series.center)\n                            .attr(pointAttr)\n                            .animate(extend(shapeArgs, groupTranslation));\n                    } else {\n                        attr = { 'stroke-linejoin': 'round' };\n                        if (!point.visible) {\n                            attr.visibility = 'hidden';\n                        }\n\n                        point.graphic = graphic = renderer[point.shapeType](shapeArgs)\n                            .setRadialReference(series.center)\n                            .attr(pointAttr)\n                            .attr(attr)\n                            .attr(groupTranslation)\n                            .add(series.group)\n                            .shadow(shadow, shadowGroup);\n                    }\n                }\n            });\n\n        },\n\n\n        searchPoint: noop,\n\n        /**\n         * Utility for sorting data labels\n         */\n        sortByAngle: function (points, sign) {\n            points.sort(function (a, b) {\n                return a.angle !== undefined && (b.angle - a.angle) * sign;\n            });\n        },\n\n        /**\n         * Use a simple symbol from LegendSymbolMixin\n         */\n        drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n        /**\n         * Use the getCenter method from drawLegendSymbol\n         */\n        getCenter: CenteredSeriesMixin.getCenter,\n\n        /**\n         * Pies don't have point marker symbols\n         */\n        getSymbol: noop\n\n    };\n    PieSeries = extendClass(Series, PieSeries);\n    seriesTypes.pie = PieSeries;\n\n    /**\n     * Draw the data labels\n     */\n    Series.prototype.drawDataLabels = function () {\n\n        var series = this,\n            seriesOptions = series.options,\n            cursor = seriesOptions.cursor,\n            options = seriesOptions.dataLabels,\n            points = series.points,\n            pointOptions,\n            generalOptions,\n            hasRendered = series.hasRendered || 0,\n            str,\n            dataLabelsGroup,\n            renderer = series.chart.renderer;\n\n        if (options.enabled || series._hasPointLabels) {\n\n            // Process default alignment of data labels for columns\n            if (series.dlProcessOptions) {\n                series.dlProcessOptions(options);\n            }\n\n            // Create a separate group for the data labels to avoid rotation\n            dataLabelsGroup = series.plotGroup(\n                'dataLabelsGroup',\n                'data-labels',\n                options.defer ? HIDDEN : VISIBLE,\n                options.zIndex || 6\n            );\n\n            if (pick(options.defer, true)) {\n                dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300\n                if (!hasRendered) {\n                    addEvent(series, 'afterAnimate', function () {\n                        if (series.visible) { // #3023, #3024\n                            dataLabelsGroup.show();\n                        }\n                        dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({ opacity: 1 }, { duration: 200 });\n                    });\n                }\n            }\n\n            // Make the labels for each point\n            generalOptions = options;\n            each(points, function (point) {\n\n                var enabled,\n                    dataLabel = point.dataLabel,\n                    labelConfig,\n                    attr,\n                    name,\n                    rotation,\n                    connector = point.connector,\n                    isNew = true,\n                    style,\n                    moreStyle = {};\n\n                // Determine if each data label is enabled\n                pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps\n                enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled) && point.y !== null; // #2282, #4641\n\n\n                // If the point is outside the plot area, destroy it. #678, #820\n                if (dataLabel && !enabled) {\n                    point.dataLabel = dataLabel.destroy();\n\n                // Individual labels are disabled if the are explicitly disabled\n                // in the point options, or if they fall outside the plot area.\n                } else if (enabled) {\n\n                    // Create individual options structure that can be extended without\n                    // affecting others\n                    options = merge(generalOptions, pointOptions);\n                    style = options.style;\n\n                    rotation = options.rotation;\n\n                    // Get the string\n                    labelConfig = point.getLabelConfig();\n                    str = options.format ?\n                        format(options.format, labelConfig) :\n                        options.formatter.call(labelConfig, options);\n\n                    // Determine the color\n                    style.color = pick(options.color, style.color, series.color, 'black');\n\n\n                    // update existing label\n                    if (dataLabel) {\n\n                        if (defined(str)) {\n                            dataLabel\n                                .attr({\n                                    text: str\n                                });\n                            isNew = false;\n\n                        } else { // #1437 - the label is shown conditionally\n                            point.dataLabel = dataLabel = dataLabel.destroy();\n                            if (connector) {\n                                point.connector = connector.destroy();\n                            }\n                        }\n\n                    // create new label\n                    } else if (defined(str)) {\n                        attr = {\n                            //align: align,\n                            fill: options.backgroundColor,\n                            stroke: options.borderColor,\n                            'stroke-width': options.borderWidth,\n                            r: options.borderRadius || 0,\n                            rotation: rotation,\n                            padding: options.padding,\n                            zIndex: 1\n                        };\n\n                        // Get automated contrast color\n                        if (style.color === 'contrast') {\n                            moreStyle.color = options.inside || options.distance < 0 || !!seriesOptions.stacking ?\n                                renderer.getContrast(point.color || series.color) :\n                                '#000000';\n                        }\n                        if (cursor) {\n                            moreStyle.cursor = cursor;\n                        }\n\n\n                        // Remove unused attributes (#947)\n                        for (name in attr) {\n                            if (attr[name] === UNDEFINED) {\n                                delete attr[name];\n                            }\n                        }\n\n                        dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation\n                            str,\n                            0,\n                            -9999,\n                            options.shape,\n                            null,\n                            null,\n                            options.useHTML\n                        )\n                        .attr(attr)\n                        .css(extend(style, moreStyle))\n                        .add(dataLabelsGroup)\n                        .shadow(options.shadow);\n\n                    }\n\n                    if (dataLabel) {\n                        // Now the data label is created and placed at 0,0, so we need to align it\n                        series.alignDataLabel(point, dataLabel, options, null, isNew);\n                    }\n                }\n            });\n        }\n    };\n\n    /**\n     * Align each individual data label\n     */\n    Series.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {\n        var chart = this.chart,\n            inverted = chart.inverted,\n            plotX = pick(point.plotX, -9999),\n            plotY = pick(point.plotY, -9999),\n            bBox = dataLabel.getBBox(),\n            baseline = chart.renderer.fontMetrics(options.style.fontSize).b,\n            rotation = options.rotation,\n            normRotation,\n            negRotation,\n            align = options.align,\n            rotCorr, // rotation correction\n            // Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)\n            visible = this.visible && (point.series.forceDL || chart.isInsidePlot(plotX, mathRound(plotY), inverted) ||\n                (alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted))),\n            alignAttr, // the final position;\n            justify = pick(options.overflow, 'justify') === 'justify';\n\n        if (visible) {\n\n            // The alignment box is a singular point\n            alignTo = extend({\n                x: inverted ? chart.plotWidth - plotY : plotX,\n                y: mathRound(inverted ? chart.plotHeight - plotX : plotY),\n                width: 0,\n                height: 0\n            }, alignTo);\n\n            // Add the text size for alignment calculation\n            extend(options, {\n                width: bBox.width,\n                height: bBox.height\n            });\n\n            // Allow a hook for changing alignment in the last moment, then do the alignment\n            if (rotation) {\n                justify = false; // Not supported for rotated text\n                rotCorr = chart.renderer.rotCorr(baseline, rotation); // #3723\n                alignAttr = {\n                    x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,\n                    y: alignTo.y + options.y + alignTo.height / 2\n                };\n                dataLabel\n                    [isNew ? 'attr' : 'animate'](alignAttr)\n                    .attr({ // #3003\n                        align: options.align\n                    });\n\n                // Compensate for the rotated label sticking out on the sides\n                normRotation = (rotation + 720) % 360;\n                negRotation = normRotation > 180 && normRotation < 360;\n\n                if (align === 'left') {\n                    alignAttr.y -= negRotation ? bBox.height : 0;\n                } else if (align === 'center') {\n                    alignAttr.x -= bBox.width / 2;\n                    alignAttr.y -= bBox.height / 2;\n                } else if (align === 'right') {\n                    alignAttr.x -= bBox.width;\n                    alignAttr.y -= negRotation ? 0 : bBox.height;\n                }\n            \n\n            } else {\n                dataLabel.align(options, null, alignTo);\n                alignAttr = dataLabel.alignAttr;\n            }\n\n            // Handle justify or crop\n            if (justify) {\n                this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);\n            \n            // Now check that the data label is within the plot area\n            } else if (pick(options.crop, true)) {\n                visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);\n            }\n\n            // When we're using a shape, make it possible with a connector or an arrow pointing to thie point\n            if (options.shape && !rotation) {\n                dataLabel.attr({\n                    anchorX: point.plotX,\n                    anchorY: point.plotY\n                });\n            }\n        }\n\n        // Show or hide based on the final aligned position\n        if (!visible) {\n            stop(dataLabel);\n            dataLabel.attr({ y: -9999 });\n            dataLabel.placed = false; // don't animate back in\n        }\n\n    };\n\n    /**\n     * If data labels fall partly outside the plot area, align them back in, in a way that\n     * doesn't hide the point.\n     */\n    Series.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {\n        var chart = this.chart,\n            align = options.align,\n            verticalAlign = options.verticalAlign,\n            off,\n            justified,\n            padding = dataLabel.box ? 0 : (dataLabel.padding || 0);\n\n        // Off left\n        off = alignAttr.x + padding;\n        if (off < 0) {\n            if (align === 'right') {\n                options.align = 'left';\n            } else {\n                options.x = -off;\n            }\n            justified = true;\n        }\n\n        // Off right\n        off = alignAttr.x + bBox.width - padding;\n        if (off > chart.plotWidth) {\n            if (align === 'left') {\n                options.align = 'right';\n            } else {\n                options.x = chart.plotWidth - off;\n            }\n            justified = true;\n        }\n\n        // Off top\n        off = alignAttr.y + padding;\n        if (off < 0) {\n            if (verticalAlign === 'bottom') {\n                options.verticalAlign = 'top';\n            } else {\n                options.y = -off;\n            }\n            justified = true;\n        }\n\n        // Off bottom\n        off = alignAttr.y + bBox.height - padding;\n        if (off > chart.plotHeight) {\n            if (verticalAlign === 'top') {\n                options.verticalAlign = 'bottom';\n            } else {\n                options.y = chart.plotHeight - off;\n            }\n            justified = true;\n        }\n\n        if (justified) {\n            dataLabel.placed = !isNew;\n            dataLabel.align(options, null, alignTo);\n        }\n    };\n\n    /**\n     * Override the base drawDataLabels method by pie specific functionality\n     */\n    if (seriesTypes.pie) {\n        seriesTypes.pie.prototype.drawDataLabels = function () {\n            var series = this,\n                data = series.data,\n                point,\n                chart = series.chart,\n                options = series.options.dataLabels,\n                connectorPadding = pick(options.connectorPadding, 10),\n                connectorWidth = pick(options.connectorWidth, 1),\n                plotWidth = chart.plotWidth,\n                plotHeight = chart.plotHeight,\n                connector,\n                connectorPath,\n                softConnector = pick(options.softConnector, true),\n                distanceOption = options.distance,\n                seriesCenter = series.center,\n                radius = seriesCenter[2] / 2,\n                centerY = seriesCenter[1],\n                outside = distanceOption > 0,\n                dataLabel,\n                dataLabelWidth,\n                labelPos,\n                labelHeight,\n                halves = [// divide the points into right and left halves for anti collision\n                    [], // right\n                    []  // left\n                ],\n                x,\n                y,\n                visibility,\n                rankArr,\n                i,\n                j,\n                overflow = [0, 0, 0, 0], // top, right, bottom, left\n                sort = function (a, b) {\n                    return b.y - a.y;\n                };\n\n            // get out if not enabled\n            if (!series.visible || (!options.enabled && !series._hasPointLabels)) {\n                return;\n            }\n\n            // run parent method\n            Series.prototype.drawDataLabels.apply(series);\n\n            each(data, function (point) {\n                if (point.dataLabel && point.visible) { // #407, #2510\n\n                    // Arrange points for detection collision\n                    halves[point.half].push(point);\n\n                    // Reset positions (#4905)\n                    point.dataLabel._pos = null;\n                }\n            });\n\n            /* Loop over the points in each half, starting from the top and bottom\n             * of the pie to detect overlapping labels.\n             */\n            i = 2;\n            while (i--) {\n\n                var slots = [],\n                    slotsLength,\n                    usedSlots = [],\n                    points = halves[i],\n                    pos,\n                    bottom,\n                    length = points.length,\n                    slotIndex;\n\n                if (!length) {\n                    continue;\n                }\n\n                // Sort by angle\n                series.sortByAngle(points, i - 0.5);\n\n                // Assume equal label heights on either hemisphere (#2630)\n                j = labelHeight = 0;\n                while (!labelHeight && points[j]) { // #1569\n                    labelHeight = points[j] && points[j].dataLabel && (points[j].dataLabel.getBBox().height || 21); // 21 is for #968\n                    j++;\n                }\n\n                // Only do anti-collision when we are outside the pie and have connectors (#856)\n                if (distanceOption > 0) {\n\n                    // Build the slots\n                    bottom = mathMin(centerY + radius + distanceOption, chart.plotHeight);\n                    for (pos = mathMax(0, centerY - radius - distanceOption); pos <= bottom; pos += labelHeight) {\n                        slots.push(pos);\n                    }\n                    slotsLength = slots.length;\n\n\n                    /* Visualize the slots\n                    if (!series.slotElements) {\n                        series.slotElements = [];\n                    }\n                    if (i === 1) {\n                        series.slotElements.forEach(function (elem) {\n                            elem.destroy();\n                        });\n                        series.slotElements.length = 0;\n                    }\n\n                    slots.forEach(function (pos, no) {\n                        var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),\n                            slotY = pos + chart.plotTop;\n\n                        if (!isNaN(slotX)) {\n                            series.slotElements.push(chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)\n                                .attr({\n                                    'stroke-width': 1,\n                                    stroke: 'silver',\n                                    fill: 'rgba(0,0,255,0.1)'\n                                })\n                                .add());\n                            series.slotElements.push(chart.renderer.text('Slot '+ no, slotX, slotY + 4)\n                                .attr({\n                                    fill: 'silver'\n                                }).add());\n                        }\n                    });\n                    // */\n\n                    // if there are more values than available slots, remove lowest values\n                    if (length > slotsLength) {\n                        // create an array for sorting and ranking the points within each quarter\n                        rankArr = [].concat(points);\n                        rankArr.sort(sort);\n                        j = length;\n                        while (j--) {\n                            rankArr[j].rank = j;\n                        }\n                        j = length;\n                        while (j--) {\n                            if (points[j].rank >= slotsLength) {\n                                points.splice(j, 1);\n                            }\n                        }\n                        length = points.length;\n                    }\n\n                    // The label goes to the nearest open slot, but not closer to the edge than\n                    // the label's index.\n                    for (j = 0; j < length; j++) {\n\n                        point = points[j];\n                        labelPos = point.labelPos;\n\n                        var closest = 9999,\n                            distance,\n                            slotI;\n\n                        // find the closest slot index\n                        for (slotI = 0; slotI < slotsLength; slotI++) {\n                            distance = mathAbs(slots[slotI] - labelPos[1]);\n                            if (distance < closest) {\n                                closest = distance;\n                                slotIndex = slotI;\n                            }\n                        }\n\n                        // if that slot index is closer to the edges of the slots, move it\n                        // to the closest appropriate slot\n                        if (slotIndex < j && slots[j] !== null) { // cluster at the top\n                            slotIndex = j;\n                        } else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom\n                            slotIndex = slotsLength - length + j;\n                            while (slots[slotIndex] === null) { // make sure it is not taken\n                                slotIndex++;\n                            }\n                        } else {\n                            // Slot is taken, find next free slot below. In the next run, the next slice will find the\n                            // slot above these, because it is the closest one\n                            while (slots[slotIndex] === null) { // make sure it is not taken\n                                slotIndex++;\n                            }\n                        }\n\n                        usedSlots.push({ i: slotIndex, y: slots[slotIndex] });\n                        slots[slotIndex] = null; // mark as taken\n                    }\n                    // sort them in order to fill in from the top\n                    usedSlots.sort(sort);\n                }\n\n                // now the used slots are sorted, fill them up sequentially\n                for (j = 0; j < length; j++) {\n\n                    var slot, naturalY;\n\n                    point = points[j];\n                    labelPos = point.labelPos;\n                    dataLabel = point.dataLabel;\n                    visibility = point.visible === false ? HIDDEN : 'inherit';\n                    naturalY = labelPos[1];\n\n                    if (distanceOption > 0) {\n                        slot = usedSlots.pop();\n                        slotIndex = slot.i;\n\n                        // if the slot next to currrent slot is free, the y value is allowed\n                        // to fall back to the natural position\n                        y = slot.y;\n                        if ((naturalY > y && slots[slotIndex + 1] !== null) ||\n                                (naturalY < y &&  slots[slotIndex - 1] !== null)) {\n                            y = mathMin(mathMax(0, naturalY), chart.plotHeight);\n                        }\n\n                    } else {\n                        y = naturalY;\n                    }\n\n                    // get the x - use the natural x position for first and last slot, to prevent the top\n                    // and botton slice connectors from touching each other on either side\n                    x = options.justify ?\n                        seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :\n                        series.getX(y === centerY - radius - distanceOption || y === centerY + radius + distanceOption ? naturalY : y, i);\n\n\n                    // Record the placement and visibility\n                    dataLabel._attr = {\n                        visibility: visibility,\n                        align: labelPos[6]\n                    };\n                    dataLabel._pos = {\n                        x: x + options.x +\n                            ({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),\n                        y: y + options.y - 10 // 10 is for the baseline (label vs text)\n                    };\n                    dataLabel.connX = x;\n                    dataLabel.connY = y;\n\n\n                    // Detect overflowing data labels\n                    if (this.options.size === null) {\n                        dataLabelWidth = dataLabel.width;\n                        // Overflow left\n                        if (x - dataLabelWidth < connectorPadding) {\n                            overflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);\n\n                        // Overflow right\n                        } else if (x + dataLabelWidth > plotWidth - connectorPadding) {\n                            overflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);\n                        }\n\n                        // Overflow top\n                        if (y - labelHeight / 2 < 0) {\n                            overflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);\n\n                        // Overflow left\n                        } else if (y + labelHeight / 2 > plotHeight) {\n                            overflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);\n                        }\n                    }\n                } // for each point\n            } // for each half\n\n            // Do not apply the final placement and draw the connectors until we have verified\n            // that labels are not spilling over.\n            if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {\n\n                // Place the labels in the final position\n                this.placeDataLabels();\n\n                // Draw the connectors\n                if (outside && connectorWidth) {\n                    each(this.points, function (point) {\n                        connector = point.connector;\n                        labelPos = point.labelPos;\n                        dataLabel = point.dataLabel;\n\n                        if (dataLabel && dataLabel._pos && point.visible) {\n                            visibility = dataLabel._attr.visibility;\n                            x = dataLabel.connX;\n                            y = dataLabel.connY;\n                            connectorPath = softConnector ? [\n                                M,\n                                x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n                                'C',\n                                x, y, // first break, next to the label\n                                2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],\n                                labelPos[2], labelPos[3], // second break\n                                L,\n                                labelPos[4], labelPos[5] // base\n                            ] : [\n                                M,\n                                x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n                                L,\n                                labelPos[2], labelPos[3], // second break\n                                L,\n                                labelPos[4], labelPos[5] // base\n                            ];\n\n                            if (connector) {\n                                connector.animate({ d: connectorPath });\n                                connector.attr('visibility', visibility);\n\n                            } else {\n                                point.connector = connector = series.chart.renderer.path(connectorPath).attr({\n                                    'stroke-width': connectorWidth,\n                                    stroke: options.connectorColor || point.color || '#606060',\n                                    visibility: visibility\n                                    //zIndex: 0 // #2722 (reversed)\n                                })\n                                .add(series.dataLabelsGroup);\n                            }\n                        } else if (connector) {\n                            point.connector = connector.destroy();\n                        }\n                    });\n                }\n            }\n        };\n        /**\n         * Perform the final placement of the data labels after we have verified that they\n         * fall within the plot area.\n         */\n        seriesTypes.pie.prototype.placeDataLabels = function () {\n            each(this.points, function (point) {\n                var dataLabel = point.dataLabel,\n                    _pos;\n\n                if (dataLabel && point.visible) {\n                    _pos = dataLabel._pos;\n                    if (_pos) {\n                        dataLabel.attr(dataLabel._attr);\n                        dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);\n                        dataLabel.moved = true;\n                    } else if (dataLabel) {\n                        dataLabel.attr({ y: -9999 });\n                    }\n                }\n            });\n        };\n\n        seriesTypes.pie.prototype.alignDataLabel =  noop;\n\n        /**\n         * Verify whether the data labels are allowed to draw, or we should run more translation and data\n         * label positioning to keep them inside the plot area. Returns true when data labels are ready\n         * to draw.\n         */\n        seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {\n\n            var center = this.center,\n                options = this.options,\n                centerOption = options.center,\n                minSize = options.minSize || 80,\n                newSize = minSize,\n                ret;\n\n            // Handle horizontal size and center\n            if (centerOption[0] !== null) { // Fixed center\n                newSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);\n\n            } else { // Auto center\n                newSize = mathMax(\n                    center[2] - overflow[1] - overflow[3], // horizontal overflow\n                    minSize\n                );\n                center[0] += (overflow[3] - overflow[1]) / 2; // horizontal center\n            }\n\n            // Handle vertical size and center\n            if (centerOption[1] !== null) { // Fixed center\n                newSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);\n\n            } else { // Auto center\n                newSize = mathMax(\n                    mathMin(\n                        newSize,\n                        center[2] - overflow[0] - overflow[2] // vertical overflow\n                    ),\n                    minSize\n                );\n                center[1] += (overflow[0] - overflow[2]) / 2; // vertical center\n            }\n\n            // If the size must be decreased, we need to run translate and drawDataLabels again\n            if (newSize < center[2]) {\n                center[2] = newSize;\n                center[3] = Math.min(relativeLength(options.innerSize || 0, newSize), newSize); // #3632\n                this.translate(center);\n            \n                if (this.drawDataLabels) {\n                    this.drawDataLabels();\n                }\n            // Else, return true to indicate that the pie and its labels is within the plot area\n            } else {\n                ret = true;\n            }\n            return ret;\n        };\n    }\n\n    if (seriesTypes.column) {\n\n        /**\n         * Override the basic data label alignment by adjusting for the position of the column\n         */\n        seriesTypes.column.prototype.alignDataLabel = function (point, dataLabel, options,  alignTo, isNew) {\n            var inverted = this.chart.inverted,\n                series = point.series,\n                dlBox = point.dlBox || point.shapeArgs, // data label box for alignment\n                below = pick(point.below, point.plotY > pick(this.translatedThreshold, series.yAxis.len)), // point.below is used in range series\n                inside = pick(options.inside, !!this.options.stacking), // draw it inside the box?\n                overshoot;\n\n            // Align to the column itself, or the top of it\n            if (dlBox) { // Area range uses this method but not alignTo\n                alignTo = merge(dlBox);\n\n                if (alignTo.y < 0) {\n                    alignTo.height += alignTo.y;\n                    alignTo.y = 0;\n                }\n                overshoot = alignTo.y + alignTo.height - series.yAxis.len;\n                if (overshoot > 0) {\n                    alignTo.height -= overshoot;\n                }\n\n                if (inverted) {\n                    alignTo = {\n                        x: series.yAxis.len - alignTo.y - alignTo.height,\n                        y: series.xAxis.len - alignTo.x - alignTo.width,\n                        width: alignTo.height,\n                        height: alignTo.width\n                    };\n                }\n\n                // Compute the alignment box\n                if (!inside) {\n                    if (inverted) {\n                        alignTo.x += below ? 0 : alignTo.width;\n                        alignTo.width = 0;\n                    } else {\n                        alignTo.y += below ? alignTo.height : 0;\n                        alignTo.height = 0;\n                    }\n                }\n            }\n\n\n            // When alignment is undefined (typically columns and bars), display the individual\n            // point below or above the point depending on the threshold\n            options.align = pick(\n                options.align,\n                !inverted || inside ? 'center' : below ? 'right' : 'left'\n            );\n            options.verticalAlign = pick(\n                options.verticalAlign,\n                inverted || inside ? 'middle' : below ? 'top' : 'bottom'\n            );\n\n            // Call the parent method\n            Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);\n        };\n    }\n\n\n\n    /**\n     * Highcharts module to hide overlapping data labels. This module is included in Highcharts.\n     */\n    (function (H) {\n        var Chart = H.Chart,\n            each = H.each,\n            pick = H.pick,\n            addEvent = H.addEvent;\n\n        // Collect potensial overlapping data labels. Stack labels probably don't need to be \n        // considered because they are usually accompanied by data labels that lie inside the columns.\n        Chart.prototype.callbacks.push(function (chart) {\n            function collectAndHide() {\n                var labels = [];\n\n                each(chart.series, function (series) {\n                    var dlOptions = series.options.dataLabels,\n                        collections = series.dataLabelCollections || ['dataLabel']; // Range series have two collections\n                    if ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) { // #3866\n                        each(collections, function (coll) {\n                            each(series.points, function (point) {\n                                if (point[coll]) {\n                                    point[coll].labelrank = pick(point.labelrank, point.shapeArgs && point.shapeArgs.height); // #4118\n                                    labels.push(point[coll]);\n                                }\n                            });\n                        });\n                    }\n                });\n                chart.hideOverlappingLabels(labels);\n            }\n\n            // Do it now ...\n            collectAndHide();\n\n            // ... and after each chart redraw\n            addEvent(chart, 'redraw', collectAndHide);\n\n        });\n\n        /**\n         * Hide overlapping labels. Labels are moved and faded in and out on zoom to provide a smooth \n         * visual imression.\n         */    \n        Chart.prototype.hideOverlappingLabels = function (labels) {\n\n            var len = labels.length,\n                label,\n                i,\n                j,\n                label1,\n                label2,\n                isIntersecting,\n                pos1,\n                pos2,\n                parent1,\n                parent2,\n                padding,\n                intersectRect = function (x1, y1, w1, h1, x2, y2, w2, h2) {\n                    return !(\n                        x2 > x1 + w1 ||\n                        x2 + w2 < x1 ||\n                        y2 > y1 + h1 ||\n                        y2 + h2 < y1\n                    );\n                };\n    \n            // Mark with initial opacity\n            for (i = 0; i < len; i++) {\n                label = labels[i];\n                if (label) {\n                    label.oldOpacity = label.opacity;\n                    label.newOpacity = 1;\n                }\n            }\n\n            // Prevent a situation in a gradually rising slope, that each label\n            // will hide the previous one because the previous one always has\n            // lower rank.\n            labels.sort(function (a, b) {\n                return (b.labelrank || 0) - (a.labelrank || 0);\n            });\n\n            // Detect overlapping labels\n            for (i = 0; i < len; i++) {\n                label1 = labels[i];\n\n                for (j = i + 1; j < len; ++j) {\n                    label2 = labels[j];\n                    if (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0) {\n                        pos1 = label1.alignAttr;\n                        pos2 = label2.alignAttr;\n                        parent1 = label1.parentGroup; // Different panes have different positions\n                        parent2 = label2.parentGroup;\n                        padding = 2 * (label1.box ? 0 : label1.padding); // Substract the padding if no background or border (#4333)\n                        isIntersecting = intersectRect(\n                            pos1.x + parent1.translateX,\n                            pos1.y + parent1.translateY,\n                            label1.width - padding,\n                            label1.height - padding,\n                            pos2.x + parent2.translateX,\n                            pos2.y + parent2.translateY,\n                            label2.width - padding,\n                            label2.height - padding\n                        );\n\n                        if (isIntersecting) {\n                            (label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;\n                        }\n                    }\n                }\n            }\n\n            // Hide or show\n            each(labels, function (label) {\n                var complete,\n                    newOpacity;\n\n                if (label) {\n                    newOpacity = label.newOpacity;\n\n                    if (label.oldOpacity !== newOpacity && label.placed) {\n\n                        // Make sure the label is completely hidden to avoid catching clicks (#4362)\n                        if (newOpacity) {\n                            label.show(true);\n                        } else {\n                            complete = function () {\n                                label.hide();\n                            };\n                        }\n\n                        // Animate or set the opacity                \n                        label.alignAttr.opacity = newOpacity;\n                        label[label.isOld ? 'animate' : 'attr'](label.alignAttr, null, complete);\n                    \n                    }\n                    label.isOld = true;\n                }\n            });\n        };\n    }(Highcharts));\n    /**\n     * TrackerMixin for points and graphs\n     */\n\n    var TrackerMixin = Highcharts.TrackerMixin = {\n\n        drawTrackerPoint: function () {\n            var series = this,\n                chart = series.chart,\n                pointer = chart.pointer,\n                cursor = series.options.cursor,\n                css = cursor && { cursor: cursor },\n                onMouseOver = function (e) {\n                    var target = e.target,\n                        point;\n\n                    while (target && !point) {\n                        point = target.point;\n                        target = target.parentNode;\n                    }\n\n                    if (point !== UNDEFINED && point !== chart.hoverPoint) { // undefined on graph in scatterchart\n                        point.onMouseOver(e);\n                    }\n                };\n\n            // Add reference to the point\n            each(series.points, function (point) {\n                if (point.graphic) {\n                    point.graphic.element.point = point;\n                }\n                if (point.dataLabel) {\n                    point.dataLabel.element.point = point;\n                }\n            });\n\n            // Add the event listeners, we need to do this only once\n            if (!series._hasTracking) {\n                each(series.trackerGroups, function (key) {\n                    if (series[key]) { // we don't always have dataLabelsGroup\n                        series[key]\n                            .addClass(PREFIX + 'tracker')\n                            .on('mouseover', onMouseOver)\n                            .on('mouseout', function (e) {\n                                pointer.onTrackerMouseOut(e);\n                            })\n                            .css(css);\n                        if (hasTouch) {\n                            series[key].on('touchstart', onMouseOver);\n                        }\n                    }\n                });\n                series._hasTracking = true;\n            }\n        },\n\n        /**\n         * Draw the tracker object that sits above all data labels and markers to\n         * track mouse events on the graph or points. For the line type charts\n         * the tracker uses the same graphPath, but with a greater stroke width\n         * for better control.\n         */\n        drawTrackerGraph: function () {\n            var series = this,\n                options = series.options,\n                trackByArea = options.trackByArea,\n                trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),\n                trackerPathLength = trackerPath.length,\n                chart = series.chart,\n                pointer = chart.pointer,\n                renderer = chart.renderer,\n                snap = chart.options.tooltip.snap,\n                tracker = series.tracker,\n                cursor = options.cursor,\n                css = cursor && { cursor: cursor },\n                i,\n                onMouseOver = function () {\n                    if (chart.hoverSeries !== series) {\n                        series.onMouseOver();\n                    }\n                },\n                /*\n                 * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable\n                 * IE6: 0.002\n                 * IE7: 0.002\n                 * IE8: 0.002\n                 * IE9: 0.00000000001 (unlimited)\n                 * IE10: 0.0001 (exporting only)\n                 * FF: 0.00000000001 (unlimited)\n                 * Chrome: 0.000001\n                 * Safari: 0.000001\n                 * Opera: 0.00000000001 (unlimited)\n                 */\n                TRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.0001 : 0.002) + ')';\n\n            // Extend end points. A better way would be to use round linecaps,\n            // but those are not clickable in VML.\n            if (trackerPathLength && !trackByArea) {\n                i = trackerPathLength + 1;\n                while (i--) {\n                    if (trackerPath[i] === M) { // extend left side\n                        trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);\n                    }\n                    if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side\n                        trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);\n                    }\n                }\n            }\n\n            // handle single points\n            /*for (i = 0; i < singlePoints.length; i++) {\n                singlePoint = singlePoints[i];\n                trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,\n                L, singlePoint.plotX + snap, singlePoint.plotY);\n            }*/\n\n            // draw the tracker\n            if (tracker) {\n                tracker.attr({ d: trackerPath });\n            } else { // create\n\n                series.tracker = renderer.path(trackerPath)\n                .attr({\n                    'stroke-linejoin': 'round', // #1225\n                    visibility: series.visible ? VISIBLE : HIDDEN,\n                    stroke: TRACKER_FILL,\n                    fill: trackByArea ? TRACKER_FILL : NONE,\n                    'stroke-width': options.lineWidth + (trackByArea ? 0 : 2 * snap),\n                    zIndex: 2\n                })\n                .add(series.group);\n\n                // The tracker is added to the series group, which is clipped, but is covered\n                // by the marker group. So the marker group also needs to capture events.\n                each([series.tracker, series.markerGroup], function (tracker) {\n                    tracker.addClass(PREFIX + 'tracker')\n                        .on('mouseover', onMouseOver)\n                        .on('mouseout', function (e) {\n                            pointer.onTrackerMouseOut(e);\n                        })\n                        .css(css);\n\n                    if (hasTouch) {\n                        tracker.on('touchstart', onMouseOver);\n                    }\n                });\n            }\n        }\n    };\n    /* End TrackerMixin */\n\n\n    /**\n     * Add tracking event listener to the series group, so the point graphics\n     * themselves act as trackers\n     */\n\n    if (seriesTypes.column) {\n        ColumnSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n    }\n\n    if (seriesTypes.pie) {\n        seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n    }\n\n    if (seriesTypes.scatter) {\n        ScatterSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n    }\n\n    /*\n     * Extend Legend for item events\n     */\n    extend(Legend.prototype, {\n\n        setItemEvents: function (item, legendItem, useHTML, itemStyle, itemHiddenStyle) {\n            var legend = this;\n            // Set the events on the item group, or in case of useHTML, the item itself (#1249)\n            (useHTML ? legendItem : item.legendGroup).on('mouseover', function () {\n                item.setState(HOVER_STATE);\n                legendItem.css(legend.options.itemHoverStyle);\n            })\n            .on('mouseout', function () {\n                legendItem.css(item.visible ? itemStyle : itemHiddenStyle);\n                item.setState();\n            })\n            .on('click', function (event) {\n                var strLegendItemClick = 'legendItemClick',\n                    fnLegendItemClick = function () {\n                        if (item.setVisible) {\n                            item.setVisible();\n                        }\n                    };\n\n                // Pass over the click/touch event. #4.\n                event = {\n                    browserEvent: event\n                };\n\n                // click the name or symbol\n                if (item.firePointEvent) { // point\n                    item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);\n                } else {\n                    fireEvent(item, strLegendItemClick, event, fnLegendItemClick);\n                }\n            });\n        },\n\n        createCheckboxForItem: function (item) {\n            var legend = this;\n\n            item.checkbox = createElement('input', {\n                type: 'checkbox',\n                checked: item.selected,\n                defaultChecked: item.selected // required by IE7\n            }, legend.options.itemCheckboxStyle, legend.chart.container);\n\n            addEvent(item.checkbox, 'click', function (event) {\n                var target = event.target;\n                fireEvent(\n                    item.series || item, \n                    'checkboxClick', \n                    { // #3712\n                        checked: target.checked,\n                        item: item\n                    },\n                    function () {\n                        item.select();\n                    }\n                );\n            });\n        }\n    });\n\n    /*\n     * Add pointer cursor to legend itemstyle in defaultOptions\n     */\n    defaultOptions.legend.itemStyle.cursor = 'pointer';\n\n\n    /*\n     * Extend the Chart object with interaction\n     */\n\n    extend(Chart.prototype, {\n        /**\n         * Display the zoom button\n         */\n        showResetZoom: function () {\n            var chart = this,\n                lang = defaultOptions.lang,\n                btnOptions = chart.options.chart.resetZoomButton,\n                theme = btnOptions.theme,\n                states = theme.states,\n                alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';\n\n            function zoomOut() {\n                chart.zoomOut();\n            }\n\n            this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme, states && states.hover)\n                .attr({\n                    align: btnOptions.position.align,\n                    title: lang.resetZoomTitle\n                })\n                .add()\n                .align(btnOptions.position, false, alignTo);\n\n        },\n\n        /**\n         * Zoom out to 1:1\n         */\n        zoomOut: function () {\n            var chart = this;\n            fireEvent(chart, 'selection', { resetSelection: true }, function () {\n                chart.zoom();\n            });\n        },\n\n        /**\n         * Zoom into a given portion of the chart given by axis coordinates\n         * @param {Object} event\n         */\n        zoom: function (event) {\n            var chart = this,\n                hasZoomed,\n                pointer = chart.pointer,\n                displayButton = false,\n                resetZoomButton;\n\n            // If zoom is called with no arguments, reset the axes\n            if (!event || event.resetSelection) {\n                each(chart.axes, function (axis) {\n                    hasZoomed = axis.zoom();\n                });\n            } else { // else, zoom in on all axes\n                each(event.xAxis.concat(event.yAxis), function (axisData) {\n                    var axis = axisData.axis,\n                        isXAxis = axis.isXAxis;\n\n                    // don't zoom more than minRange\n                    if (pointer[isXAxis ? 'zoomX' : 'zoomY'] || pointer[isXAxis ? 'pinchX' : 'pinchY']) {\n                        hasZoomed = axis.zoom(axisData.min, axisData.max);\n                        if (axis.displayBtn) {\n                            displayButton = true;\n                        }\n                    }\n                });\n            }\n\n            // Show or hide the Reset zoom button\n            resetZoomButton = chart.resetZoomButton;\n            if (displayButton && !resetZoomButton) {\n                chart.showResetZoom();\n            } else if (!displayButton && isObject(resetZoomButton)) {\n                chart.resetZoomButton = resetZoomButton.destroy();\n            }\n\n\n            // Redraw\n            if (hasZoomed) {\n                chart.redraw(\n                    pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation\n                );\n            }\n        },\n\n        /**\n         * Pan the chart by dragging the mouse across the pane. This function is called\n         * on mouse move, and the distance to pan is computed from chartX compared to\n         * the first chartX position in the dragging operation.\n         */\n        pan: function (e, panning) {\n\n            var chart = this,\n                hoverPoints = chart.hoverPoints,\n                doRedraw;\n\n            // remove active points for shared tooltip\n            if (hoverPoints) {\n                each(hoverPoints, function (point) {\n                    point.setState();\n                });\n            }\n\n            each(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps\n                var axis = chart[isX ? 'xAxis' : 'yAxis'][0],\n                    horiz = axis.horiz,\n                    mousePos = e[horiz ? 'chartX' : 'chartY'],\n                    mouseDown = horiz ? 'mouseDownX' : 'mouseDownY',\n                    startPos = chart[mouseDown],\n                    halfPointRange = (axis.pointRange || 0) / 2,\n                    extremes = axis.getExtremes(),\n                    newMin = axis.toValue(startPos - mousePos, true) + halfPointRange,\n                    newMax = axis.toValue(startPos + axis.len - mousePos, true) - halfPointRange,\n                    goingLeft = startPos > mousePos; // #3613\n            \n                if (axis.series.length &&\n                        (goingLeft || newMin > mathMin(extremes.dataMin, extremes.min)) &&    \n                        (!goingLeft || newMax < mathMax(extremes.dataMax, extremes.max))) {\n                    axis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });\n                    doRedraw = true;\n                }\n\n                chart[mouseDown] = mousePos; // set new reference for next run\n            });\n\n            if (doRedraw) {\n                chart.redraw(false);\n            }\n            css(chart.container, { cursor: 'move' });\n        }\n    });\n\n    /*\n     * Extend the Point object with interaction\n     */\n    extend(Point.prototype, {\n        /**\n         * Toggle the selection status of a point\n         * @param {Boolean} selected Whether to select or unselect the point.\n         * @param {Boolean} accumulate Whether to add to the previous selection. By default,\n         *         this happens if the control key (Cmd on Mac) was pressed during clicking.\n         */\n        select: function (selected, accumulate) {\n            var point = this,\n                series = point.series,\n                chart = series.chart;\n\n            selected = pick(selected, !point.selected);\n\n            // fire the event with the default handler\n            point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {\n                point.selected = point.options.selected = selected;\n                series.options.data[inArray(point, series.data)] = point.options;\n\n                point.setState(selected && SELECT_STATE);\n\n                // unselect all other points unless Ctrl or Cmd + click\n                if (!accumulate) {\n                    each(chart.getSelectedPoints(), function (loopPoint) {\n                        if (loopPoint.selected && loopPoint !== point) {\n                            loopPoint.selected = loopPoint.options.selected = false;\n                            series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;\n                            loopPoint.setState(NORMAL_STATE);\n                            loopPoint.firePointEvent('unselect');\n                        }\n                    });\n                }\n            });\n        },\n\n        /**\n         * Runs on mouse over the point\n         *\n         * @param {Object} e The event arguments\n         * @param {Boolean} byProximity Falsy for kd points that are closest to the mouse, or to\n         *        actually hovered points. True for other points in shared tooltip.\n         */\n        onMouseOver: function (e, byProximity) {\n            var point = this,\n                series = point.series,\n                chart = series.chart,\n                tooltip = chart.tooltip,\n                hoverPoint = chart.hoverPoint;\n\n            if (chart.hoverSeries !== series) {\n                series.onMouseOver();\n            }\n\n            // set normal state to previous series\n            if (hoverPoint && hoverPoint !== point) {\n                hoverPoint.onMouseOut();\n            }\n\n            if (point.series) { // It may have been destroyed, #4130\n\n                // trigger the event\n                point.firePointEvent('mouseOver');\n\n                // update the tooltip\n                if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {\n                    tooltip.refresh(point, e);\n                }\n\n                // hover this\n                point.setState(HOVER_STATE);\n                if (!byProximity) {\n                    chart.hoverPoint = point;\n                }\n            }\n        },\n\n        /**\n         * Runs on mouse out from the point\n         */\n        onMouseOut: function () {\n            var chart = this.series.chart,\n                hoverPoints = chart.hoverPoints;\n\n            this.firePointEvent('mouseOut');\n\n            if (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887, #2240\n                this.setState();\n                chart.hoverPoint = null;\n            }\n        },\n\n        /**\n         * Import events from the series' and point's options. Only do it on\n         * demand, to save processing time on hovering.\n         */\n        importEvents: function () {\n            if (!this.hasImportedEvents) {\n                var point = this,\n                    options = merge(point.series.options.point, point.options),\n                    events = options.events,\n                    eventType;\n\n                point.events = events;\n\n                for (eventType in events) {\n                    addEvent(point, eventType, events[eventType]);\n                }\n                this.hasImportedEvents = true;\n\n            }\n        },\n\n        /**\n         * Set the point's state\n         * @param {String} state\n         */\n        setState: function (state, move) {\n            var point = this,\n                plotX = mathFloor(point.plotX), // #4586\n                plotY = point.plotY,\n                series = point.series,\n                stateOptions = series.options.states,\n                markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,\n                normalDisabled = markerOptions && !markerOptions.enabled,\n                markerStateOptions = markerOptions && markerOptions.states[state],\n                stateDisabled = markerStateOptions && markerStateOptions.enabled === false,\n                stateMarkerGraphic = series.stateMarkerGraphic,\n                pointMarker = point.marker || {},\n                chart = series.chart,\n                radius,\n                halo = series.halo,\n                haloOptions,\n                newSymbol,\n                pointAttr;\n\n            state = state || NORMAL_STATE; // empty string\n            pointAttr = point.pointAttr[state] || series.pointAttr[state];\n\n            if (\n                    // already has this state\n                    (state === point.state && !move) ||\n                    // selected points don't respond to hover\n                    (point.selected && state !== SELECT_STATE) ||\n                    // series' state options is disabled\n                    (stateOptions[state] && stateOptions[state].enabled === false) ||\n                    // general point marker's state options is disabled\n                    (state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||\n                    // individual point marker's state options is disabled\n                    (state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610\n\n                ) {\n                return;\n            }\n\n            // apply hover styles to the existing point\n            if (point.graphic) {\n                radius = markerOptions && point.graphic.symbolName && pointAttr.r;\n                point.graphic.attr(merge(\n                    pointAttr,\n                    radius ? { // new symbol attributes (#507, #612)\n                        x: plotX - radius,\n                        y: plotY - radius,\n                        width: 2 * radius,\n                        height: 2 * radius\n                    } : {}\n                ));\n\n                // Zooming in from a range with no markers to a range with markers\n                if (stateMarkerGraphic) {\n                    stateMarkerGraphic.hide();\n                }\n            } else {\n                // if a graphic is not applied to each point in the normal state, create a shared\n                // graphic for the hover state\n                if (state && markerStateOptions) {\n                    radius = markerStateOptions.radius;\n                    newSymbol = pointMarker.symbol || series.symbol;\n\n                    // If the point has another symbol than the previous one, throw away the\n                    // state marker graphic and force a new one (#1459)\n                    if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {\n                        stateMarkerGraphic = stateMarkerGraphic.destroy();\n                    }\n\n                    // Add a new state marker graphic\n                    if (!stateMarkerGraphic) {\n                        if (newSymbol) {\n                            series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(\n                                newSymbol,\n                                plotX - radius,\n                                plotY - radius,\n                                2 * radius,\n                                2 * radius\n                            )\n                            .attr(pointAttr)\n                            .add(series.markerGroup);\n                            stateMarkerGraphic.currentSymbol = newSymbol;\n                        }\n\n                    // Move the existing graphic\n                    } else {\n                        stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054\n                            x: plotX - radius,\n                            y: plotY - radius\n                        });\n                    }\n                }\n\n                if (stateMarkerGraphic) {\n                    stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450\n                    stateMarkerGraphic.element.point = point; // #4310\n                }\n            }\n\n            // Show me your halo\n            haloOptions = stateOptions[state] && stateOptions[state].halo;\n            if (haloOptions && haloOptions.size) {\n                if (!halo) {\n                    series.halo = halo = chart.renderer.path()\n                        .add(chart.seriesGroup);\n                }\n                halo.attr(extend({\n                    'fill': point.color || series.color,\n                    'fill-opacity': haloOptions.opacity,\n                    'zIndex': -1 // #4929, IE8 added halo above everything\n                },\n                haloOptions.attributes))[move ? 'animate' : 'attr']({\n                    d: point.haloPath(haloOptions.size)\n                });\n            } else if (halo) {\n                halo.attr({ d: [] });\n            }\n\n            point.state = state;\n        },\n\n        /**\n         * Get the circular path definition for the halo\n         * @param  {Number} size The radius of the circular halo\n         * @returns {Array} The path definition\n         */\n        haloPath: function (size) {\n            var series = this.series,\n                chart = series.chart,\n                plotBox = series.getPlotBox(),\n                inverted = chart.inverted,\n                plotX = Math.floor(this.plotX);\n\n            return chart.renderer.symbols.circle(\n                plotBox.translateX + (inverted ? series.yAxis.len - this.plotY : plotX) - size, \n                plotBox.translateY + (inverted ? series.xAxis.len - plotX : this.plotY) - size, \n                size * 2, \n                size * 2\n            );\n        }\n    });\n\n    /*\n     * Extend the Series object with interaction\n     */\n\n    extend(Series.prototype, {\n        /**\n         * Series mouse over handler\n         */\n        onMouseOver: function () {\n            var series = this,\n                chart = series.chart,\n                hoverSeries = chart.hoverSeries;\n\n            // set normal state to previous series\n            if (hoverSeries && hoverSeries !== series) {\n                hoverSeries.onMouseOut();\n            }\n\n            // trigger the event, but to save processing time,\n            // only if defined\n            if (series.options.events.mouseOver) {\n                fireEvent(series, 'mouseOver');\n            }\n\n            // hover this\n            series.setState(HOVER_STATE);\n            chart.hoverSeries = series;\n        },\n\n        /**\n         * Series mouse out handler\n         */\n        onMouseOut: function () {\n            // trigger the event only if listeners exist\n            var series = this,\n                options = series.options,\n                chart = series.chart,\n                tooltip = chart.tooltip,\n                hoverPoint = chart.hoverPoint;\n\n            chart.hoverSeries = null; // #182, set to null before the mouseOut event fires\n\n            // trigger mouse out on the point, which must be in this series\n            if (hoverPoint) {\n                hoverPoint.onMouseOut();\n            }\n\n            // fire the mouse out event\n            if (series && options.events.mouseOut) {\n                fireEvent(series, 'mouseOut');\n            }\n\n\n            // hide the tooltip\n            if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {\n                tooltip.hide();\n            }\n\n            // set normal state\n            series.setState();\n        },\n\n        /**\n         * Set the state of the graph\n         */\n        setState: function (state) {\n            var series = this,\n                options = series.options,\n                graph = series.graph,\n                stateOptions = options.states,\n                lineWidth = options.lineWidth,\n                attribs,\n                i = 0;\n\n            state = state || NORMAL_STATE;\n\n            if (series.state !== state) {\n                series.state = state;\n\n                if (stateOptions[state] && stateOptions[state].enabled === false) {\n                    return;\n                }\n\n                if (state) {\n                    lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0); // #4035\n                }\n\n                if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML\n                    attribs = {\n                        'stroke-width': lineWidth\n                    };\n                    // use attr because animate will cause any other animation on the graph to stop\n                    graph.attr(attribs);\n                    while (series['zoneGraph' + i]) {\n                        series['zoneGraph' + i].attr(attribs);\n                        i = i + 1;\n                    }\n                }\n            }\n        },\n\n        /**\n         * Set the visibility of the graph\n         *\n         * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,\n         *                the visibility is toggled.\n         */\n        setVisible: function (vis, redraw) {\n            var series = this,\n                chart = series.chart,\n                legendItem = series.legendItem,\n                showOrHide,\n                ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,\n                oldVisibility = series.visible;\n\n            // if called without an argument, toggle visibility\n            series.visible = vis = series.userOptions.visible = vis === UNDEFINED ? !oldVisibility : vis;\n            showOrHide = vis ? 'show' : 'hide';\n\n            // show or hide elements\n            each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker'], function (key) {\n                if (series[key]) {\n                    series[key][showOrHide]();\n                }\n            });\n\n\n            // hide tooltip (#1361)\n            if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {\n                series.onMouseOut();\n            }\n\n\n            if (legendItem) {\n                chart.legend.colorizeItem(series, vis);\n            }\n\n\n            // rescale or adapt to resized chart\n            series.isDirty = true;\n            // in a stack, all other series are affected\n            if (series.options.stacking) {\n                each(chart.series, function (otherSeries) {\n                    if (otherSeries.options.stacking && otherSeries.visible) {\n                        otherSeries.isDirty = true;\n                    }\n                });\n            }\n\n            // show or hide linked series\n            each(series.linkedSeries, function (otherSeries) {\n                otherSeries.setVisible(vis, false);\n            });\n\n            if (ignoreHiddenSeries) {\n                chart.isDirtyBox = true;\n            }\n            if (redraw !== false) {\n                chart.redraw();\n            }\n\n            fireEvent(series, showOrHide);\n        },\n\n        /**\n         * Show the graph\n         */\n        show: function () {\n            this.setVisible(true);\n        },\n\n        /**\n         * Hide the graph\n         */\n        hide: function () {\n            this.setVisible(false);\n        },\n\n\n        /**\n         * Set the selected state of the graph\n         *\n         * @param selected {Boolean} True to select the series, false to unselect. If\n         *                UNDEFINED, the selection state is toggled.\n         */\n        select: function (selected) {\n            var series = this;\n            // if called without an argument, toggle\n            series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;\n\n            if (series.checkbox) {\n                series.checkbox.checked = selected;\n            }\n\n            fireEvent(series, selected ? 'select' : 'unselect');\n        },\n\n        drawTracker: TrackerMixin.drawTrackerGraph\n    });\n\n    // global variables\n    extend(Highcharts, {\n\n        // Constructors\n        Color: Color,\n        Point: Point,\n        Tick: Tick,\n        Renderer: Renderer,\n        SVGElement: SVGElement,\n        SVGRenderer: SVGRenderer,\n\n        // Various\n        arrayMin: arrayMin,\n        arrayMax: arrayMax,\n        charts: charts,\n        dateFormat: dateFormat,\n        error: error,\n        format: format,\n        pathAnim: pathAnim,\n        getOptions: getOptions,\n        hasBidiBug: hasBidiBug,\n        isTouchDevice: isTouchDevice,\n        setOptions: setOptions,\n        addEvent: addEvent,\n        removeEvent: removeEvent,\n        createElement: createElement,\n        discardElement: discardElement,\n        css: css,\n        each: each,\n        map: map,\n        merge: merge,\n        splat: splat,\n        stableSort: stableSort,\n        extendClass: extendClass,\n        pInt: pInt,\n        svg: hasSVG,\n        canvas: useCanVG,\n        vml: !hasSVG && !useCanVG,\n        product: PRODUCT,\n        version: VERSION\n    });\n    \n    return Highcharts;\n}));\n","// ==ClosureCompiler==\n// @compilation_level SIMPLE_OPTIMIZATIONS\n\n/**\n * @license Highcharts JS v4.2.3 (2016-02-08)\n *\n * (c) 2009-2016 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory;\n    } else {\n        factory(Highcharts);\n    }\n}(function (Highcharts) {\nvar arrayMin = Highcharts.arrayMin,\n        arrayMax = Highcharts.arrayMax,\n        each = Highcharts.each,\n        extend = Highcharts.extend,\n        merge = Highcharts.merge,\n        map = Highcharts.map,\n        pick = Highcharts.pick,\n        pInt = Highcharts.pInt,\n        defaultPlotOptions = Highcharts.getOptions().plotOptions,\n        seriesTypes = Highcharts.seriesTypes,\n        extendClass = Highcharts.extendClass,\n        splat = Highcharts.splat,\n        wrap = Highcharts.wrap,\n        Axis = Highcharts.Axis,\n        Tick = Highcharts.Tick,\n        Point = Highcharts.Point,\n        Pointer = Highcharts.Pointer,\n        CenteredSeriesMixin = Highcharts.CenteredSeriesMixin,\n        TrackerMixin = Highcharts.TrackerMixin,\n        Series = Highcharts.Series,\n        math = Math,\n        mathRound = math.round,\n        mathFloor = math.floor,\n        mathMax = math.max,\n        Color = Highcharts.Color,\n        noop = function () {},\n        UNDEFINED;/**\n     * The Pane object allows options that are common to a set of X and Y axes.\n     *\n     * In the future, this can be extended to basic Highcharts and Highstock.\n     */\n    function Pane(options, chart, firstAxis) {\n        this.init(options, chart, firstAxis);\n    }\n\n    // Extend the Pane prototype\n    extend(Pane.prototype, {\n\n        /**\n         * Initiate the Pane object\n         */\n        init: function (options, chart, firstAxis) {\n            var pane = this,\n                backgroundOption,\n                defaultOptions = pane.defaultOptions;\n\n            pane.chart = chart;\n\n            // Set options. Angular charts have a default background (#3318)\n            pane.options = options = merge(defaultOptions, chart.angular ? { background: {} } : undefined, options);\n\n            backgroundOption = options.background;\n\n            // To avoid having weighty logic to place, update and remove the backgrounds,\n            // push them to the first axis' plot bands and borrow the existing logic there.\n            if (backgroundOption) {\n                each([].concat(splat(backgroundOption)).reverse(), function (config) {\n                    var backgroundColor = config.backgroundColor,  // if defined, replace the old one (specific for gradients)\n                        axisUserOptions = firstAxis.userOptions;\n                    config = merge(pane.defaultBackgroundOptions, config);\n                    if (backgroundColor) {\n                        config.backgroundColor = backgroundColor;\n                    }\n                    config.color = config.backgroundColor; // due to naming in plotBands\n                    firstAxis.options.plotBands.unshift(config);\n                    axisUserOptions.plotBands = axisUserOptions.plotBands || []; // #3176\n                    if (axisUserOptions.plotBands !== firstAxis.options.plotBands) {\n                        axisUserOptions.plotBands.unshift(config);\n                    }\n                });\n            }\n        },\n\n        /**\n         * The default options object\n         */\n        defaultOptions: {\n            // background: {conditional},\n            center: ['50%', '50%'],\n            size: '85%',\n            startAngle: 0\n            //endAngle: startAngle + 360\n        },\n\n        /**\n         * The default background options\n         */\n        defaultBackgroundOptions: {\n            shape: 'circle',\n            borderWidth: 1,\n            borderColor: 'silver',\n            backgroundColor: {\n                linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },\n                stops: [\n                    [0, '#FFF'],\n                    [1, '#DDD']\n                ]\n            },\n            from: -Number.MAX_VALUE, // corrected to axis min\n            innerRadius: 0,\n            to: Number.MAX_VALUE, // corrected to axis max\n            outerRadius: '105%'\n        }\n    });\n\n    var axisProto = Axis.prototype,\n        tickProto = Tick.prototype;\n\n    /**\n     * Augmented methods for the x axis in order to hide it completely, used for the X axis in gauges\n     */\n    var hiddenAxisMixin = {\n        getOffset: noop,\n        redraw: function () {\n            this.isDirty = false; // prevent setting Y axis dirty\n        },\n        render: function () {\n            this.isDirty = false; // prevent setting Y axis dirty\n        },\n        setScale: noop,\n        setCategories: noop,\n        setTitle: noop\n    };\n\n    /**\n     * Augmented methods for the value axis\n     */\n    var radialAxisMixin = {\n        isRadial: true,\n\n        /**\n         * The default options extend defaultYAxisOptions\n         */\n        defaultRadialGaugeOptions: {\n            labels: {\n                align: 'center',\n                x: 0,\n                y: null // auto\n            },\n            minorGridLineWidth: 0,\n            minorTickInterval: 'auto',\n            minorTickLength: 10,\n            minorTickPosition: 'inside',\n            minorTickWidth: 1,\n            tickLength: 10,\n            tickPosition: 'inside',\n            tickWidth: 2,\n            title: {\n                rotation: 0\n            },\n            zIndex: 2 // behind dials, points in the series group\n        },\n\n        // Circular axis around the perimeter of a polar chart\n        defaultRadialXOptions: {\n            gridLineWidth: 1, // spokes\n            labels: {\n                align: null, // auto\n                distance: 15,\n                x: 0,\n                y: null // auto\n            },\n            maxPadding: 0,\n            minPadding: 0,\n            showLastLabel: false,\n            tickLength: 0\n        },\n\n        // Radial axis, like a spoke in a polar chart\n        defaultRadialYOptions: {\n            gridLineInterpolation: 'circle',\n            labels: {\n                align: 'right',\n                x: -3,\n                y: -2\n            },\n            showLastLabel: false,\n            title: {\n                x: 4,\n                text: null,\n                rotation: 90\n            }\n        },\n\n        /**\n         * Merge and set options\n         */\n        setOptions: function (userOptions) {\n\n            var options = this.options = merge(\n                this.defaultOptions,\n                this.defaultRadialOptions,\n                userOptions\n            );\n\n            // Make sure the plotBands array is instanciated for each Axis (#2649)\n            if (!options.plotBands) {\n                options.plotBands = [];\n            }\n\n        },\n\n        /**\n         * Wrap the getOffset method to return zero offset for title or labels in a radial\n         * axis\n         */\n        getOffset: function () {\n            // Call the Axis prototype method (the method we're in now is on the instance)\n            axisProto.getOffset.call(this);\n\n            // Title or label offsets are not counted\n            this.chart.axisOffset[this.side] = 0;\n\n            // Set the center array\n            this.center = this.pane.center = CenteredSeriesMixin.getCenter.call(this.pane);\n        },\n\n\n        /**\n         * Get the path for the axis line. This method is also referenced in the getPlotLinePath\n         * method.\n         */\n        getLinePath: function (lineWidth, radius) {\n            var center = this.center;\n            radius = pick(radius, center[2] / 2 - this.offset);\n\n            return this.chart.renderer.symbols.arc(\n                this.left + center[0],\n                this.top + center[1],\n                radius,\n                radius,\n                {\n                    start: this.startAngleRad,\n                    end: this.endAngleRad,\n                    open: true,\n                    innerR: 0\n                }\n            );\n        },\n\n        /**\n         * Override setAxisTranslation by setting the translation to the difference\n         * in rotation. This allows the translate method to return angle for\n         * any given value.\n         */\n        setAxisTranslation: function () {\n\n            // Call uber method\n            axisProto.setAxisTranslation.call(this);\n\n            // Set transA and minPixelPadding\n            if (this.center) { // it's not defined the first time\n                if (this.isCircular) {\n\n                    this.transA = (this.endAngleRad - this.startAngleRad) /\n                        ((this.max - this.min) || 1);\n\n\n                } else {\n                    this.transA = (this.center[2] / 2) / ((this.max - this.min) || 1);\n                }\n\n                if (this.isXAxis) {\n                    this.minPixelPadding = this.transA * this.minPointOffset;\n                } else {\n                    // This is a workaround for regression #2593, but categories still don't position correctly.\n                    this.minPixelPadding = 0;\n                }\n            }\n        },\n\n        /**\n         * In case of auto connect, add one closestPointRange to the max value right before\n         * tickPositions are computed, so that ticks will extend passed the real max.\n         */\n        beforeSetTickPositions: function () {\n            if (this.autoConnect) {\n                this.max += (this.categories && 1) || this.pointRange || this.closestPointRange || 0; // #1197, #2260\n            }\n        },\n\n        /**\n         * Override the setAxisSize method to use the arc's circumference as length. This\n         * allows tickPixelInterval to apply to pixel lengths along the perimeter\n         */\n        setAxisSize: function () {\n\n            axisProto.setAxisSize.call(this);\n\n            if (this.isRadial) {\n\n                // Set the center array\n                this.center = this.pane.center = Highcharts.CenteredSeriesMixin.getCenter.call(this.pane);\n\n                // The sector is used in Axis.translate to compute the translation of reversed axis points (#2570)\n                if (this.isCircular) {\n                    this.sector = this.endAngleRad - this.startAngleRad;\n                }\n\n                // Axis len is used to lay out the ticks\n                this.len = this.width = this.height = this.center[2] * pick(this.sector, 1) / 2;\n\n\n            }\n        },\n\n        /**\n         * Returns the x, y coordinate of a point given by a value and a pixel distance\n         * from center\n         */\n        getPosition: function (value, length) {\n            return this.postTranslate(\n                this.isCircular ? this.translate(value) : 0, // #2848\n                pick(this.isCircular ? length : this.translate(value), this.center[2] / 2) - this.offset\n            );\n        },\n\n        /**\n         * Translate from intermediate plotX (angle), plotY (axis.len - radius) to final chart coordinates.\n         */\n        postTranslate: function (angle, radius) {\n\n            var chart = this.chart,\n                center = this.center;\n\n            angle = this.startAngleRad + angle;\n\n            return {\n                x: chart.plotLeft + center[0] + Math.cos(angle) * radius,\n                y: chart.plotTop + center[1] + Math.sin(angle) * radius\n            };\n\n        },\n\n        /**\n         * Find the path for plot bands along the radial axis\n         */\n        getPlotBandPath: function (from, to, options) {\n            var center = this.center,\n                startAngleRad = this.startAngleRad,\n                fullRadius = center[2] / 2,\n                radii = [\n                    pick(options.outerRadius, '100%'),\n                    options.innerRadius,\n                    pick(options.thickness, 10)\n                ],\n                percentRegex = /%$/,\n                start,\n                end,\n                open,\n                isCircular = this.isCircular, // X axis in a polar chart\n                ret;\n\n            // Polygonal plot bands\n            if (this.options.gridLineInterpolation === 'polygon') {\n                ret = this.getPlotLinePath(from).concat(this.getPlotLinePath(to, true));\n\n            // Circular grid bands\n            } else {\n\n                // Keep within bounds\n                from = Math.max(from, this.min);\n                to = Math.min(to, this.max);\n\n                // Plot bands on Y axis (radial axis) - inner and outer radius depend on to and from\n                if (!isCircular) {\n                    radii[0] = this.translate(from);\n                    radii[1] = this.translate(to);\n                }\n\n                // Convert percentages to pixel values\n                radii = map(radii, function (radius) {\n                    if (percentRegex.test(radius)) {\n                        radius = (pInt(radius, 10) * fullRadius) / 100;\n                    }\n                    return radius;\n                });\n\n                // Handle full circle\n                if (options.shape === 'circle' || !isCircular) {\n                    start = -Math.PI / 2;\n                    end = Math.PI * 1.5;\n                    open = true;\n                } else {\n                    start = startAngleRad + this.translate(from);\n                    end = startAngleRad + this.translate(to);\n                }\n\n\n                ret = this.chart.renderer.symbols.arc(\n                    this.left + center[0],\n                    this.top + center[1],\n                    radii[0],\n                    radii[0],\n                    {\n                        start: Math.min(start, end), // Math is for reversed yAxis (#3606)\n                        end: Math.max(start, end),\n                        innerR: pick(radii[1], radii[0] - radii[2]),\n                        open: open\n                    }\n                );\n            }\n\n            return ret;\n        },\n\n        /**\n         * Find the path for plot lines perpendicular to the radial axis.\n         */\n        getPlotLinePath: function (value, reverse) {\n            var axis = this,\n                center = axis.center,\n                chart = axis.chart,\n                end = axis.getPosition(value),\n                xAxis,\n                xy,\n                tickPositions,\n                ret;\n\n            // Spokes\n            if (axis.isCircular) {\n                ret = ['M', center[0] + chart.plotLeft, center[1] + chart.plotTop, 'L', end.x, end.y];\n\n            // Concentric circles\n            } else if (axis.options.gridLineInterpolation === 'circle') {\n                value = axis.translate(value);\n                if (value) { // a value of 0 is in the center\n                    ret = axis.getLinePath(0, value);\n                }\n            // Concentric polygons\n            } else {\n                // Find the X axis in the same pane\n                each(chart.xAxis, function (a) {\n                    if (a.pane === axis.pane) {\n                        xAxis = a;\n                    }\n                });\n                ret = [];\n                value = axis.translate(value);\n                tickPositions = xAxis.tickPositions;\n                if (xAxis.autoConnect) {\n                    tickPositions = tickPositions.concat([tickPositions[0]]);\n                }\n                // Reverse the positions for concatenation of polygonal plot bands\n                if (reverse) {\n                    tickPositions = [].concat(tickPositions).reverse();\n                }\n\n                each(tickPositions, function (pos, i) {\n                    xy = xAxis.getPosition(pos, value);\n                    ret.push(i ? 'L' : 'M', xy.x, xy.y);\n                });\n\n            }\n            return ret;\n        },\n\n        /**\n         * Find the position for the axis title, by default inside the gauge\n         */\n        getTitlePosition: function () {\n            var center = this.center,\n                chart = this.chart,\n                titleOptions = this.options.title;\n\n            return {\n                x: chart.plotLeft + center[0] + (titleOptions.x || 0),\n                y: chart.plotTop + center[1] - ({ high: 0.5, middle: 0.25, low: 0 }[titleOptions.align] *\n                    center[2]) + (titleOptions.y || 0)\n            };\n        }\n\n    };\n\n    /**\n     * Override axisProto.init to mix in special axis instance functions and function overrides\n     */\n    wrap(axisProto, 'init', function (proceed, chart, userOptions) {\n        var axis = this,\n            angular = chart.angular,\n            polar = chart.polar,\n            isX = userOptions.isX,\n            isHidden = angular && isX,\n            isCircular,\n            startAngleRad,\n            endAngleRad,\n            options,\n            chartOptions = chart.options,\n            paneIndex = userOptions.pane || 0,\n            pane,\n            paneOptions;\n\n        // Before prototype.init\n        if (angular) {\n            extend(this, isHidden ? hiddenAxisMixin : radialAxisMixin);\n            isCircular =  !isX;\n            if (isCircular) {\n                this.defaultRadialOptions = this.defaultRadialGaugeOptions;\n            }\n\n        } else if (polar) {\n            //extend(this, userOptions.isX ? radialAxisMixin : radialAxisMixin);\n            extend(this, radialAxisMixin);\n            isCircular = isX;\n            this.defaultRadialOptions = isX ? this.defaultRadialXOptions : merge(this.defaultYAxisOptions, this.defaultRadialYOptions);\n\n        }\n\n        // Run prototype.init\n        proceed.call(this, chart, userOptions);\n\n        if (!isHidden && (angular || polar)) {\n            options = this.options;\n\n            // Create the pane and set the pane options.\n            if (!chart.panes) {\n                chart.panes = [];\n            }\n            this.pane = pane = chart.panes[paneIndex] = chart.panes[paneIndex] || new Pane(\n                splat(chartOptions.pane)[paneIndex],\n                chart,\n                axis\n            );\n            paneOptions = pane.options;\n\n\n            // Disable certain features on angular and polar axes\n            chart.inverted = false;\n            chartOptions.chart.zoomType = null;\n\n            // Start and end angle options are\n            // given in degrees relative to top, while internal computations are\n            // in radians relative to right (like SVG).\n            this.startAngleRad = startAngleRad = (paneOptions.startAngle - 90) * Math.PI / 180;\n            this.endAngleRad = endAngleRad = (pick(paneOptions.endAngle, paneOptions.startAngle + 360)  - 90) * Math.PI / 180;\n            this.offset = options.offset || 0;\n\n            this.isCircular = isCircular;\n\n            // Automatically connect grid lines?\n            if (isCircular && userOptions.max === UNDEFINED && endAngleRad - startAngleRad === 2 * Math.PI) {\n                this.autoConnect = true;\n            }\n        }\n\n    });\n\n    /**\n     * Wrap auto label align to avoid setting axis-wide rotation on radial axes (#4920)\n     * @param   {Function} proceed\n     * @returns {String} Alignment\n     */\n    wrap(axisProto, 'autoLabelAlign', function (proceed) {\n        if (!this.isRadial) {\n            return proceed.apply(this, [].slice.call(arguments, 1));\n        } // else return undefined\n    });\n\n    /**\n     * Add special cases within the Tick class' methods for radial axes.\n     */\n    wrap(tickProto, 'getPosition', function (proceed, horiz, pos, tickmarkOffset, old) {\n        var axis = this.axis;\n\n        return axis.getPosition ?\n            axis.getPosition(pos) :\n            proceed.call(this, horiz, pos, tickmarkOffset, old);\n    });\n\n    /**\n     * Wrap the getLabelPosition function to find the center position of the label\n     * based on the distance option\n     */\n    wrap(tickProto, 'getLabelPosition', function (proceed, x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n        var axis = this.axis,\n            optionsY = labelOptions.y,\n            ret,\n            centerSlot = 20, // 20 degrees to each side at the top and bottom\n            align = labelOptions.align,\n            angle = ((axis.translate(this.pos) + axis.startAngleRad + Math.PI / 2) / Math.PI * 180) % 360;\n\n        if (axis.isRadial) {\n            ret = axis.getPosition(this.pos, (axis.center[2] / 2) + pick(labelOptions.distance, -25));\n\n            // Automatically rotated\n            if (labelOptions.rotation === 'auto') {\n                label.attr({\n                    rotation: angle\n                });\n\n            // Vertically centered\n            } else if (optionsY === null) {\n                optionsY = axis.chart.renderer.fontMetrics(label.styles.fontSize).b - label.getBBox().height / 2;\n            }\n\n            // Automatic alignment\n            if (align === null) {\n                if (axis.isCircular) {\n                    if (this.label.getBBox().width > axis.len * axis.tickInterval / (axis.max - axis.min)) { // #3506\n                        centerSlot = 0;\n                    }\n                    if (angle > centerSlot && angle < 180 - centerSlot) {\n                        align = 'left'; // right hemisphere\n                    } else if (angle > 180 + centerSlot && angle < 360 - centerSlot) {\n                        align = 'right'; // left hemisphere\n                    } else {\n                        align = 'center'; // top or bottom\n                    }\n                } else {\n                    align = 'center';\n                }\n                label.attr({\n                    align: align\n                });\n            }\n\n            ret.x += labelOptions.x;\n            ret.y += optionsY;\n\n        } else {\n            ret = proceed.call(this, x, y, label, horiz, labelOptions, tickmarkOffset, index, step);\n        }\n        return ret;\n    });\n\n    /**\n     * Wrap the getMarkPath function to return the path of the radial marker\n     */\n    wrap(tickProto, 'getMarkPath', function (proceed, x, y, tickLength, tickWidth, horiz, renderer) {\n        var axis = this.axis,\n            endPoint,\n            ret;\n\n        if (axis.isRadial) {\n            endPoint = axis.getPosition(this.pos, axis.center[2] / 2 + tickLength);\n            ret = [\n                'M',\n                x,\n                y,\n                'L',\n                endPoint.x,\n                endPoint.y\n            ];\n        } else {\n            ret = proceed.call(this, x, y, tickLength, tickWidth, horiz, renderer);\n        }\n        return ret;\n    });/*\n     * The AreaRangeSeries class\n     *\n     */\n\n    /**\n     * Extend the default options with map options\n     */\n    defaultPlotOptions.arearange = merge(defaultPlotOptions.area, {\n        lineWidth: 1,\n        marker: null,\n        threshold: null,\n        tooltip: {\n            pointFormat: '<span style=\"color:{series.color}\">\\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n        },\n        trackByArea: true,\n        dataLabels: {\n            align: null,\n            verticalAlign: null,\n            xLow: 0,\n            xHigh: 0,\n            yLow: 0,\n            yHigh: 0\n        },\n        states: {\n            hover: {\n                halo: false\n            }\n        }\n    });\n\n    /**\n     * Add the series type\n     */\n    seriesTypes.arearange = extendClass(seriesTypes.area, {\n        type: 'arearange',\n        pointArrayMap: ['low', 'high'],\n        dataLabelCollections: ['dataLabel', 'dataLabelUpper'],\n        toYData: function (point) {\n            return [point.low, point.high];\n        },\n        pointValKey: 'low',\n        deferTranslatePolar: true,\n\n        /**\n         * Translate a point's plotHigh from the internal angle and radius measures to\n         * true plotHigh coordinates. This is an addition of the toXY method found in\n         * Polar.js, because it runs too early for arearanges to be considered (#3419).\n         */\n        highToXY: function (point) {\n            // Find the polar plotX and plotY\n            var chart = this.chart,\n                xy = this.xAxis.postTranslate(point.rectPlotX, this.yAxis.len - point.plotHigh);\n            point.plotHighX = xy.x - chart.plotLeft;\n            point.plotHigh = xy.y - chart.plotTop;\n        },\n\n        /**\n         * Translate data points from raw values x and y to plotX and plotY\n         */\n        translate: function () {\n            var series = this,\n                yAxis = series.yAxis;\n\n            seriesTypes.area.prototype.translate.apply(series);\n\n            // Set plotLow and plotHigh\n            each(series.points, function (point) {\n\n                var low = point.low,\n                    high = point.high,\n                    plotY = point.plotY;\n\n                if (high === null || low === null) {\n                    point.isNull = true;\n                } else {\n                    point.plotLow = plotY;\n                    point.plotHigh = yAxis.translate(high, 0, 1, 0, 1);\n                }\n            });\n\n            // Postprocess plotHigh\n            if (this.chart.polar) {\n                each(this.points, function (point) {\n                    series.highToXY(point);\n                });\n            }\n        },\n\n        /**\n         * Extend the line series' getSegmentPath method by applying the segment\n         * path to both lower and higher values of the range\n         */\n        getGraphPath: function () {\n        \n            var points = this.points,\n                highPoints = [],\n                highAreaPoints = [],\n                i = points.length,\n                getGraphPath = Series.prototype.getGraphPath,\n                point,\n                pointShim,\n                linePath,\n                lowerPath,\n                options = this.options,\n                step = options.step,\n                higherPath,\n                higherAreaPath;\n\n            // Create the top line and the top part of the area fill. The area fill compensates for \n            // null points by drawing down to the lower graph, moving across the null gap and \n            // starting again at the lower graph.\n            i = points.length;\n            while (i--) {\n                point = points[i];\n        \n                if (!point.isNull && (!points[i + 1] || points[i + 1].isNull)) {\n                    highAreaPoints.push({\n                        plotX: point.plotX,\n                        plotY: point.plotLow\n                    });\n                }\n                pointShim = {\n                    plotX: point.plotX,\n                    plotY: point.plotHigh,\n                    isNull: point.isNull\n                };\n                highAreaPoints.push(pointShim);\n                highPoints.push(pointShim);\n                if (!point.isNull && (!points[i - 1] || points[i - 1].isNull)) {\n                    highAreaPoints.push({\n                        plotX: point.plotX,\n                        plotY: point.plotLow\n                    });\n                }\n            }\n\n            // Get the paths\n            lowerPath = getGraphPath.call(this, points);\n            if (step) {\n                if (step === true) {\n                    step = 'left';\n                }\n                options.step = { left: 'right', center: 'center', right: 'left' }[step]; // swap for reading in getGraphPath\n            }\n            higherPath = getGraphPath.call(this, highPoints);\n            higherAreaPath = getGraphPath.call(this, highAreaPoints);\n            options.step = step;\n\n            // Create a line on both top and bottom of the range\n            linePath = [].concat(lowerPath, higherPath);\n\n            // For the area path, we need to change the 'move' statement into 'lineTo' or 'curveTo'\n            if (!this.chart.polar && higherAreaPath[0] === 'M') {\n                higherAreaPath[0] = 'L'; // this probably doesn't work for spline        \n            }\n            this.areaPath = this.areaPath.concat(lowerPath, higherAreaPath);\n            return linePath;\n        },\n\n        /**\n         * Extend the basic drawDataLabels method by running it for both lower and higher\n         * values.\n         */\n        drawDataLabels: function () {\n\n            var data = this.data,\n                length = data.length,\n                i,\n                originalDataLabels = [],\n                seriesProto = Series.prototype,\n                dataLabelOptions = this.options.dataLabels,\n                align = dataLabelOptions.align,\n                verticalAlign = dataLabelOptions.verticalAlign,\n                inside = dataLabelOptions.inside,\n                point,\n                up,\n                inverted = this.chart.inverted;\n\n            if (dataLabelOptions.enabled || this._hasPointLabels) {\n\n                // Step 1: set preliminary values for plotY and dataLabel and draw the upper labels\n                i = length;\n                while (i--) {\n                    point = data[i];\n                    if (point) {\n                        up = inside ? point.plotHigh < point.plotLow : point.plotHigh > point.plotLow;\n\n                        // Set preliminary values\n                        point.y = point.high;\n                        point._plotY = point.plotY;\n                        point.plotY = point.plotHigh;\n\n                        // Store original data labels and set preliminary label objects to be picked up\n                        // in the uber method\n                        originalDataLabels[i] = point.dataLabel;\n                        point.dataLabel = point.dataLabelUpper;\n\n                        // Set the default offset\n                        point.below = up;\n                        if (inverted) {\n                            if (!align) {\n                                dataLabelOptions.align = up ? 'right' : 'left';\n                            }\n                        } else {\n                            if (!verticalAlign) {\n                                dataLabelOptions.verticalAlign = up ? 'top' : 'bottom';\n                            }\n                        }\n\n                        dataLabelOptions.x = dataLabelOptions.xHigh;\n                        dataLabelOptions.y = dataLabelOptions.yHigh;\n                    }\n                }\n\n                if (seriesProto.drawDataLabels) {\n                    seriesProto.drawDataLabels.apply(this, arguments); // #1209\n                }\n\n                // Step 2: reorganize and handle data labels for the lower values\n                i = length;\n                while (i--) {\n                    point = data[i];\n                    if (point) {\n                        up = inside ? point.plotHigh < point.plotLow : point.plotHigh > point.plotLow;\n\n                        // Move the generated labels from step 1, and reassign the original data labels\n                        point.dataLabelUpper = point.dataLabel;\n                        point.dataLabel = originalDataLabels[i];\n\n                        // Reset values\n                        point.y = point.low;\n                        point.plotY = point._plotY;\n\n                        // Set the default offset\n                        point.below = !up;\n                        if (inverted) {\n                            if (!align) {\n                                dataLabelOptions.align = up ? 'left' : 'right';\n                            }\n                        } else {\n                            if (!verticalAlign) {\n                                dataLabelOptions.verticalAlign = up ? 'bottom' : 'top';\n                            }\n                        \n                        }\n\n                        dataLabelOptions.x = dataLabelOptions.xLow;\n                        dataLabelOptions.y = dataLabelOptions.yLow;\n                    }\n                }\n                if (seriesProto.drawDataLabels) {\n                    seriesProto.drawDataLabels.apply(this, arguments);\n                }\n            }\n\n            dataLabelOptions.align = align;\n            dataLabelOptions.verticalAlign = verticalAlign;\n        },\n\n        alignDataLabel: function () {\n            seriesTypes.column.prototype.alignDataLabel.apply(this, arguments);\n        },\n\n        setStackedPoints: noop,\n\n        getSymbol: noop,\n\n        drawPoints: noop\n    });\n    /**\n     * The AreaSplineRangeSeries class\n     */\n\n    defaultPlotOptions.areasplinerange = merge(defaultPlotOptions.arearange);\n\n    /**\n     * AreaSplineRangeSeries object\n     */\n    seriesTypes.areasplinerange = extendClass(seriesTypes.arearange, {\n        type: 'areasplinerange',\n        getPointSpline: seriesTypes.spline.prototype.getPointSpline\n    });\n\n    (function () {\n\n        var colProto = seriesTypes.column.prototype;\n\n        /**\n         * The ColumnRangeSeries class\n         */\n        defaultPlotOptions.columnrange = merge(defaultPlotOptions.column, defaultPlotOptions.arearange, {\n            lineWidth: 1,\n            pointRange: null\n        });\n\n        /**\n         * ColumnRangeSeries object\n         */\n        seriesTypes.columnrange = extendClass(seriesTypes.arearange, {\n            type: 'columnrange',\n            /**\n             * Translate data points from raw values x and y to plotX and plotY\n             */\n            translate: function () {\n                var series = this,\n                    yAxis = series.yAxis,\n                    xAxis = series.xAxis,\n                    chart = series.chart,\n                    plotHigh;\n\n                colProto.translate.apply(series);\n\n                // Set plotLow and plotHigh\n                each(series.points, function (point) {\n                    var shapeArgs = point.shapeArgs,\n                        minPointLength = series.options.minPointLength,\n                        heightDifference,\n                        height,\n                        y;\n\n                    point.plotHigh = plotHigh = yAxis.translate(point.high, 0, 1, 0, 1);\n                    point.plotLow = point.plotY;\n\n                    // adjust shape\n                    y = plotHigh;\n                    height = point.plotY - plotHigh;\n\n                    // Adjust for minPointLength\n                    if (Math.abs(height) < minPointLength) {\n                        heightDifference = (minPointLength - height);\n                        height += heightDifference;\n                        y -= heightDifference / 2;\n\n                    // Adjust for negative ranges or reversed Y axis (#1457)\n                    } else if (height < 0) {\n                        height *= -1;\n                        y -= height;\n                    }\n\n                    shapeArgs.height = height;\n                    shapeArgs.y = y;\n\n                    point.tooltipPos = chart.inverted ? \n                        [ \n                            yAxis.len + yAxis.pos - chart.plotLeft - y - height / 2, \n                            xAxis.len + xAxis.pos - chart.plotTop - shapeArgs.x - shapeArgs.width / 2, \n                            height\n                        ] : [\n                            xAxis.left - chart.plotLeft + shapeArgs.x + shapeArgs.width / 2, \n                            yAxis.pos - chart.plotTop + y + height / 2, \n                            height\n                        ]; // don't inherit from column tooltip position - #3372\n                });\n            },\n            directTouch: true,\n            trackerGroups: ['group', 'dataLabelsGroup'],\n            drawGraph: noop,\n            crispCol: colProto.crispCol,\n            pointAttrToOptions: colProto.pointAttrToOptions,\n            drawPoints: colProto.drawPoints,\n            drawTracker: colProto.drawTracker,\n            animate: colProto.animate,\n            getColumnMetrics: colProto.getColumnMetrics\n        });\n    }());\n\n    /*\n     * The GaugeSeries class\n     */\n\n\n\n    /**\n     * Extend the default options\n     */\n    defaultPlotOptions.gauge = merge(defaultPlotOptions.line, {\n        dataLabels: {\n            enabled: true,\n            defer: false,\n            y: 15,\n            borderWidth: 1,\n            borderColor: 'silver',\n            borderRadius: 3,\n            crop: false,\n            verticalAlign: 'top',\n            zIndex: 2\n        },\n        dial: {\n            // radius: '80%',\n            // backgroundColor: 'black',\n            // borderColor: 'silver',\n            // borderWidth: 0,\n            // baseWidth: 3,\n            // topWidth: 1,\n            // baseLength: '70%' // of radius\n            // rearLength: '10%'\n        },\n        pivot: {\n            //radius: 5,\n            //borderWidth: 0\n            //borderColor: 'silver',\n            //backgroundColor: 'black'\n        },\n        tooltip: {\n            headerFormat: ''\n        },\n        showInLegend: false\n    });\n\n    /**\n     * Extend the point object\n     */\n    var GaugePoint = extendClass(Point, {\n        /**\n         * Don't do any hover colors or anything\n         */\n        setState: function (state) {\n            this.state = state;\n        }\n    });\n\n\n    /**\n     * Add the series type\n     */\n    var GaugeSeries = {\n        type: 'gauge',\n        pointClass: GaugePoint,\n\n        // chart.angular will be set to true when a gauge series is present, and this will\n        // be used on the axes\n        angular: true,\n        drawGraph: noop,\n        fixedBox: true,\n        forceDL: true,\n        trackerGroups: ['group', 'dataLabelsGroup'],\n\n        /**\n         * Calculate paths etc\n         */\n        translate: function () {\n\n            var series = this,\n                yAxis = series.yAxis,\n                options = series.options,\n                center = yAxis.center;\n\n            series.generatePoints();\n\n            each(series.points, function (point) {\n\n                var dialOptions = merge(options.dial, point.dial),\n                    radius = (pInt(pick(dialOptions.radius, 80)) * center[2]) / 200,\n                    baseLength = (pInt(pick(dialOptions.baseLength, 70)) * radius) / 100,\n                    rearLength = (pInt(pick(dialOptions.rearLength, 10)) * radius) / 100,\n                    baseWidth = dialOptions.baseWidth || 3,\n                    topWidth = dialOptions.topWidth || 1,\n                    overshoot = options.overshoot,\n                    rotation = yAxis.startAngleRad + yAxis.translate(point.y, null, null, null, true);\n\n                // Handle the wrap and overshoot options\n                if (overshoot && typeof overshoot === 'number') {\n                    overshoot = overshoot / 180 * Math.PI;\n                    rotation = Math.max(yAxis.startAngleRad - overshoot, Math.min(yAxis.endAngleRad + overshoot, rotation));\n\n                } else if (options.wrap === false) {\n                    rotation = Math.max(yAxis.startAngleRad, Math.min(yAxis.endAngleRad, rotation));\n                }\n\n                rotation = rotation * 180 / Math.PI;\n\n                point.shapeType = 'path';\n                point.shapeArgs = {\n                    d: dialOptions.path || [\n                        'M',\n                        -rearLength, -baseWidth / 2,\n                        'L',\n                        baseLength, -baseWidth / 2,\n                        radius, -topWidth / 2,\n                        radius, topWidth / 2,\n                        baseLength, baseWidth / 2,\n                        -rearLength, baseWidth / 2,\n                        'z'\n                    ],\n                    translateX: center[0],\n                    translateY: center[1],\n                    rotation: rotation\n                };\n\n                // Positions for data label\n                point.plotX = center[0];\n                point.plotY = center[1];\n            });\n        },\n\n        /**\n         * Draw the points where each point is one needle\n         */\n        drawPoints: function () {\n\n            var series = this,\n                center = series.yAxis.center,\n                pivot = series.pivot,\n                options = series.options,\n                pivotOptions = options.pivot,\n                renderer = series.chart.renderer;\n\n            each(series.points, function (point) {\n\n                var graphic = point.graphic,\n                    shapeArgs = point.shapeArgs,\n                    d = shapeArgs.d,\n                    dialOptions = merge(options.dial, point.dial); // #1233\n\n                if (graphic) {\n                    graphic.animate(shapeArgs);\n                    shapeArgs.d = d; // animate alters it\n                } else {\n                    point.graphic = renderer[point.shapeType](shapeArgs)\n                        .attr({\n                            stroke: dialOptions.borderColor || 'none',\n                            'stroke-width': dialOptions.borderWidth || 0,\n                            fill: dialOptions.backgroundColor || 'black',\n                            rotation: shapeArgs.rotation, // required by VML when animation is false\n                            zIndex: 1\n                        })\n                        .add(series.group);\n                }\n            });\n\n            // Add or move the pivot\n            if (pivot) {\n                pivot.animate({ // #1235\n                    translateX: center[0],\n                    translateY: center[1]\n                });\n            } else {\n                series.pivot = renderer.circle(0, 0, pick(pivotOptions.radius, 5))\n                    .attr({\n                        'stroke-width': pivotOptions.borderWidth || 0,\n                        stroke: pivotOptions.borderColor || 'silver',\n                        fill: pivotOptions.backgroundColor || 'black',\n                        zIndex: 2\n                    })\n                    .translate(center[0], center[1])\n                    .add(series.group);\n            }\n        },\n\n        /**\n         * Animate the arrow up from startAngle\n         */\n        animate: function (init) {\n            var series = this;\n\n            if (!init) {\n                each(series.points, function (point) {\n                    var graphic = point.graphic;\n\n                    if (graphic) {\n                        // start value\n                        graphic.attr({\n                            rotation: series.yAxis.startAngleRad * 180 / Math.PI\n                        });\n\n                        // animate\n                        graphic.animate({\n                            rotation: point.shapeArgs.rotation\n                        }, series.options.animation);\n                    }\n                });\n\n                // delete this function to allow it only once\n                series.animate = null;\n            }\n        },\n\n        render: function () {\n            this.group = this.plotGroup(\n                'group',\n                'series',\n                this.visible ? 'visible' : 'hidden',\n                this.options.zIndex,\n                this.chart.seriesGroup\n            );\n            Series.prototype.render.call(this);\n            this.group.clip(this.chart.clipRect);\n        },\n\n        /**\n         * Extend the basic setData method by running processData and generatePoints immediately,\n         * in order to access the points from the legend.\n         */\n        setData: function (data, redraw) {\n            Series.prototype.setData.call(this, data, false);\n            this.processData();\n            this.generatePoints();\n            if (pick(redraw, true)) {\n                this.chart.redraw();\n            }\n        },\n\n        /**\n         * If the tracking module is loaded, add the point tracker\n         */\n        drawTracker: TrackerMixin && TrackerMixin.drawTrackerPoint\n    };\n    seriesTypes.gauge = extendClass(seriesTypes.line, GaugeSeries);\n\n    /* ****************************************************************************\n     * Start Box plot series code                                                  *\n     *****************************************************************************/\n\n    // Set default options\n    defaultPlotOptions.boxplot = merge(defaultPlotOptions.column, {\n        fillColor: '#FFFFFF',\n        lineWidth: 1,\n        //medianColor: null,\n        medianWidth: 2,\n        states: {\n            hover: {\n                brightness: -0.3\n            }\n        },\n        //stemColor: null,\n        //stemDashStyle: 'solid'\n        //stemWidth: null,\n        threshold: null,\n        tooltip: {\n            pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> <b> {series.name}</b><br/>' +\n                'Maximum: {point.high}<br/>' +\n                'Upper quartile: {point.q3}<br/>' +\n                'Median: {point.median}<br/>' +\n                'Lower quartile: {point.q1}<br/>' +\n                'Minimum: {point.low}<br/>'\n\n        },\n        //whiskerColor: null,\n        whiskerLength: '50%',\n        whiskerWidth: 2\n    });\n\n    // Create the series object\n    seriesTypes.boxplot = extendClass(seriesTypes.column, {\n        type: 'boxplot',\n        pointArrayMap: ['low', 'q1', 'median', 'q3', 'high'], // array point configs are mapped to this\n        toYData: function (point) { // return a plain array for speedy calculation\n            return [point.low, point.q1, point.median, point.q3, point.high];\n        },\n        pointValKey: 'high', // defines the top of the tracker\n\n        /**\n         * One-to-one mapping from options to SVG attributes\n         */\n        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n            fill: 'fillColor',\n            stroke: 'color',\n            'stroke-width': 'lineWidth'\n        },\n\n        /**\n         * Disable data labels for box plot\n         */\n        drawDataLabels: noop,\n\n        /**\n         * Translate data points from raw values x and y to plotX and plotY\n         */\n        translate: function () {\n            var series = this,\n                yAxis = series.yAxis,\n                pointArrayMap = series.pointArrayMap;\n\n            seriesTypes.column.prototype.translate.apply(series);\n\n            // do the translation on each point dimension\n            each(series.points, function (point) {\n                each(pointArrayMap, function (key) {\n                    if (point[key] !== null) {\n                        point[key + 'Plot'] = yAxis.translate(point[key], 0, 1, 0, 1);\n                    }\n                });\n            });\n        },\n\n        /**\n         * Draw the data points\n         */\n        drawPoints: function () {\n            var series = this,  //state = series.state,\n                points = series.points,\n                options = series.options,\n                chart = series.chart,\n                renderer = chart.renderer,\n                pointAttr,\n                q1Plot,\n                q3Plot,\n                highPlot,\n                lowPlot,\n                medianPlot,\n                crispCorr,\n                crispX,\n                graphic,\n                stemPath,\n                stemAttr,\n                boxPath,\n                whiskersPath,\n                whiskersAttr,\n                medianPath,\n                medianAttr,\n                width,\n                left,\n                right,\n                halfWidth,\n                shapeArgs,\n                color,\n                doQuartiles = series.doQuartiles !== false, // error bar inherits this series type but doesn't do quartiles\n                pointWiskerLength,\n                whiskerLength = series.options.whiskerLength;\n\n\n            each(points, function (point) {\n\n                graphic = point.graphic;\n                shapeArgs = point.shapeArgs; // the box\n                stemAttr = {};\n                whiskersAttr = {};\n                medianAttr = {};\n                color = point.color || series.color;\n\n                if (point.plotY !== UNDEFINED) {\n\n                    pointAttr = point.pointAttr[point.selected ? 'selected' : ''];\n\n                    // crisp vector coordinates\n                    width = shapeArgs.width;\n                    left = mathFloor(shapeArgs.x);\n                    right = left + width;\n                    halfWidth = mathRound(width / 2);\n                    //crispX = mathRound(left + halfWidth) + crispCorr;\n                    q1Plot = mathFloor(doQuartiles ? point.q1Plot : point.lowPlot);// + crispCorr;\n                    q3Plot = mathFloor(doQuartiles ? point.q3Plot : point.lowPlot);// + crispCorr;\n                    highPlot = mathFloor(point.highPlot);// + crispCorr;\n                    lowPlot = mathFloor(point.lowPlot);// + crispCorr;\n\n                    // Stem attributes\n                    stemAttr.stroke = point.stemColor || options.stemColor || color;\n                    stemAttr['stroke-width'] = pick(point.stemWidth, options.stemWidth, options.lineWidth);\n                    stemAttr.dashstyle = point.stemDashStyle || options.stemDashStyle;\n\n                    // Whiskers attributes\n                    whiskersAttr.stroke = point.whiskerColor || options.whiskerColor || color;\n                    whiskersAttr['stroke-width'] = pick(point.whiskerWidth, options.whiskerWidth, options.lineWidth);\n\n                    // Median attributes\n                    medianAttr.stroke = point.medianColor || options.medianColor || color;\n                    medianAttr['stroke-width'] = pick(point.medianWidth, options.medianWidth, options.lineWidth);\n\n                    // The stem\n                    crispCorr = (stemAttr['stroke-width'] % 2) / 2;\n                    crispX = left + halfWidth + crispCorr;\n                    stemPath = [\n                        // stem up\n                        'M',\n                        crispX, q3Plot,\n                        'L',\n                        crispX, highPlot,\n\n                        // stem down\n                        'M',\n                        crispX, q1Plot,\n                        'L',\n                        crispX, lowPlot\n                    ];\n\n                    // The box\n                    if (doQuartiles) {\n                        crispCorr = (pointAttr['stroke-width'] % 2) / 2;\n                        crispX = mathFloor(crispX) + crispCorr;\n                        q1Plot = mathFloor(q1Plot) + crispCorr;\n                        q3Plot = mathFloor(q3Plot) + crispCorr;\n                        left += crispCorr;\n                        right += crispCorr;\n                        boxPath = [\n                            'M',\n                            left, q3Plot,\n                            'L',\n                            left, q1Plot,\n                            'L',\n                            right, q1Plot,\n                            'L',\n                            right, q3Plot,\n                            'L',\n                            left, q3Plot,\n                            'z'\n                        ];\n                    }\n\n                    // The whiskers\n                    if (whiskerLength) {\n                        crispCorr = (whiskersAttr['stroke-width'] % 2) / 2;\n                        highPlot = highPlot + crispCorr;\n                        lowPlot = lowPlot + crispCorr;\n                        pointWiskerLength = (/%$/).test(whiskerLength) ? halfWidth * parseFloat(whiskerLength) / 100 : whiskerLength / 2;\n                        whiskersPath = [\n                            // High whisker\n                            'M',\n                            crispX - pointWiskerLength,\n                            highPlot,\n                            'L',\n                            crispX + pointWiskerLength,\n                            highPlot,\n\n                            // Low whisker\n                            'M',\n                            crispX - pointWiskerLength,\n                            lowPlot,\n                            'L',\n                            crispX + pointWiskerLength,\n                            lowPlot\n                        ];\n                    }\n\n                    // The median\n                    crispCorr = (medianAttr['stroke-width'] % 2) / 2;\n                    medianPlot = mathRound(point.medianPlot) + crispCorr;\n                    medianPath = [\n                        'M',\n                        left,\n                        medianPlot,\n                        'L',\n                        right,\n                        medianPlot\n                    ];\n\n                    // Create or update the graphics\n                    if (graphic) { // update\n\n                        point.stem.animate({ d: stemPath });\n                        if (whiskerLength) {\n                            point.whiskers.animate({ d: whiskersPath });\n                        }\n                        if (doQuartiles) {\n                            point.box.animate({ d: boxPath });\n                        }\n                        point.medianShape.animate({ d: medianPath });\n\n                    } else { // create new\n                        point.graphic = graphic = renderer.g()\n                            .add(series.group);\n\n                        point.stem = renderer.path(stemPath)\n                            .attr(stemAttr)\n                            .add(graphic);\n\n                        if (whiskerLength) {\n                            point.whiskers = renderer.path(whiskersPath)\n                                .attr(whiskersAttr)\n                                .add(graphic);\n                        }\n                        if (doQuartiles) {\n                            point.box = renderer.path(boxPath)\n                                .attr(pointAttr)\n                                .add(graphic);\n                        }\n                        point.medianShape = renderer.path(medianPath)\n                            .attr(medianAttr)\n                            .add(graphic);\n                    }\n                }\n            });\n\n        },\n        setStackedPoints: noop // #3890\n\n\n    });\n\n    /* ****************************************************************************\n     * End Box plot series code                                                *\n     *****************************************************************************/\n    /* ****************************************************************************\n     * Start error bar series code                                                *\n     *****************************************************************************/\n\n    // 1 - set default options\n    defaultPlotOptions.errorbar = merge(defaultPlotOptions.boxplot, {\n        color: '#000000',\n        grouping: false,\n        linkedTo: ':previous',\n        tooltip: {\n            pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n        },\n        whiskerWidth: null\n    });\n\n    // 2 - Create the series object\n    seriesTypes.errorbar = extendClass(seriesTypes.boxplot, {\n        type: 'errorbar',\n        pointArrayMap: ['low', 'high'], // array point configs are mapped to this\n        toYData: function (point) { // return a plain array for speedy calculation\n            return [point.low, point.high];\n        },\n        pointValKey: 'high', // defines the top of the tracker\n        doQuartiles: false,\n        drawDataLabels: seriesTypes.arearange ? seriesTypes.arearange.prototype.drawDataLabels : noop,\n\n        /**\n         * Get the width and X offset, either on top of the linked series column\n         * or standalone\n         */\n        getColumnMetrics: function () {\n            return (this.linkedParent && this.linkedParent.columnMetrics) ||\n                seriesTypes.column.prototype.getColumnMetrics.call(this);\n        }\n    });\n\n    /* ****************************************************************************\n     * End error bar series code                                                  *\n     *****************************************************************************/\n    /* ****************************************************************************\n     * Start Waterfall series code                                                *\n     *****************************************************************************/\n\n    // 1 - set default options\n    defaultPlotOptions.waterfall = merge(defaultPlotOptions.column, {\n        lineWidth: 1,\n        lineColor: '#333',\n        dashStyle: 'dot',\n        borderColor: '#333',\n        dataLabels: {\n            inside: true\n        },\n        states: {\n            hover: {\n                lineWidthPlus: 0 // #3126\n            }\n        }\n    });\n\n\n    // 2 - Create the series object\n    seriesTypes.waterfall = extendClass(seriesTypes.column, {\n        type: 'waterfall',\n\n        upColorProp: 'fill',\n\n        pointValKey: 'y',\n\n        /**\n         * Translate data points from raw values\n         */\n        translate: function () {\n            var series = this,\n                options = series.options,\n                yAxis = series.yAxis,\n                len,\n                i,\n                points,\n                point,\n                shapeArgs,\n                stack,\n                y,\n                yValue,\n                previousY,\n                previousIntermediate,\n                range,\n                minPointLength = pick(options.minPointLength, 5),\n                threshold = options.threshold,\n                stacking = options.stacking,\n                tooltipY;\n\n            // run column series translate\n            seriesTypes.column.prototype.translate.apply(this);\n            series.minPointLengthOffset = 0;\n\n            previousY = previousIntermediate = threshold;\n            points = series.points;\n\n            for (i = 0, len = points.length; i < len; i++) {\n                // cache current point object\n                point = points[i];\n                yValue = this.processedYData[i];\n                shapeArgs = point.shapeArgs;\n\n                // get current stack\n                stack = stacking && yAxis.stacks[(series.negStacks && yValue < threshold ? '-' : '') + series.stackKey];\n                range = stack ?\n                    stack[point.x].points[series.index + ',' + i] :\n                    [0, yValue];\n\n                // override point value for sums\n                // #3710 Update point does not propagate to sum\n                if (point.isSum) {\n                    point.y = yValue;\n                } else if (point.isIntermediateSum) {\n                    point.y = yValue - previousIntermediate; // #3840\n                }\n                // up points\n                y = mathMax(previousY, previousY + point.y) + range[0];\n                shapeArgs.y = yAxis.translate(y, 0, 1);\n\n\n                // sum points\n                if (point.isSum) {\n                    shapeArgs.y = yAxis.translate(range[1], 0, 1);\n                    shapeArgs.height = Math.min(yAxis.translate(range[0], 0, 1), yAxis.len) - shapeArgs.y + series.minPointLengthOffset; // #4256\n\n                } else if (point.isIntermediateSum) {\n                    shapeArgs.y = yAxis.translate(range[1], 0, 1);\n                    shapeArgs.height = Math.min(yAxis.translate(previousIntermediate, 0, 1), yAxis.len) - shapeArgs.y + series.minPointLengthOffset;\n                    previousIntermediate = range[1];\n\n                // If it's not the sum point, update previous stack end position and get\n                // shape height (#3886)\n                } else {\n                    if (previousY !== 0) { // Not the first point\n                        shapeArgs.height = yValue > 0 ?\n                            yAxis.translate(previousY, 0, 1) - shapeArgs.y :\n                            yAxis.translate(previousY, 0, 1) - yAxis.translate(previousY - yValue, 0, 1);\n                    }\n                    previousY += yValue;\n                }\n                // #3952 Negative sum or intermediate sum not rendered correctly\n                if (shapeArgs.height < 0) {\n                    shapeArgs.y += shapeArgs.height;\n                    shapeArgs.height *= -1;\n                }\n\n                point.plotY = shapeArgs.y = mathRound(shapeArgs.y) - (series.borderWidth % 2) / 2;\n                shapeArgs.height = mathMax(mathRound(shapeArgs.height), 0.001); // #3151\n                point.yBottom = shapeArgs.y + shapeArgs.height;\n\n                if (shapeArgs.height <= minPointLength) {\n                    shapeArgs.height = minPointLength;\n                    series.minPointLengthOffset += minPointLength;\n                }\n\n                shapeArgs.y -= series.minPointLengthOffset;\n\n                // Correct tooltip placement (#3014)\n                tooltipY = point.plotY + (point.negative ? shapeArgs.height : 0) - series.minPointLengthOffset;\n                if (series.chart.inverted) {\n                    point.tooltipPos[0] = yAxis.len - tooltipY;\n                } else {\n                    point.tooltipPos[1] = tooltipY;\n                }\n\n            }\n        },\n\n        /**\n         * Call default processData then override yData to reflect waterfall's extremes on yAxis\n         */\n        processData: function (force) {\n            var series = this,\n                options = series.options,\n                yData = series.yData,\n                points = series.options.data, // #3710 Update point does not propagate to sum\n                point,\n                dataLength = yData.length,\n                threshold = options.threshold || 0,\n                subSum,\n                sum,\n                dataMin,\n                dataMax,\n                y,\n                i;\n\n            sum = subSum = dataMin = dataMax = threshold;\n\n            for (i = 0; i < dataLength; i++) {\n                y = yData[i];\n                point = points && points[i] ? points[i] : {};\n\n                if (y === 'sum' || point.isSum) {\n                    yData[i] = sum;\n                } else if (y === 'intermediateSum' || point.isIntermediateSum) {\n                    yData[i] = subSum;\n                } else {\n                    sum += y;\n                    subSum += y;\n                }\n                dataMin = Math.min(sum, dataMin);\n                dataMax = Math.max(sum, dataMax);\n            }\n\n            Series.prototype.processData.call(this, force);\n\n            // Record extremes\n            series.dataMin = dataMin;\n            series.dataMax = dataMax;\n        },\n\n        /**\n         * Return y value or string if point is sum\n         */\n        toYData: function (pt) {\n            if (pt.isSum) {\n                return (pt.x === 0 ? null : 'sum'); //#3245 Error when first element is Sum or Intermediate Sum\n            }\n            if (pt.isIntermediateSum) {\n                return (pt.x === 0 ? null : 'intermediateSum'); //#3245\n            }\n            return pt.y;\n        },\n\n        /**\n         * Postprocess mapping between options and SVG attributes\n         */\n        getAttribs: function () {\n            seriesTypes.column.prototype.getAttribs.apply(this, arguments);\n\n            var series = this,\n                options = series.options,\n                stateOptions = options.states,\n                upColor = options.upColor || series.color,\n                hoverColor = Highcharts.Color(upColor).brighten(0.1).get(),\n                seriesDownPointAttr = merge(series.pointAttr),\n                upColorProp = series.upColorProp;\n\n            seriesDownPointAttr[''][upColorProp] = upColor;\n            seriesDownPointAttr.hover[upColorProp] = stateOptions.hover.upColor || hoverColor;\n            seriesDownPointAttr.select[upColorProp] = stateOptions.select.upColor || upColor;\n\n            each(series.points, function (point) {\n                if (!point.options.color) {\n                    // Up color\n                    if (point.y > 0) {\n                        point.pointAttr = seriesDownPointAttr;\n                        point.color = upColor;\n\n                    // Down color (#3710, update to negative)\n                    } else {\n                        point.pointAttr = series.pointAttr;\n                    }\n                }\n            });\n        },\n\n        /**\n         * Draw columns' connector lines\n         */\n        getGraphPath: function () {\n\n            var data = this.data,\n                length = data.length,\n                lineWidth = this.options.lineWidth + this.borderWidth,\n                normalizer = mathRound(lineWidth) % 2 / 2,\n                path = [],\n                M = 'M',\n                L = 'L',\n                prevArgs,\n                pointArgs,\n                i,\n                d;\n\n            for (i = 1; i < length; i++) {\n                pointArgs = data[i].shapeArgs;\n                prevArgs = data[i - 1].shapeArgs;\n\n                d = [\n                    M,\n                    prevArgs.x + prevArgs.width, prevArgs.y + normalizer,\n                    L,\n                    pointArgs.x, prevArgs.y + normalizer\n                ];\n\n                if (data[i - 1].y < 0) {\n                    d[2] += prevArgs.height;\n                    d[5] += prevArgs.height;\n                }\n\n                path = path.concat(d);\n            }\n\n            return path;\n        },\n\n        /**\n         * Extremes are recorded in processData\n         */\n        getExtremes: noop,\n\n        drawGraph: Series.prototype.drawGraph\n    });\n\n    /* ****************************************************************************\n     * End Waterfall series code                                                  *\n     *****************************************************************************/\n    /**\n     * Set the default options for polygon\n     */\n    defaultPlotOptions.polygon = merge(defaultPlotOptions.scatter, {\n        marker: {\n            enabled: false\n        }\n    });\n\n    /**\n     * The polygon series class\n     */\n    seriesTypes.polygon = extendClass(seriesTypes.scatter, {\n        type: 'polygon',\n        fillGraph: true,\n        // Close all segments\n        getSegmentPath: function (segment) {\n            return Series.prototype.getSegmentPath.call(this, segment).concat('z');\n        },\n        drawGraph: Series.prototype.drawGraph,\n        drawLegendSymbol: Highcharts.LegendSymbolMixin.drawRectangle\n    });\n    /* ****************************************************************************\n     * Start Bubble series code                                                      *\n     *****************************************************************************/\n\n    // 1 - set default options\n    defaultPlotOptions.bubble = merge(defaultPlotOptions.scatter, {\n        dataLabels: {\n            formatter: function () { // #2945\n                return this.point.z;\n            },\n            inside: true,\n            verticalAlign: 'middle'\n        },\n        // displayNegative: true,\n        marker: {\n            // fillOpacity: 0.5,\n            lineColor: null, // inherit from series.color\n            lineWidth: 1\n        },\n        minSize: 8,\n        maxSize: '20%',\n        // negativeColor: null,\n        // sizeBy: 'area'\n        softThreshold: false,\n        states: {\n            hover: {\n                halo: {\n                    size: 5\n                }\n            }\n        },\n        tooltip: {\n            pointFormat: '({point.x}, {point.y}), Size: {point.z}'\n        },\n        turboThreshold: 0,\n        zThreshold: 0,\n        zoneAxis: 'z'\n    });\n\n    var BubblePoint = extendClass(Point, {\n        haloPath: function () {\n            return Point.prototype.haloPath.call(this, this.shapeArgs.r + this.series.options.states.hover.halo.size);\n        },\n        ttBelow: false\n    });\n\n    // 2 - Create the series object\n    seriesTypes.bubble = extendClass(seriesTypes.scatter, {\n        type: 'bubble',\n        pointClass: BubblePoint,\n        pointArrayMap: ['y', 'z'],\n        parallelArrays: ['x', 'y', 'z'],\n        trackerGroups: ['group', 'dataLabelsGroup'],\n        bubblePadding: true,\n        zoneAxis: 'z',\n\n        /**\n         * Mapping between SVG attributes and the corresponding options\n         */\n        pointAttrToOptions: {\n            stroke: 'lineColor',\n            'stroke-width': 'lineWidth',\n            fill: 'fillColor'\n        },\n\n        /**\n         * Apply the fillOpacity to all fill positions\n         */\n        applyOpacity: function (fill) {\n            var markerOptions = this.options.marker,\n                fillOpacity = pick(markerOptions.fillOpacity, 0.5);\n\n            // When called from Legend.colorizeItem, the fill isn't predefined\n            fill = fill || markerOptions.fillColor || this.color;\n\n            if (fillOpacity !== 1) {\n                fill = Color(fill).setOpacity(fillOpacity).get('rgba');\n            }\n            return fill;\n        },\n\n        /**\n         * Extend the convertAttribs method by applying opacity to the fill\n         */\n        convertAttribs: function () {\n            var obj = Series.prototype.convertAttribs.apply(this, arguments);\n\n            obj.fill = this.applyOpacity(obj.fill);\n\n            return obj;\n        },\n\n        /**\n         * Get the radius for each point based on the minSize, maxSize and each point's Z value. This\n         * must be done prior to Series.translate because the axis needs to add padding in\n         * accordance with the point sizes.\n         */\n        getRadii: function (zMin, zMax, minSize, maxSize) {\n            var len,\n                i,\n                pos,\n                zData = this.zData,\n                radii = [],\n                options = this.options,\n                sizeByArea = options.sizeBy !== 'width',\n                zThreshold = options.zThreshold,\n                zRange = zMax - zMin,\n                value,\n                radius;\n\n            // Set the shape type and arguments to be picked up in drawPoints\n            for (i = 0, len = zData.length; i < len; i++) {\n\n                value = zData[i];\n\n                // When sizing by threshold, the absolute value of z determines the size\n                // of the bubble.\n                if (options.sizeByAbsoluteValue && value !== null) {\n                    value = Math.abs(value - zThreshold);\n                    zMax = Math.max(zMax - zThreshold, Math.abs(zMin - zThreshold));\n                    zMin = 0;\n                }\n\n                if (value === null) {\n                    radius = null;\n                // Issue #4419 - if value is less than zMin, push a radius that's always smaller than the minimum size\n                } else if (value < zMin) {\n                    radius = minSize / 2 - 1;\n                } else {\n                    // Relative size, a number between 0 and 1\n                    pos = zRange > 0 ? (value - zMin) / zRange : 0.5;\n\n                    if (sizeByArea && pos >= 0) {\n                        pos = Math.sqrt(pos);\n                    }\n                    radius = math.ceil(minSize + pos * (maxSize - minSize)) / 2;\n                }\n                radii.push(radius);\n            }\n            this.radii = radii;\n        },\n\n        /**\n         * Perform animation on the bubbles\n         */\n        animate: function (init) {\n            var animation = this.options.animation;\n\n            if (!init) { // run the animation\n                each(this.points, function (point) {\n                    var graphic = point.graphic,\n                        shapeArgs = point.shapeArgs;\n\n                    if (graphic && shapeArgs) {\n                        // start values\n                        graphic.attr('r', 1);\n\n                        // animate\n                        graphic.animate({\n                            r: shapeArgs.r\n                        }, animation);\n                    }\n                });\n\n                // delete this function to allow it only once\n                this.animate = null;\n            }\n        },\n\n        /**\n         * Extend the base translate method to handle bubble size\n         */\n        translate: function () {\n\n            var i,\n                data = this.data,\n                point,\n                radius,\n                radii = this.radii;\n\n            // Run the parent method\n            seriesTypes.scatter.prototype.translate.call(this);\n\n            // Set the shape type and arguments to be picked up in drawPoints\n            i = data.length;\n\n            while (i--) {\n                point = data[i];\n                radius = radii ? radii[i] : 0; // #1737\n\n                if (typeof radius === 'number' && radius >= this.minPxSize / 2) {\n                    // Shape arguments\n                    point.shapeType = 'circle';\n                    point.shapeArgs = {\n                        x: point.plotX,\n                        y: point.plotY,\n                        r: radius\n                    };\n\n                    // Alignment box for the data label\n                    point.dlBox = {\n                        x: point.plotX - radius,\n                        y: point.plotY - radius,\n                        width: 2 * radius,\n                        height: 2 * radius\n                    };\n                } else { // below zThreshold or z = null\n                    point.shapeArgs = point.plotY = point.dlBox = UNDEFINED; // #1691\n                }\n            }\n        },\n\n        /**\n         * Get the series' symbol in the legend\n         *\n         * @param {Object} legend The legend object\n         * @param {Object} item The series (this) or point\n         */\n        drawLegendSymbol: function (legend, item) {\n            var renderer = this.chart.renderer,\n                radius = renderer.fontMetrics(legend.itemStyle.fontSize).f / 2;\n\n            item.legendSymbol = renderer.circle(\n                radius,\n                legend.baseline - radius,\n                radius\n            ).attr({\n                zIndex: 3\n            }).add(item.legendGroup);\n            item.legendSymbol.isMarker = true;\n\n        },\n\n        drawPoints: seriesTypes.column.prototype.drawPoints,\n        alignDataLabel: seriesTypes.column.prototype.alignDataLabel,\n        buildKDTree: noop,\n        applyZones: noop\n    });\n\n    /**\n     * Add logic to pad each axis with the amount of pixels\n     * necessary to avoid the bubbles to overflow.\n     */\n    Axis.prototype.beforePadding = function () {\n        var axis = this,\n            axisLength = this.len,\n            chart = this.chart,\n            pxMin = 0,\n            pxMax = axisLength,\n            isXAxis = this.isXAxis,\n            dataKey = isXAxis ? 'xData' : 'yData',\n            min = this.min,\n            extremes = {},\n            smallestSize = math.min(chart.plotWidth, chart.plotHeight),\n            zMin = Number.MAX_VALUE,\n            zMax = -Number.MAX_VALUE,\n            range = this.max - min,\n            transA = axisLength / range,\n            activeSeries = [];\n\n        // Handle padding on the second pass, or on redraw\n        each(this.series, function (series) {\n\n            var seriesOptions = series.options,\n                zData;\n\n            if (series.bubblePadding && (series.visible || !chart.options.chart.ignoreHiddenSeries)) {\n\n                // Correction for #1673\n                axis.allowZoomOutside = true;\n\n                // Cache it\n                activeSeries.push(series);\n\n                if (isXAxis) { // because X axis is evaluated first\n\n                    // For each series, translate the size extremes to pixel values\n                    each(['minSize', 'maxSize'], function (prop) {\n                        var length = seriesOptions[prop],\n                            isPercent = /%$/.test(length);\n\n                        length = pInt(length);\n                        extremes[prop] = isPercent ?\n                            smallestSize * length / 100 :\n                            length;\n\n                    });\n                    series.minPxSize = extremes.minSize;\n                    series.maxPxSize = extremes.maxSize;\n\n                    // Find the min and max Z\n                    zData = series.zData;\n                    if (zData.length) { // #1735\n                        zMin = pick(seriesOptions.zMin, math.min(\n                            zMin,\n                            math.max(\n                                arrayMin(zData),\n                                seriesOptions.displayNegative === false ? seriesOptions.zThreshold : -Number.MAX_VALUE\n                            )\n                        ));\n                        zMax = pick(seriesOptions.zMax, math.max(zMax, arrayMax(zData)));\n                    }\n                }\n            }\n        });\n\n        each(activeSeries, function (series) {\n\n            var data = series[dataKey],\n                i = data.length,\n                radius;\n\n            if (isXAxis) {\n                series.getRadii(zMin, zMax, series.minPxSize, series.maxPxSize);\n            }\n\n            if (range > 0) {\n                while (i--) {\n                    if (typeof data[i] === 'number') {\n                        radius = series.radii[i];\n                        pxMin = Math.min(((data[i] - min) * transA) - radius, pxMin);\n                        pxMax = Math.max(((data[i] - min) * transA) + radius, pxMax);\n                    }\n                }\n            }\n        });\n\n\n        if (activeSeries.length && range > 0 && !this.isLog) {\n            pxMax -= axisLength;\n            transA *= (axisLength + pxMin - pxMax) / axisLength;\n            each([['min', 'userMin', pxMin], ['max', 'userMax', pxMax]], function (keys) {\n                if (pick(axis.options[keys[0]], axis[keys[1]]) === UNDEFINED) {\n                    axis[keys[0]] += keys[2] / transA;\n                }\n            });\n        }\n    };\n\n    /* ****************************************************************************\n     * End Bubble series code                                                     *\n     *****************************************************************************/\n\n    (function () {\n\n        /**\n         * Extensions for polar charts. Additionally, much of the geometry required for polar charts is\n         * gathered in RadialAxes.js.\n         *\n         */\n\n        var seriesProto = Series.prototype,\n            pointerProto = Pointer.prototype,\n            colProto;\n\n        /**\n         * Search a k-d tree by the point angle, used for shared tooltips in polar charts\n         */\n        seriesProto.searchPointByAngle = function (e) {\n            var series = this,\n                chart = series.chart,\n                xAxis = series.xAxis,\n                center = xAxis.pane.center,\n                plotX = e.chartX - center[0] - chart.plotLeft,\n                plotY = e.chartY - center[1] - chart.plotTop;\n\n            return this.searchKDTree({\n                clientX: 180 + (Math.atan2(plotX, plotY) * (-180 / Math.PI))\n            });\n\n        };\n\n        /**\n         * Wrap the buildKDTree function so that it searches by angle (clientX) in case of shared tooltip,\n         * and by two dimensional distance in case of non-shared.\n         */\n        wrap(seriesProto, 'buildKDTree', function (proceed) {\n            if (this.chart.polar) {\n                if (this.kdByAngle) {\n                    this.searchPoint = this.searchPointByAngle;\n                } else {\n                    this.kdDimensions = 2;\n                }\n            }\n            proceed.apply(this);\n        });\n\n        /**\n         * Translate a point's plotX and plotY from the internal angle and radius measures to\n         * true plotX, plotY coordinates\n         */\n        seriesProto.toXY = function (point) {\n            var xy,\n                chart = this.chart,\n                plotX = point.plotX,\n                plotY = point.plotY,\n                clientX;\n\n            // Save rectangular plotX, plotY for later computation\n            point.rectPlotX = plotX;\n            point.rectPlotY = plotY;\n\n            // Find the polar plotX and plotY\n            xy = this.xAxis.postTranslate(point.plotX, this.yAxis.len - plotY);\n            point.plotX = point.polarPlotX = xy.x - chart.plotLeft;\n            point.plotY = point.polarPlotY = xy.y - chart.plotTop;\n\n            // If shared tooltip, record the angle in degrees in order to align X points. Otherwise,\n            // use a standard k-d tree to get the nearest point in two dimensions.\n            if (this.kdByAngle) {\n                clientX = ((plotX / Math.PI * 180) + this.xAxis.pane.options.startAngle) % 360;\n                if (clientX < 0) { // #2665\n                    clientX += 360;\n                }\n                point.clientX = clientX;\n            } else {\n                point.clientX = point.plotX;\n            }\n        };\n\n        if (seriesTypes.spline) {\n            /**\n             * Overridden method for calculating a spline from one point to the next\n             */\n            wrap(seriesTypes.spline.prototype, 'getPointSpline', function (proceed, segment, point, i) {\n\n                var ret,\n                    smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc;\n                    denom = smoothing + 1,\n                    plotX,\n                    plotY,\n                    lastPoint,\n                    nextPoint,\n                    lastX,\n                    lastY,\n                    nextX,\n                    nextY,\n                    leftContX,\n                    leftContY,\n                    rightContX,\n                    rightContY,\n                    distanceLeftControlPoint,\n                    distanceRightControlPoint,\n                    leftContAngle,\n                    rightContAngle,\n                    jointAngle;\n\n\n                if (this.chart.polar) {\n\n                    plotX = point.plotX;\n                    plotY = point.plotY;\n                    lastPoint = segment[i - 1];\n                    nextPoint = segment[i + 1];\n\n                    // Connect ends\n                    if (this.connectEnds) {\n                        if (!lastPoint) {\n                            lastPoint = segment[segment.length - 2]; // not the last but the second last, because the segment is already connected\n                        }\n                        if (!nextPoint) {\n                            nextPoint = segment[1];\n                        }\n                    }\n\n                    // find control points\n                    if (lastPoint && nextPoint) {\n\n                        lastX = lastPoint.plotX;\n                        lastY = lastPoint.plotY;\n                        nextX = nextPoint.plotX;\n                        nextY = nextPoint.plotY;\n                        leftContX = (smoothing * plotX + lastX) / denom;\n                        leftContY = (smoothing * plotY + lastY) / denom;\n                        rightContX = (smoothing * plotX + nextX) / denom;\n                        rightContY = (smoothing * plotY + nextY) / denom;\n                        distanceLeftControlPoint = Math.sqrt(Math.pow(leftContX - plotX, 2) + Math.pow(leftContY - plotY, 2));\n                        distanceRightControlPoint = Math.sqrt(Math.pow(rightContX - plotX, 2) + Math.pow(rightContY - plotY, 2));\n                        leftContAngle = Math.atan2(leftContY - plotY, leftContX - plotX);\n                        rightContAngle = Math.atan2(rightContY - plotY, rightContX - plotX);\n                        jointAngle = (Math.PI / 2) + ((leftContAngle + rightContAngle) / 2);\n\n\n                        // Ensure the right direction, jointAngle should be in the same quadrant as leftContAngle\n                        if (Math.abs(leftContAngle - jointAngle) > Math.PI / 2) {\n                            jointAngle -= Math.PI;\n                        }\n\n                        // Find the corrected control points for a spline straight through the point\n                        leftContX = plotX + Math.cos(jointAngle) * distanceLeftControlPoint;\n                        leftContY = plotY + Math.sin(jointAngle) * distanceLeftControlPoint;\n                        rightContX = plotX + Math.cos(Math.PI + jointAngle) * distanceRightControlPoint;\n                        rightContY = plotY + Math.sin(Math.PI + jointAngle) * distanceRightControlPoint;\n\n                        // Record for drawing in next point\n                        point.rightContX = rightContX;\n                        point.rightContY = rightContY;\n\n                    }\n\n\n                    // moveTo or lineTo\n                    if (!i) {\n                        ret = ['M', plotX, plotY];\n                    } else { // curve from last point to this\n                        ret = [\n                            'C',\n                            lastPoint.rightContX || lastPoint.plotX,\n                            lastPoint.rightContY || lastPoint.plotY,\n                            leftContX || plotX,\n                            leftContY || plotY,\n                            plotX,\n                            plotY\n                        ];\n                        lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later\n                    }\n\n\n                } else {\n                    ret = proceed.call(this, segment, point, i);\n                }\n                return ret;\n            });\n        }\n\n        /**\n         * Extend translate. The plotX and plotY values are computed as if the polar chart were a\n         * cartesian plane, where plotX denotes the angle in radians and (yAxis.len - plotY) is the pixel distance from\n         * center.\n         */\n        wrap(seriesProto, 'translate', function (proceed) {\n            var chart = this.chart,\n                points,\n                i;\n\n            // Run uber method\n            proceed.call(this);\n\n            // Postprocess plot coordinates\n            if (chart.polar) {\n                this.kdByAngle = chart.tooltip && chart.tooltip.shared;\n\n                if (!this.preventPostTranslate) {\n                    points = this.points;\n                    i = points.length;\n\n                    while (i--) {\n                        // Translate plotX, plotY from angle and radius to true plot coordinates\n                        this.toXY(points[i]);\n                    }\n                }\n            }\n        });\n\n        /**\n         * Extend getSegmentPath to allow connecting ends across 0 to provide a closed circle in\n         * line-like series.\n         */\n        wrap(seriesProto, 'getGraphPath', function (proceed, points) {\n            var series = this;\n        \n            // Connect the path\n            if (this.chart.polar) {\n                points = points || this.points;\n    \n                if (this.options.connectEnds !== false && points[0].y !== null) {\n                    this.connectEnds = true; // re-used in splines\n                    points.splice(points.length, 0, points[0]);\n                }\n\n                // For area charts, pseudo points are added to the graph, now we need to translate these\n                each(points, function (point) {\n                    if (point.polarPlotY === undefined) {\n                        series.toXY(point);\n                    }\n                });\n            }\n\n            // Run uber method\n            return proceed.apply(this, [].slice.call(arguments, 1));\n    \n        });\n\n\n        function polarAnimate(proceed, init) {\n            var chart = this.chart,\n                animation = this.options.animation,\n                group = this.group,\n                markerGroup = this.markerGroup,\n                center = this.xAxis.center,\n                plotLeft = chart.plotLeft,\n                plotTop = chart.plotTop,\n                attribs;\n\n            // Specific animation for polar charts\n            if (chart.polar) {\n\n                // Enable animation on polar charts only in SVG. In VML, the scaling is different, plus animation\n                // would be so slow it would't matter.\n                if (chart.renderer.isSVG) {\n\n                    if (animation === true) {\n                        animation = {};\n                    }\n\n                    // Initialize the animation\n                    if (init) {\n\n                        // Scale down the group and place it in the center\n                        attribs = {\n                            translateX: center[0] + plotLeft,\n                            translateY: center[1] + plotTop,\n                            scaleX: 0.001, // #1499\n                            scaleY: 0.001\n                        };\n\n                        group.attr(attribs);\n                        if (markerGroup) {\n                            //markerGroup.attrSetters = group.attrSetters;\n                            markerGroup.attr(attribs);\n                        }\n\n                    // Run the animation\n                    } else {\n                        attribs = {\n                            translateX: plotLeft,\n                            translateY: plotTop,\n                            scaleX: 1,\n                            scaleY: 1\n                        };\n                        group.animate(attribs, animation);\n                        if (markerGroup) {\n                            markerGroup.animate(attribs, animation);\n                        }\n\n                        // Delete this function to allow it only once\n                        this.animate = null;\n                    }\n                }\n\n            // For non-polar charts, revert to the basic animation\n            } else {\n                proceed.call(this, init);\n            }\n        }\n\n        // Define the animate method for regular series\n        wrap(seriesProto, 'animate', polarAnimate);\n\n\n        if (seriesTypes.column) {\n\n            colProto = seriesTypes.column.prototype;\n            /**\n            * Define the animate method for columnseries\n            */\n            wrap(colProto, 'animate', polarAnimate);\n\n\n            /**\n             * Extend the column prototype's translate method\n             */\n            wrap(colProto, 'translate', function (proceed) {\n\n                var xAxis = this.xAxis,\n                    len = this.yAxis.len,\n                    center = xAxis.center,\n                    startAngleRad = xAxis.startAngleRad,\n                    renderer = this.chart.renderer,\n                    start,\n                    points,\n                    point,\n                    i;\n\n                this.preventPostTranslate = true;\n\n                // Run uber method\n                proceed.call(this);\n\n                // Postprocess plot coordinates\n                if (xAxis.isRadial) {\n                    points = this.points;\n                    i = points.length;\n                    while (i--) {\n                        point = points[i];\n                        start = point.barX + startAngleRad;\n                        point.shapeType = 'path';\n                        point.shapeArgs = {\n                            d: renderer.symbols.arc(\n                                center[0],\n                                center[1],\n                                len - point.plotY,\n                                null,\n                                {\n                                    start: start,\n                                    end: start + point.pointWidth,\n                                    innerR: len - pick(point.yBottom, len)\n                                }\n                            )\n                        };\n                        // Provide correct plotX, plotY for tooltip\n                        this.toXY(point);\n                        point.tooltipPos = [point.plotX, point.plotY];\n                        point.ttBelow = point.plotY > center[1];\n                    }\n                }\n            });\n\n\n            /**\n             * Align column data labels outside the columns. #1199.\n             */\n            wrap(colProto, 'alignDataLabel', function (proceed, point, dataLabel, options, alignTo, isNew) {\n\n                if (this.chart.polar) {\n                    var angle = point.rectPlotX / Math.PI * 180,\n                        align,\n                        verticalAlign;\n\n                    // Align nicely outside the perimeter of the columns\n                    if (options.align === null) {\n                        if (angle > 20 && angle < 160) {\n                            align = 'left'; // right hemisphere\n                        } else if (angle > 200 && angle < 340) {\n                            align = 'right'; // left hemisphere\n                        } else {\n                            align = 'center'; // top or bottom\n                        }\n                        options.align = align;\n                    }\n                    if (options.verticalAlign === null) {\n                        if (angle < 45 || angle > 315) {\n                            verticalAlign = 'bottom'; // top part\n                        } else if (angle > 135 && angle < 225) {\n                            verticalAlign = 'top'; // bottom part\n                        } else {\n                            verticalAlign = 'middle'; // left or right\n                        }\n                        options.verticalAlign = verticalAlign;\n                    }\n\n                    seriesProto.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);\n                } else {\n                    proceed.call(this, point, dataLabel, options, alignTo, isNew);\n                }\n\n            });\n        }\n\n        /**\n         * Extend getCoordinates to prepare for polar axis values\n         */\n        wrap(pointerProto, 'getCoordinates', function (proceed, e) {\n            var chart = this.chart,\n                ret = {\n                    xAxis: [],\n                    yAxis: []\n                };\n\n            if (chart.polar) {\n\n                each(chart.axes, function (axis) {\n                    var isXAxis = axis.isXAxis,\n                        center = axis.center,\n                        x = e.chartX - center[0] - chart.plotLeft,\n                        y = e.chartY - center[1] - chart.plotTop;\n\n                    ret[isXAxis ? 'xAxis' : 'yAxis'].push({\n                        axis: axis,\n                        value: axis.translate(\n                            isXAxis ?\n                                Math.PI - Math.atan2(x, y) : // angle\n                                Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)), // distance from center\n                            true\n                        )\n                    });\n                });\n\n            } else {\n                ret = proceed.call(this, e);\n            }\n\n            return ret;\n        });\n\n    }());\n\n}));\n","(function(chart) {\n    'use strict';\n\n    chart.onDomReady = function() {\n        //No need to do anything on domReady\n    };\n\n    chart.render = function(container, jsonUrl, options) {\n        if ($(container).length >= 1) {\n\n            //get dates from daterangepicker\n            var graphType    = kukua.getGraphType()\n            var selectedDate = kukua.getDateRangePicker()\n            var interval     = kukua.getGraphInterval()\n            var country = kukua.getGraphCountry()\n\n            var postdata = {\n                'region': 1,\n                'type': graphType.val(),\n                'dateFrom': selectedDate.data('daterangepicker').startDate.startOf('day').format('X'),\n                'dateTo': selectedDate.data('daterangepicker').endDate.endOf('day').format('X'),\n                'interval': interval.val()\n            }\n\n            var call = $.ajax({\n                type: 'POST',\n                url: jsonUrl,\n                data: postdata,\n                dataType: 'json',\n                beforeSend: function() {\n                    $(container).html(\"<div class='loading'></div>\");\n                }\n            })\n\n            call.done(function(request) {\n                var result = []\n\t\t\t\toptions.series = [];\n                if (request != null && request.length > 0) {\n\t\t\t\t\toptions.series = request;\n                }\n\n                //Combine given options with default options\n                var opt = $.extend({}, chart.getOptions(), options)\n\n                //render\n                $(container).highcharts(opt)\n            })\n        }\n    };\n\n    chart.getOptions = function() {\n        var options = new Object({\n            title: {\n                text: \"\",\n\t\t\t\talign: \"left\",\n\t\t\t\tstyle: {\n\t\t\t\t\tfontSize: \"26px\",\n\t\t\t\t\tfontFamily: \"Asap, Trebuchet MS\"\n\t\t\t\t}\n            },\n            xAxis: {\n                type: 'datetime',\n                labels: {\n                    rotation: -45,\n                    align: 'right',\n                },\n                title: {\n                    text: 'Date/Time',\n                },\n                crosshair: true,\n                events: {\n                    afterSetExtremes: function(event){\n                        var extremes = this.getExtremes();\n\n                        //Set daterangepicker object\n                        kukua.getDateRangePicker().daterangepicker({\n                            ranges: kukua.getDatePickerRanges(),\n                            startDate: moment(extremes.min),\n                            endDate: moment(extremes.max)\n                        }, kukua.datePickerCallback)\n\n                        //Rebind\n                        kukua.datePickerChange()\n                        kukua.datePickerCallback(moment(extremes.min), moment(extremes.max));\n                    }\n                },\n                alternateGridColor: \"#f7f7f7\"\n            },\n            tooltip: {\n                shared: true,\n                valueSuffix: '',\n            },\n            legend: {\n                align: 'center',\n                verticalAlign: 'bottom',\n                layout: 'horizontal',\n            },\n            yAxis: {\n                title: {\n                    text: ''\n                }\n            },\n            chart: {\n\t\t\t\tstyle: {\n\t\t\t\t\tfontFamily: 'Trebuchet MS',\n\t\t\t\t},\n                zoomType: 'x',\n            },\n            plotOptions: {\n                series: {\n                    cropTreshhold: 5000,\n                    states: {\n                        hover: {\n                            enabled: false\n                        }\n                    },\n                },\n                line: {\n                    turboThreshold: 5000,\n                    lineWidth: 1\n                }\n            },\n            credits: {\n                enabled: false\n            }\n        });\n\n        return options;\n    };\n\n})(window.chart = window.chart || {});\n$(document).ready(chart.onDomReady);\n","(function(kukua) {\n\t'use strict';\n\tkukua.onDomReady = function() {\n\n\t\t//Initializations\n\t\tkukua.datePickerInit()\n\t\tkukua.datePickerCallback(moment(), moment())\n\n\t\t//bind onChange reload graph\n\t\tkukua.formChanges()\n\t\tkukua.graph()\n\t};\n\n\tkukua.datePickerInit = function() {\n\t\tkukua.getDateRangePicker().daterangepicker({\n\t\t\tranges: kukua.getDatePickerRanges()\n\t\t}, kukua.datePickerCallback)\n\t};\n\n\tkukua.getDatePickerRanges = function() {\n\t\treturn {\n\t\t   'Today': [moment().startOf('day'), moment().endOf('day')],\n\t\t   'Tomorrow': [moment().add(1, 'days').startOf('day'), moment().add(1, 'days').endOf('day')],\n\t\t   'Yesterday': [moment().subtract(1, 'day').startOf('day'), moment().subtract(1, 'day').endOf('day')],\n\t\t   'Last 7 Days': [moment().subtract(6, 'days').startOf('day'), moment().endOf('day')],\n\t\t   'Last 30 Days': [moment().subtract(30, 'days').startOf('day'), moment().endOf('day')]\n\t\t}\n\t};\n\n\tkukua.datePickerCallback = function(start, end) {\n\t\tvar startDate = start.startOf('day')\n\t\tvar endDate   = end.endOf('day')\n\n\t\tkukua.getDateRangePickerSpan().html(startDate.format('DD-MM-YYYY') + ' - ' + endDate.format('DD-MM-YYYY'))\n\t\t$('input#dateFrom').val(startDate.format(\"X\"))\n\t\t$('input#dateTo').val(endDate.format(\"X\"))\n\t};\n\n\tkukua.graph = function() {\n\t\tvar graphCountry\t= kukua.getGraphCountry()\n\t\tvar graphType\t\t= kukua.getGraphType()\n\t\tvar graphTypeText\t= kukua.getGraphTypeText()\n\t\tvar graphInterval\t= kukua.getGraphInterval()\n\n\t\tvar options = chart.getOptions()\n\t\toptions.chart.zoomType = 'x'\n\t\toptions.title.text = graphTypeText\n\n\t\tvar item = graphType.find(\":selected\").data('text');\n\t\tswitch(item) {\n\t\t\tcase 'Temperature':\n\t\t\t\toptions.chart.type = \"line\"\n\t\t\t\toptions.yAxis.title.text = graphTypeText + \" (C)\"\n\t\t\t\toptions.tooltip.valueSuffix = 'C'\n\t\t\t\tbreak\n\t\t\tcase 'Humidity':\n\t\t\t\toptions.chart.type = \"line\"\n\t\t\t\toptions.yAxis.title.text = graphTypeText + \" (%)\"\n\t\t\t\toptions.tooltip.valueSuffix = ' (%)'\n\t\t\t\tbreak\n\t\t\tcase 'Pressure':\n\t\t\t\toptions.chart.type = \"line\"\n\t\t\t\toptions.yAxis.title.text = graphTypeText + \" (hPa)\"\n\t\t\t\toptions.tooltip.valueSuffix = ' (hPa)'\n\t\t\t\tbreak\n\t\t\tcase 'Rainfall':\n\t\t\t\toptions.chart.type = \"column\"\n\t\t\t\toptions.yAxis.title.text = graphTypeText + \" (mm)\"\n\t\t\t\toptions.tooltip.valueSuffix = ' mm'\n\t\t\t\tbreak\n\t\t\tcase 'Wind':\n\t\t\t\toptions.chart.type = \"line\"\n\t\t\t\toptions.yAxis.title.text = graphTypeText + \" (km/h)\"\n\t\t\t\toptions.tooltip.valueSuffix = ' km/h'\n\t\t\t\tbreak;\n\t\t}\n\t\tchart.render(\"#chart\", \"/ajax.php\", options)\n\t};\n\n\tkukua.datePickerChange = function() {\n\t\tkukua.getDateRangePicker().on(\"apply.daterangepicker\", function(ev, picker) {\n\t\t\tkukua.graph()\n\t\t})\n\t};\n\n\tkukua.formChanges = function() {\n\t\tkukua.datePickerChange();\n\t\tkukua.getGraphInterval().on(\"change\", function() {\n\t\t\tkukua.graph()\n\t\t})\n\t\tkukua.getGraphType().on(\"change\", function() {\n\t\t\tkukua.graph()\n\t\t})\n\t};\n\n\tkukua.getGraphCountry = function() {\n\t\treturn $(\"#js-graph-country\")\n\t};\n\tkukua.getGraphInterval = function() {\n\t\treturn $('#js-graph-show-per')\n\t};\n\tkukua.getGraphType = function() {\n\t\treturn $(\"#js-graph-type-swap\")\n\t};\n\tkukua.getGraphTypeText = function() {\n\t\tvar input = kukua.getGraphType()\n\t\treturn input.find(\"option:selected\").text()\n\t};\n\tkukua.getDateRangePicker = function() {\n\t\treturn $(\"#reportrange\")\n\t};\n\tkukua.getDateRangePickerSpan = function() {\n\t\treturn $(\"#reportrange span\")\n\t};\n\n})(window.kukua = window.kukua || {});\n$(document).ready(kukua.onDomReady);\n","(function(helpers) {\n\t'use strict';\n\n\thelpers.onDomReady = function() {\n\t\thelpers.forecast();\n\n\t\thelpers.confirmDelete()\n\t\thelpers.confirmDisable()\n\t\thelpers.confirmRevoke()\n\t\thelpers.confirmGrant()\n\t\thelpers.feedbackDisplay()\n\t\thelpers.feedbackPost()\n\n\t\thelpers.tableRowClick()\n\t};\n\n\thelpers.forecast = function() {\n\t\t$(\"#js-forecast-country\").on('change', function () {\n\t\t\tvar postCountry = {\n\t\t\t\t\"country\": $(this).val()\n\t\t\t}\n\t\t\tvar call = $.ajax({\n\t\t\t\ttype: 'POST',\n\t\t\t\turl: '/forecast/get/',\n\t\t\t\tdata: postCountry,\n\t\t\t\tdataType: 'json'\n\t\t\t})\n\n\t\t\tcall.done(function(request) {\n\t\t\t\t$(\".js-iframe\").html('<iframe src=\"' + request.url + '\" frameborder=\"0\" width=\"802px\" height=\"802px\"></iframe>');\n\t\t\t})\n\t\t}).trigger(\"change\");\n\t}\n\n\t/**\n\t * Display confirm box on delete\n\t */\n\thelpers.confirmDelete = function() {\n\t\t$(\".js-confirm-delete\").unbind(\"click\");\n\t\t$(\".js-confirm-delete\").on(\"click\", function() {\n\t\t\tvar txt = \"Are you sure you want to delete this?\";\n\t\t\tif ($(this).data(\"text\")) {\n\t\t\t\ttxt = $(this).data(\"text\");\n\t\t\t}\n\t\t\tvar x = confirm(txt)\n\t\t\tif (x == true) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\t};\n\n\t/**\n\t * Display confirm box on disable\n\t */\n\thelpers.confirmDisable = function() {\n\t\t$(\".js-confirm-disable\").unbind(\"click\");\n\t\t$(\".js-confirm-disable\").on(\"click\", function() {\n\t\t\tvar x = confirm(\"Are you sure you want to disable this?\")\n\t\t\tif (x == true) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\t};\n\n\t/**\n\t * Display confirm box on user access revoke\n\t */\n\thelpers.confirmRevoke = function() {\n\t\t$(\".js-confirm-revoke\").on(\"click\", function() {\n\t\t\tvar x = confirm(\"Are you sure you want to revoke these rights?\")\n\t\t\tif (x == true) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\t};\n\n\t/**\n\t * Display confirm box on user access grant\n\t */\n\thelpers.confirmGrant = function() {\n\t\t$(\".js-confirm-grant\").on(\"click\", function() {\n\t\t\tvar x = confirm(\"Are you sure you want to grant these rights?\")\n\t\t\tif (x == true) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\t};\n\n\t/**\n\t * Display feedback box\n\t */\n\thelpers.feedbackDisplay = function() {\n\t\t$(\".js-feedback\").on(\"click\", function(e) {\n\t\t\te.preventDefault();\n\t\t\tif ($(this).parent().hasClass(\"open\")) {\n\t\t\t\t$(\".js-feedback\").parent().removeClass(\"open\");\n\t\t\t} else {\n\t\t\t\t$(\".js-feedback\").parent().addClass(\"open\");\n\t\t\t}\n\t\t})\n\t};\n\n\t/**\n\t * Feedback post ajax handle\n\t */\n\thelpers.feedbackPost = function() {\n\t\tvar form = $('.js-post-feedback');\n\t\tform.on(\"submit\", function(e) {\n\t\t\te.preventDefault();\n\t\t\t$.ajax({\n\t\t\t\ttype: \"POST\",\n\t\t\t\turl:  \"/feedback/create\",\n\t\t\t\tdata: form.serialize(),\n\t\t\t\tpostData: \"json\",\n\t\t\t\tsuccess: function(data) {\n\t\t\t\t\tvar result = JSON.parse(data)\n\t\t\t\t\tif (result.success == true) {\n\t\t\t\t\t\t$(\".js-feedback-result\").html(\"<i class='glyphicon glyphicon-ok'></i> Thanks for your feedback!\")\n\t\t\t\t\t\t$(\".js-feedback-submit\").attr(\"disabled\", \"disabled\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$(\".js-feedback-result\").html(result.message)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n\n\thelpers.removeStation = function() {\n\t\tvar item = $(\".js-remove-station\");\n\t\titem.on(\"click\", function(e) {\n\t\t\tvar $this = $(this);\n\t\t\tvar x = confirm(\"Are you sure you want to delete this station?\")\n\t\t\tif (x == true) {\n\t\t\t\t$.ajax({\n\t\t\t\t\ttype: \"GET\",\n\t\t\t\t\turl: \"/locations/delete_station/\" + item.data(\"station_id\"),\n\t\t\t\t\tsuccess: function(data) {\n\t\t\t\t\t\t$this.parent(\"td\").parent(\"tr\").fadeOut()\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\t}\n\n\thelpers.tableRowClick = function() {\n\t\t$(\".js-row-link td\").on(\"click\", function() {\n\t\t\tif ($(this).children(\"a\").length > 1) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\twindow.document.location = $(this).parent('tr').data(\"href\");\n\t\t\t}\n\t\t})\n\t}\n})(window.helpers = window.helpers || {});\n$(document).ready(helpers.onDomReady);\n"],"sourceRoot":"/source/"}